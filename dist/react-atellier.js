(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactAtellier"] = factory(require("react"), require("react-dom"));
	else
		root["ReactAtellier"] = factory(root["react"], root["react-dom"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_16__, __WEBPACK_EXTERNAL_MODULE_43__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Atellier = __webpack_require__(15);

	var _Atellier2 = _interopRequireDefault(_Atellier);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _Atellier2.default;

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _immutable = __webpack_require__(17);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _Sidebar = __webpack_require__(18);

	var _Sidebar2 = _interopRequireDefault(_Sidebar);

	var _Workspace = __webpack_require__(22);

	var _Workspace2 = _interopRequireDefault(_Workspace);

	var _DefaultPropsMerger = __webpack_require__(44);

	var _DefaultPropsMerger2 = _interopRequireDefault(_DefaultPropsMerger);

	__webpack_require__(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Atellier = function (_React$Component) {
	  _inherits(Atellier, _React$Component);

	  function Atellier(props) {
	    _classCallCheck(this, Atellier);

	    var _this = _possibleConstructorReturn(this, (Atellier.__proto__ || Object.getPrototypeOf(Atellier)).call(this, props));

	    _this._handleSelectComponent = function (component, key) {
	      component.indexKey = key;
	      _this.setState({ stagedComponent: component });
	    };

	    _this.state = {
	      components: _immutable2.default.List((0, _DefaultPropsMerger2.default)(props.components)),
	      stagedComponent: null
	    };
	    return _this;
	  }

	  _createClass(Atellier, [{
	    key: 'render',
	    value: function render() {
	      var _state = this.state,
	          components = _state.components,
	          stagedComponent = _state.stagedComponent;

	      return _react2.default.createElement(
	        'div',
	        { className: 'atellier' },
	        _react2.default.createElement(_Sidebar2.default, { components: components, stagedComponent: stagedComponent, onSelect: this._handleSelectComponent }),
	        _react2.default.createElement(_Workspace2.default, { components: components, component: stagedComponent, onCloseProperties: this._handleSelectComponent })
	      );
	    }
	  }]);

	  return Atellier;
	}(_react2.default.Component);

	// commonjs2


	Atellier.defaultProps = {
	  components: []
	};
	Atellier.propTypes = {
	  components: _react.PropTypes.arrayOf(_react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string,
	    defaultAtellierProps: _react.PropTypes.object,
	    extraPropTypes: _react.PropTypes.object
	  }))
	};
	exports.default = Atellier;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32âˆ’1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _immutable = __webpack_require__(17);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _ComponentList = __webpack_require__(20);

	var _ComponentList2 = _interopRequireDefault(_ComponentList);

	var _arrow = __webpack_require__(21);

	var _arrow2 = _interopRequireDefault(_arrow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Sidebar = function (_React$Component) {
	  _inherits(Sidebar, _React$Component);

	  function Sidebar(props) {
	    _classCallCheck(this, Sidebar);

	    var _this = _possibleConstructorReturn(this, (Sidebar.__proto__ || Object.getPrototypeOf(Sidebar)).call(this, props));

	    _this._handleToggleSidebar = function () {
	      _this.setState({ close: !_this.state.close });
	    };

	    _this.state = {
	      close: false
	    };
	    return _this;
	  }

	  _createClass(Sidebar, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          components = _props.components,
	          stagedComponent = _props.stagedComponent,
	          onSelect = _props.onSelect;

	      var className = (0, _classnames2.default)('sidebar', { 'sidebar-close': this.state.close });
	      return _react2.default.createElement(
	        'div',
	        { className: className },
	        _react2.default.createElement(
	          'h1',
	          { className: 'logo' },
	          'ATELLIER'
	        ),
	        _react2.default.createElement(
	          'span',
	          { className: 'sidebar-toggle-button', onClick: this._handleToggleSidebar },
	          _react2.default.createElement('img', { src: _arrow2.default })
	        ),
	        _react2.default.createElement(_ComponentList2.default, { components: components, stagedComponent: stagedComponent, onSelect: onSelect })
	      );
	    }
	  }]);

	  return Sidebar;
	}(_react2.default.Component);

	Sidebar.defaultProps = {
	  components: [],
	  onSelect: _react.PropTypes.func,
	  stagedComponent: {}
	};
	Sidebar.propTypes = {
	  components: _react.PropTypes.instanceOf(_immutable2.default.List),
	  onSelect: _react.PropTypes.func,
	  stagedComponent: _react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string,
	    defaultAtellierProps: _react.PropTypes.object,
	    extraPropTypes: _react.PropTypes.object
	  })
	};
	exports.default = Sidebar;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _immutable = __webpack_require__(17);

	var _immutable2 = _interopRequireDefault(_immutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ComponentList = function (_React$Component) {
	  _inherits(ComponentList, _React$Component);

	  function ComponentList(props) {
	    _classCallCheck(this, ComponentList);

	    var _this = _possibleConstructorReturn(this, (ComponentList.__proto__ || Object.getPrototypeOf(ComponentList)).call(this, props));

	    _this._handleSelectComponentItem = function (component, key) {
	      return function () {
	        _this.props.onSelect(component, key);
	      };
	    };

	    _this._handleFilterComponents = function (event) {
	      _this.setState({ filter: event.target.value });
	    };

	    _this.state = {
	      filter: ''
	    };
	    return _this;
	  }

	  _createClass(ComponentList, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        { className: 'component-nav' },
	        _react2.default.createElement(
	          'div',
	          { className: 'component-tools' },
	          _react2.default.createElement('input', { type: 'text',
	            className: 'component-filter atellier-input atellier-input-icon',
	            placeholder: 'Search components',
	            onChange: this._handleFilterComponents })
	        ),
	        _react2.default.createElement(
	          'ul',
	          { className: 'component-list' },
	          this._renderComponentListItems()
	        )
	      );
	    }
	  }, {
	    key: '_getInvalidComponents',
	    value: function _getInvalidComponents() {
	      return JSON.parse(localStorage.getItem('invalidComponents')) || [];
	    }
	  }, {
	    key: '_isInvalidComponent',
	    value: function _isInvalidComponent(component, indexKey) {
	      var invalidComponents = this._getInvalidComponents();
	      var exists = invalidComponents.find(function (item) {
	        return item.componentName === component.componentName && item.indexKey === indexKey;
	      });
	      return !!exists;
	    }
	  }, {
	    key: '_renderComponentListItems',
	    value: function _renderComponentListItems() {
	      var _this2 = this;

	      return this.props.components.filter(function (_ref) {
	        var componentName = _ref.componentName;

	        return ~componentName.toLowerCase().indexOf(_this2.state.filter.toLowerCase());
	      }).map(function (component, key) {
	        var className = (0, _classnames2.default)('component-list-item', {
	          'component-list-item-error': _this2._isInvalidComponent(component, key),
	          'component-list-item-selected': _immutable2.default.is(component, _this2.props.stagedComponent)
	        });

	        return _react2.default.createElement(
	          'li',
	          { key: key, className: className, onClick: _this2._handleSelectComponentItem(component, key) },
	          component.componentName
	        );
	      });
	    }
	  }]);

	  return ComponentList;
	}(_react2.default.Component);

	ComponentList.defaultProps = {
	  components: [],
	  onSelect: _react.PropTypes.func,
	  stagedComponent: {}
	};
	ComponentList.propTypes = {
	  components: _react.PropTypes.instanceOf(_immutable2.default.List),
	  onSelect: _react.PropTypes.func,
	  stagedComponent: _react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string,
	    defaultAtellierProps: _react.PropTypes.object,
	    extraPropTypes: _react.PropTypes.object
	  })
	};
	exports.default = ComponentList;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAJCAYAAAARml2dAAAAhklEQVQImV3PIQ9BUQDF8d8V2N6G2RSBQtHeB1IkmxnBNzGK5oP4DF7yihtUSaVcxd3Mif8T/ueElJKcWFctLPBu/MA2tpjgHFJKYl31sUGB3Xha3sPtehlijdcXPqCBGTo4ZpiLE55Yxroa5CI7el9HF/vxtIwhz411VWCFEQ7h70cTc6QPUb41ZeqAUMkAAAAASUVORK5CYII="

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _immutable = __webpack_require__(17);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _ComponentProperties = __webpack_require__(23);

	var _ComponentProperties2 = _interopRequireDefault(_ComponentProperties);

	var _Stage = __webpack_require__(42);

	var _Stage2 = _interopRequireDefault(_Stage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Workspace = function (_React$Component) {
	  _inherits(Workspace, _React$Component);

	  function Workspace(props) {
	    _classCallCheck(this, Workspace);

	    var _this = _possibleConstructorReturn(this, (Workspace.__proto__ || Object.getPrototypeOf(Workspace)).call(this, props));

	    _this._handleChangeProps = function (properties) {
	      _this.setState({ componentProps: properties });
	    };

	    _this.state = {
	      componentProps: {}
	    };
	    return _this;
	  }

	  _createClass(Workspace, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          components = _props.components,
	          component = _props.component,
	          onCloseProperties = _props.onCloseProperties;
	      var componentProps = this.state.componentProps;

	      return !!component && _react2.default.createElement(
	        'div',
	        { className: 'workspace' },
	        _react2.default.createElement(_ComponentProperties2.default, {
	          components: components,
	          component: component,
	          componentProps: componentProps,
	          onChangeProps: this._handleChangeProps,
	          onCloseProperties: onCloseProperties }),
	        _react2.default.createElement(_Stage2.default, {
	          component: component,
	          properties: componentProps })
	      );
	    }
	  }]);

	  return Workspace;
	}(_react2.default.Component);

	Workspace.propTypes = {
	  component: _react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string
	  }),
	  components: _react.PropTypes.instanceOf(_immutable2.default.List),
	  onCloseProperties: _react.PropTypes.func
	};
	exports.default = Workspace;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _immutable = __webpack_require__(17);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _PropertiesContainer = __webpack_require__(24);

	var _PropertiesContainer2 = _interopRequireDefault(_PropertiesContainer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Properties = function (_React$Component) {
	  _inherits(Properties, _React$Component);

	  function Properties(props) {
	    _classCallCheck(this, Properties);

	    var _this = _possibleConstructorReturn(this, (Properties.__proto__ || Object.getPrototypeOf(Properties)).call(this, props));

	    _this._handleChangeProps = function (properties) {
	      _this.props.onChangeProps(properties);
	    };

	    return _this;
	  }

	  _createClass(Properties, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          component = _props.component,
	          componentProps = _props.componentProps,
	          components = _props.components,
	          onCloseProperties = _props.onCloseProperties;

	      var element = _react2.default.createElement(component.component);
	      return _react2.default.createElement(
	        'div',
	        { className: 'component-properties' },
	        _react2.default.createElement(_PropertiesContainer2.default, {
	          name: component.componentName,
	          element: element,
	          elementProps: componentProps,
	          components: components,
	          onChangeProps: this._handleChangeProps,
	          onCloseProperties: onCloseProperties
	        })
	      );
	    }
	  }]);

	  return Properties;
	}(_react2.default.Component);

	Properties.propTypes = {
	  component: _react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string
	  }),
	  componentProps: _react.PropTypes.object,
	  components: _react.PropTypes.instanceOf(_immutable2.default.List),
	  onChangeProps: _react.PropTypes.func,
	  onCloseProperties: _react.PropTypes.func
	};
	exports.default = Properties;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _FieldType = __webpack_require__(25);

	var _FieldType2 = _interopRequireDefault(_FieldType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SimpleElement = function (_React$Component) {
	  _inherits(SimpleElement, _React$Component);

	  function SimpleElement() {
	    _classCallCheck(this, SimpleElement);

	    return _possibleConstructorReturn(this, (SimpleElement.__proto__ || Object.getPrototypeOf(SimpleElement)).apply(this, arguments));
	  }

	  _createClass(SimpleElement, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('span', null);
	    }
	  }]);

	  return SimpleElement;
	}(_react2.default.Component);

	function getPropTypeName(validate) {

	  var types = {
	    array: [],
	    string: '',
	    number: 0,
	    bool: true,
	    func: function func() {},
	    object: {},
	    element: _react2.default.createElement(SimpleElement, null),
	    oneOf: "____"
	  };

	  for (var typeName in types) {
	    var errors = validate({ "name": types[typeName] }, "name");

	    if (!errors) {
	      return {
	        "name": typeName,
	        "values": typeName == 'element' ? undefined : types[typeName]
	      };
	    }

	    switch (true) {
	      case /one of/.test(errors):
	        var oneOfArray = /expected one of (\[.*\])/.exec(errors);

	        if (oneOfArray && oneOfArray[1]) {
	          return {
	            name: 'oneOf',
	            options: JSON.parse(oneOfArray[1]) || []
	          };
	        }
	        break;
	    }
	  }

	  return {
	    "name": 'unknown',
	    "values": undefined
	  };
	}

	var PropertiesContainer = function (_React$Component2) {
	  _inherits(PropertiesContainer, _React$Component2);

	  function PropertiesContainer(props) {
	    _classCallCheck(this, PropertiesContainer);

	    var _this2 = _possibleConstructorReturn(this, (PropertiesContainer.__proto__ || Object.getPrototypeOf(PropertiesContainer)).call(this, props));

	    _initialiseProps.call(_this2);

	    if (props) {
	      _this2._defineProperties(props);
	    }
	    return _this2;
	  }

	  _createClass(PropertiesContainer, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      this._defineProperties(nextProps);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          name = _props.name,
	          element = _props.element;


	      if (element && element.type && _typeof(element.type.propTypes) !== 'object') {
	        return null;
	      }

	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(
	          'div',
	          { className: 'properties-container' },
	          this._renderContainerHeader(name),
	          _react2.default.createElement(
	            'div',
	            { className: 'properties-form' },
	            this._renderPropertiesFields(element)
	          )
	        )
	      );
	    }
	  }, {
	    key: '_renderContainerHeader',
	    value: function _renderContainerHeader(name) {
	      return !!name && _react2.default.createElement(
	        'div',
	        { className: 'container-header' },
	        _react2.default.createElement(
	          'a',
	          { className: 'container-close-button', onClick: this._handleCloseProperties },
	          '+'
	        ),
	        _react2.default.createElement(
	          'h2',
	          { className: 'properties-component' },
	          name
	        )
	      );
	    }
	  }, {
	    key: '_renderPropertiesFields',
	    value: function _renderPropertiesFields(element) {
	      var propTypes = element && element.type.propTypes;
	      var propsFields = [];
	      for (var prop in propTypes) {
	        var proptype = propTypes[prop];

	        var _getPropTypeName = getPropTypeName(proptype),
	            name = _getPropTypeName.name,
	            values = _getPropTypeName.values,
	            options = _getPropTypeName.options;

	        var defaultProps = this._properties[prop] || values;
	        var propOptions = proptype.options || options;
	        propsFields.push(_react2.default.createElement(_FieldType2.default, {
	          key: prop,
	          name: prop,
	          type: name,
	          defaultValue: defaultProps,
	          options: propOptions,
	          components: this.props.components,
	          onChange: this._handleChange
	        }));
	      }

	      return propsFields.length && propsFields || this._renderNoProperties();
	    }
	  }, {
	    key: '_renderNoProperties',
	    value: function _renderNoProperties() {
	      return _react2.default.createElement(
	        'p',
	        { className: 'no-properties' },
	        'No properties'
	      );
	    }
	  }]);

	  return PropertiesContainer;
	}(_react2.default.Component);

	PropertiesContainer.defaultProps = {
	  type: function type() {},
	  propTypes: {},
	  defaultProps: {}
	};
	PropertiesContainer.propTypes = {
	  // onChangeProps: PropTypes.func,
	  // onCloseProperties: PropTypes.func,
	  element: _react.PropTypes.shape({
	    type: _react.PropTypes.func,
	    propTypes: _react.PropTypes.object,
	    defaultProps: _react.PropTypes.object
	  })
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this3 = this;

	  this._handleChange = function (propName, propValue) {
	    _this3._properties[propName] = propValue;
	    _this3.props.onChangeProps(_this3._properties);
	  };

	  this._handleCloseProperties = function () {
	    return _this3.props.onCloseProperties && _this3.props.onCloseProperties(null);
	  };

	  this._defineProperties = function (props) {
	    if (props.element.type) {
	      try {
	        Object.keys(props.element.type.propTypes).filter(function (prop) {
	          if (props.element.type.defaultProps && !props.element.type.defaultProps[prop]) {
	            props.element.type.defaultProps[prop] = null;
	          }
	        });
	      } catch (e) {
	        _this3._properties = {};
	      }
	    }
	    _this3._properties = _extends({}, props.element.props, props.elementProps);
	  };
	};

	exports.default = PropertiesContainer;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _reactAce = __webpack_require__(26);

	var _reactAce2 = _interopRequireDefault(_reactAce);

	var _jsBeautify = __webpack_require__(32);

	var _jsBeautify2 = _interopRequireDefault(_jsBeautify);

	var _PropertiesContainer = __webpack_require__(24);

	var _PropertiesContainer2 = _interopRequireDefault(_PropertiesContainer);

	var _Toggle = __webpack_require__(36);

	var _Toggle2 = _interopRequireDefault(_Toggle);

	__webpack_require__(37);

	__webpack_require__(39);

	__webpack_require__(41);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FieldType = function (_React$Component) {
	  _inherits(FieldType, _React$Component);

	  function FieldType(props) {
	    _classCallCheck(this, FieldType);

	    var _this = _possibleConstructorReturn(this, (FieldType.__proto__ || Object.getPrototypeOf(FieldType)).call(this, props));

	    _this._handleChange = function (response) {
	      var value = response;
	      if (response.target) {
	        value = response.target.type === 'number' && +response.target.value || response.target.value;
	      }
	      _this.props.onChange(_this.props.name, value);
	    };

	    _this._handleElementChange = function (response) {
	      var component = _this.props.components.get(response.target.value);
	      var element = _react2.default.createElement(component.component);
	      _this.props.onChange(_this.props.name, element);
	    };

	    _this._handleElementChangeProps = function (properties) {
	      var _this$props = _this.props,
	          name = _this$props.name,
	          defaultValue = _this$props.defaultValue;

	      var element = _react2.default.cloneElement(defaultValue, properties);
	      _this.props.onChange(_this.props.name, element);
	    };

	    _this._handleObjectChange = function (response) {
	      _this.setState({ defaultValue: response }, function () {
	        try {
	          _this.props.onChange(_this.props.name, JSON.parse(response));
	        } catch (e) {
	          console.error(e);
	        }
	      });
	    };

	    _this._handleFunctionChange = function (response) {
	      _this.setState({ defaultValue: response }, function () {
	        try {
	          _this.props.onChange(_this.props.name, new Function('return ' + response + ';')());
	        } catch (e) {
	          console.error(e);
	        };
	      });
	    };

	    _this._renderTypeHandlers = {
	      string: _this._renderStringInput,
	      number: _this._renderNumberInput,
	      bool: _this._renderBoolInput,
	      array: _this._renderObjectInput,
	      object: _this._renderObjectInput,
	      oneOf: _this._renderOneOf,
	      element: _this._renderElement,
	      func: _this._renderFunction
	    };

	    _this.state = {
	      defaultValue: _this._getDefaultValue(props)
	    };
	    return _this;
	  }

	  _createClass(FieldType, [{
	    key: 'render',
	    value: function render() {
	      var renderComponent = _typeof(this.props.type) && this._renderTypeHandlers[this.props.type] || this._renderStringInput;
	      return renderComponent.call(this, this.props);
	    }
	  }, {
	    key: '_renderStringInput',
	    value: function _renderStringInput(_ref) {
	      var name = _ref.name,
	          type = _ref.type,
	          defaultValue = _ref.defaultValue;

	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement('textarea', { className: 'atellier-input', defaultValue: defaultValue, onChange: this._handleChange })
	      );
	    }
	  }, {
	    key: '_renderNumberInput',
	    value: function _renderNumberInput(_ref2) {
	      var name = _ref2.name,
	          type = _ref2.type,
	          defaultValue = _ref2.defaultValue;

	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement('input', { type: 'number', className: 'atellier-input', defaultValue: defaultValue, onChange: this._handleChange })
	      );
	    }
	  }, {
	    key: '_renderBoolInput',
	    value: function _renderBoolInput(_ref3) {
	      var name = _ref3.name,
	          type = _ref3.type,
	          defaultValue = _ref3.defaultValue;

	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(_Toggle2.default, { defaultValue: defaultValue, onChange: this._handleChange }),
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        )
	      );
	    }
	  }, {
	    key: '_renderObjectInput',
	    value: function _renderObjectInput(_ref4) {
	      var name = _ref4.name,
	          type = _ref4.type,
	          defaultValue = _ref4.defaultValue;

	      var aceProps = {
	        className: 'atellier-editor',
	        mode: 'json',
	        theme: 'twilight',
	        showGutter: false,
	        onChange: this._handleObjectChange,
	        name: (Date.now() * Math.random() / Math.random()).toString(),
	        value: this.state.defaultValue
	      };

	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement(_reactAce2.default, aceProps)
	      );
	    }
	  }, {
	    key: '_renderFunction',
	    value: function _renderFunction(_ref5) {
	      var name = _ref5.name,
	          type = _ref5.type,
	          defaultValue = _ref5.defaultValue;

	      var aceProps = {
	        className: 'atellier-editor',
	        mode: 'javascript',
	        theme: 'twilight',
	        showGutter: false,
	        onChange: this._handleFunctionChange,
	        name: (Date.now() * Math.random() / Math.random()).toString(),
	        value: this.state.defaultValue
	      };

	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement(_reactAce2.default, aceProps)
	      );
	    }
	  }, {
	    key: '_renderOneOf',
	    value: function _renderOneOf(_ref6) {
	      var name = _ref6.name,
	          type = _ref6.type,
	          defaultValue = _ref6.defaultValue,
	          options = _ref6.options;

	      var selectOptions = (options || []).map(function (item, index) {
	        return _react2.default.createElement(
	          'option',
	          { key: index, value: item },
	          item
	        );
	      });
	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement(
	          'select',
	          { className: 'atellier-input', onChange: this._handleChange, defaultValue: defaultValue },
	          _react2.default.createElement(
	            'option',
	            null,
	            'Nothing selected'
	          ),
	          selectOptions
	        )
	      );
	    }
	  }, {
	    key: '_renderElement',
	    value: function _renderElement(_ref7) {
	      var name = _ref7.name,
	          type = _ref7.type,
	          defaultValue = _ref7.defaultValue,
	          components = _ref7.components;

	      var containerProps = void 0;
	      var selectComponents = components.map(function (item, index) {
	        return _react2.default.createElement(
	          'option',
	          { key: index, value: index },
	          item.componentName
	        );
	      });

	      if (defaultValue) {
	        containerProps = _react2.default.createElement(_PropertiesContainer2.default, {
	          element: defaultValue,
	          components: this.props.components,
	          onChangeProps: this._handleElementChangeProps
	        });
	      }
	      return _react2.default.createElement(
	        'div',
	        { className: 'properties-field' },
	        _react2.default.createElement(
	          'label',
	          null,
	          name
	        ),
	        _react2.default.createElement(
	          'select',
	          { className: 'atellier-input', onChange: this._handleElementChange },
	          _react2.default.createElement(
	            'option',
	            null,
	            'Nothing selected'
	          ),
	          selectComponents
	        ),
	        containerProps
	      );
	    }
	  }, {
	    key: '_getDefaultValue',
	    value: function _getDefaultValue(props) {
	      switch (props.type) {
	        case 'array':
	        case 'object':
	          return JSON.stringify(props.defaultValue, null, 2);
	        case 'func':
	          return (0, _jsBeautify2.default)(props.defaultValue && props.defaultValue.toString() || 'function() { return; }');
	        default:
	          return props.defaultValue;
	      };
	    }
	  }]);

	  return FieldType;
	}(_react2.default.Component);

	FieldType.propTypes = {
	  // defaultValue: PropTypes.any,
	  // name: PropTypes.string,
	  // onChange: PropTypes.func,
	  // type: PropTypes.string.isRequired,
	  // options: PropTypes.any
	};
	FieldType.defaultProps = {
	  // name: '',
	  // type: 'string',
	  // defaultValue: null,
	  // onChange: PropTypes.func
	};
	exports.default = FieldType;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _brace = __webpack_require__(27);

	var _brace2 = _interopRequireDefault(_brace);

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _lodash = __webpack_require__(30);

	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ace$acequire = _brace2.default.acequire('ace/range'),
	    Range = _ace$acequire.Range;

	var editorOptions = ['minLines', 'maxLines', 'readOnly', 'highlightActiveLine', 'tabSize', 'enableBasicAutocompletion', 'enableLiveAutocompletion', 'enableSnippets'];

	var ReactAce = function (_Component) {
	  _inherits(ReactAce, _Component);

	  function ReactAce(props) {
	    _classCallCheck(this, ReactAce);

	    var _this = _possibleConstructorReturn(this, (ReactAce.__proto__ || Object.getPrototypeOf(ReactAce)).call(this, props));

	    ['onChange', 'onFocus', 'onBlur', 'onCopy', 'onPaste', 'onScroll', 'handleOptions'].forEach(function (method) {
	      _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  _createClass(ReactAce, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;

	      var _props = this.props,
	          name = _props.name,
	          className = _props.className,
	          onBeforeLoad = _props.onBeforeLoad,
	          mode = _props.mode,
	          focus = _props.focus,
	          theme = _props.theme,
	          fontSize = _props.fontSize,
	          value = _props.value,
	          cursorStart = _props.cursorStart,
	          showGutter = _props.showGutter,
	          wrapEnabled = _props.wrapEnabled,
	          showPrintMargin = _props.showPrintMargin,
	          keyboardHandler = _props.keyboardHandler,
	          onLoad = _props.onLoad,
	          commands = _props.commands,
	          annotations = _props.annotations,
	          markers = _props.markers;


	      this.editor = _brace2.default.edit(this.refs.editor);

	      if (onBeforeLoad) {
	        onBeforeLoad(_brace2.default);
	      }

	      var editorProps = Object.keys(this.props.editorProps);
	      for (var i = 0; i < editorProps.length; i++) {
	        this.editor[editorProps[i]] = this.props.editorProps[editorProps[i]];
	      }

	      this.editor.getSession().setMode('ace/mode/' + mode);
	      this.editor.setTheme('ace/theme/' + theme);
	      this.editor.setFontSize(fontSize);
	      this.editor.setValue(value, cursorStart);
	      this.editor.renderer.setShowGutter(showGutter);
	      this.editor.getSession().setUseWrapMode(wrapEnabled);
	      this.editor.setShowPrintMargin(showPrintMargin);
	      this.editor.on('focus', this.onFocus);
	      this.editor.on('blur', this.onBlur);
	      this.editor.on('copy', this.onCopy);
	      this.editor.on('paste', this.onPaste);
	      this.editor.on('change', this.onChange);
	      this.editor.session.on('changeScrollTop', this.onScroll);
	      this.handleOptions(this.props);
	      this.editor.getSession().setAnnotations(annotations || []);
	      this.handleMarkers(markers || []);

	      // get a list of possible options to avoid 'misspelled option errors'
	      var availableOptions = this.editor.$options;
	      for (var _i = 0; _i < editorOptions.length; _i++) {
	        var option = editorOptions[_i];
	        if (availableOptions.hasOwnProperty(option)) {
	          this.editor.setOption(option, this.props[option]);
	        }
	      }

	      if (Array.isArray(commands)) {
	        commands.forEach(function (command) {
	          _this2.editor.commands.addCommand(command);
	        });
	      }

	      if (keyboardHandler) {
	        this.editor.setKeyboardHandler('ace/keyboard/' + keyboardHandler);
	      }

	      if (className) {
	        this.refs.editor.className += ' ' + className;
	      }

	      if (focus) {
	        this.editor.focus();
	      }

	      if (onLoad) {
	        onLoad(this.editor);
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var _this3 = this;

	      var oldProps = this.props;

	      for (var i = 0; i < editorOptions.length; i++) {
	        var option = editorOptions[i];
	        if (nextProps[option] !== oldProps[option]) {
	          this.editor.setOption(option, nextProps[option]);
	        }
	      }

	      if (nextProps.className !== oldProps.className) {
	        (function () {
	          var appliedClasses = _this3.refs.editor.className;
	          var appliedClassesArray = appliedClasses.trim().split(' ');
	          var oldClassesArray = oldProps.className.trim().split(' ');
	          oldClassesArray.forEach(function (oldClass) {
	            var index = appliedClassesArray.indexOf(oldClass);
	            appliedClassesArray.splice(index, 1);
	          });
	          _this3.refs.editor.className = ' ' + nextProps.className + ' ' + appliedClassesArray.join(' ');
	        })();
	      }

	      if (nextProps.mode !== oldProps.mode) {
	        this.editor.getSession().setMode('ace/mode/' + nextProps.mode);
	      }
	      if (nextProps.theme !== oldProps.theme) {
	        this.editor.setTheme('ace/theme/' + nextProps.theme);
	      }
	      if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {
	        if (nextProps.keyboardHandler) {
	          this.editor.setKeyboardHandler('ace/keyboard/' + nextProps.keyboardHandler);
	        } else {
	          this.editor.setKeyboardHandler(null);
	        }
	      }
	      if (nextProps.fontSize !== oldProps.fontSize) {
	        this.editor.setFontSize(nextProps.fontSize);
	      }
	      if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {
	        this.editor.getSession().setUseWrapMode(nextProps.wrapEnabled);
	      }
	      if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {
	        this.editor.setShowPrintMargin(nextProps.showPrintMargin);
	      }
	      if (nextProps.showGutter !== oldProps.showGutter) {
	        this.editor.renderer.setShowGutter(nextProps.showGutter);
	      }
	      if (!(0, _lodash2.default)(nextProps.setOptions, oldProps.setOptions)) {
	        this.handleOptions(nextProps);
	      }
	      if (!(0, _lodash2.default)(nextProps.annotations, oldProps.annotations)) {
	        this.editor.getSession().setAnnotations(nextProps.annotations || []);
	      }
	      if (!(0, _lodash2.default)(nextProps.markers, oldProps.markers)) {
	        this.handleMarkers(nextProps.markers || []);
	      }
	      if (this.editor && this.editor.getValue() !== nextProps.value) {
	        // editor.setValue is a synchronous function call, change event is emitted before setValue return.
	        this.silent = true;
	        var pos = this.editor.session.selection.toJSON();
	        this.editor.setValue(nextProps.value, nextProps.cursorStart);
	        this.editor.session.selection.fromJSON(pos);
	        this.silent = false;
	      }

	      if (nextProps.focus && !oldProps.focus) {
	        this.editor.focus();
	      }
	      if (nextProps.height !== this.props.height) {
	        this.editor.resize();
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.editor.destroy();
	      this.editor = null;
	    }
	  }, {
	    key: 'onChange',
	    value: function onChange() {
	      if (this.props.onChange && !this.silent) {
	        var value = this.editor.getValue();
	        this.props.onChange(value);
	      }
	    }
	  }, {
	    key: 'onFocus',
	    value: function onFocus() {
	      if (this.props.onFocus) {
	        this.props.onFocus();
	      }
	    }
	  }, {
	    key: 'onBlur',
	    value: function onBlur() {
	      if (this.props.onBlur) {
	        this.props.onBlur();
	      }
	    }
	  }, {
	    key: 'onCopy',
	    value: function onCopy(text) {
	      if (this.props.onCopy) {
	        this.props.onCopy(text);
	      }
	    }
	  }, {
	    key: 'onPaste',
	    value: function onPaste(text) {
	      if (this.props.onPaste) {
	        this.props.onPaste(text);
	      }
	    }
	  }, {
	    key: 'onScroll',
	    value: function onScroll() {
	      if (this.props.onScroll) {
	        this.props.onScroll(this.editor);
	      }
	    }
	  }, {
	    key: 'handleOptions',
	    value: function handleOptions(props) {
	      var setOptions = Object.keys(props.setOptions);
	      for (var y = 0; y < setOptions.length; y++) {
	        this.editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);
	      }
	    }
	  }, {
	    key: 'handleMarkers',
	    value: function handleMarkers(markers) {
	      var _this4 = this;

	      // remove foreground markers
	      var currentMarkers = this.editor.getSession().getMarkers(true);
	      for (var i in currentMarkers) {
	        if (currentMarkers.hasOwnProperty(i)) {
	          this.editor.getSession().removeMarker(currentMarkers[i].id);
	        }
	      }
	      // remove background markers
	      currentMarkers = this.editor.getSession().getMarkers(false);
	      for (var _i2 in currentMarkers) {
	        if (currentMarkers.hasOwnProperty(_i2)) {
	          this.editor.getSession().removeMarker(currentMarkers[_i2].id);
	        }
	      }
	      // add new markers
	      markers.forEach(function (_ref) {
	        var startRow = _ref.startRow,
	            startCol = _ref.startCol,
	            endRow = _ref.endRow,
	            endCol = _ref.endCol,
	            className = _ref.className,
	            type = _ref.type,
	            _ref$inFront = _ref.inFront,
	            inFront = _ref$inFront === undefined ? false : _ref$inFront;

	        var range = new Range(startRow, startCol, endRow, endCol);
	        _this4.editor.getSession().addMarker(range, className, type, inFront);
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props2 = this.props,
	          name = _props2.name,
	          width = _props2.width,
	          height = _props2.height,
	          style = _props2.style;

	      var divStyle = _extends({ width: width, height: height }, style);
	      return _react2.default.createElement('div', { ref: 'editor',
	        id: name,
	        style: divStyle
	      });
	    }
	  }]);

	  return ReactAce;
	}(_react.Component);

	exports.default = ReactAce;


	ReactAce.propTypes = {
	  mode: _react.PropTypes.string,
	  focus: _react.PropTypes.bool,
	  theme: _react.PropTypes.string,
	  name: _react.PropTypes.string,
	  className: _react.PropTypes.string,
	  height: _react.PropTypes.string,
	  width: _react.PropTypes.string,
	  fontSize: _react.PropTypes.number,
	  showGutter: _react.PropTypes.bool,
	  onChange: _react.PropTypes.func,
	  onCopy: _react.PropTypes.func,
	  onPaste: _react.PropTypes.func,
	  onFocus: _react.PropTypes.func,
	  onBlur: _react.PropTypes.func,
	  onScroll: _react.PropTypes.func,
	  value: _react.PropTypes.string,
	  onLoad: _react.PropTypes.func,
	  onBeforeLoad: _react.PropTypes.func,
	  minLines: _react.PropTypes.number,
	  maxLines: _react.PropTypes.number,
	  readOnly: _react.PropTypes.bool,
	  highlightActiveLine: _react.PropTypes.bool,
	  tabSize: _react.PropTypes.number,
	  showPrintMargin: _react.PropTypes.bool,
	  cursorStart: _react.PropTypes.number,
	  editorProps: _react.PropTypes.object,
	  setOptions: _react.PropTypes.object,
	  annotations: _react.PropTypes.array,
	  markers: _react.PropTypes.array,
	  keyboardHandler: _react.PropTypes.string,
	  wrapEnabled: _react.PropTypes.bool,
	  enableBasicAutocompletion: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.array]),
	  enableLiveAutocompletion: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.array]),
	  commands: _react.PropTypes.array
	};

	ReactAce.defaultProps = {
	  name: 'brace-editor',
	  focus: false,
	  mode: '',
	  theme: '',
	  height: '500px',
	  width: '500px',
	  value: '',
	  fontSize: 12,
	  showGutter: true,
	  onChange: null,
	  onPaste: null,
	  onLoad: null,
	  onScroll: null,
	  minLines: null,
	  maxLines: null,
	  readOnly: false,
	  highlightActiveLine: true,
	  showPrintMargin: true,
	  tabSize: 4,
	  cursorStart: 1,
	  editorProps: {},
	  setOptions: {},
	  wrapEnabled: false,
	  enableBasicAutocompletion: false,
	  enableLiveAutocompletion: false
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/* ***** BEGIN LICENSE BLOCK *****
	 * Distributed under the BSD license:
	 *
	 * Copyright (c) 2010, Ajax.org B.V.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *     * Redistributions of source code must retain the above copyright
	 *       notice, this list of conditions and the following disclaimer.
	 *     * Redistributions in binary form must reproduce the above copyright
	 *       notice, this list of conditions and the following disclaimer in the
	 *       documentation and/or other materials provided with the distribution.
	 *     * Neither the name of Ajax.org B.V. nor the
	 *       names of its contributors may be used to endorse or promote products
	 *       derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * ***** END LICENSE BLOCK ***** */

	/**
	 * Define a module along with a payload
	 * @param module a name for the payload
	 * @param payload a function to call with (acequire, exports, module) params
	 */

	(function() {

	var ACE_NAMESPACE = "ace";

	var global = (function() { return this; })();
	if (!global && typeof window != "undefined") global = window; // strict mode


	if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
	    return;


	var define = function(module, deps, payload) {
	    if (typeof module !== "string") {
	        if (define.original)
	            define.original.apply(this, arguments);
	        else {
	            console.error("dropping module because define wasn\'t a string.");
	            console.trace();
	        }
	        return;
	    }
	    if (arguments.length == 2)
	        payload = deps;
	    if (!define.modules[module]) {
	        define.payloads[module] = payload;
	        define.modules[module] = null;
	    }
	};

	define.modules = {};
	define.payloads = {};

	/**
	 * Get at functionality define()ed using the function above
	 */
	var _acequire = function(parentId, module, callback) {
	    if (typeof module === "string") {
	        var payload = lookup(parentId, module);
	        if (payload != undefined) {
	            callback && callback();
	            return payload;
	        }
	    } else if (Object.prototype.toString.call(module) === "[object Array]") {
	        var params = [];
	        for (var i = 0, l = module.length; i < l; ++i) {
	            var dep = lookup(parentId, module[i]);
	            if (dep == undefined && acequire.original)
	                return;
	            params.push(dep);
	        }
	        return callback && callback.apply(null, params) || true;
	    }
	};

	var acequire = function(module, callback) {
	    var packagedModule = _acequire("", module, callback);
	    if (packagedModule == undefined && acequire.original)
	        return acequire.original.apply(this, arguments);
	    return packagedModule;
	};

	var normalizeModule = function(parentId, moduleName) {
	    // normalize plugin acequires
	    if (moduleName.indexOf("!") !== -1) {
	        var chunks = moduleName.split("!");
	        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
	    }
	    // normalize relative acequires
	    if (moduleName.charAt(0) == ".") {
	        var base = parentId.split("/").slice(0, -1).join("/");
	        moduleName = base + "/" + moduleName;

	        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
	            var previous = moduleName;
	            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
	        }
	    }
	    return moduleName;
	};

	/**
	 * Internal function to lookup moduleNames and resolve them by calling the
	 * definition function if needed.
	 */
	var lookup = function(parentId, moduleName) {
	    moduleName = normalizeModule(parentId, moduleName);

	    var module = define.modules[moduleName];
	    if (!module) {
	        module = define.payloads[moduleName];
	        if (typeof module === 'function') {
	            var exports = {};
	            var mod = {
	                id: moduleName,
	                uri: '',
	                exports: exports,
	                packaged: true
	            };

	            var req = function(module, callback) {
	                return _acequire(moduleName, module, callback);
	            };

	            var returnValue = module(req, exports, mod);
	            exports = returnValue || mod.exports;
	            define.modules[moduleName] = exports;
	            delete define.payloads[moduleName];
	        }
	        module = define.modules[moduleName] = exports || module;
	    }
	    return module;
	};

	function exportAce(ns) {
	    var root = global;
	    if (ns) {
	        if (!global[ns])
	            global[ns] = {};
	        root = global[ns];
	    }

	    if (!root.define || !root.define.packaged) {
	        define.original = root.define;
	        root.define = define;
	        root.define.packaged = true;
	    }

	    if (!root.acequire || !root.acequire.packaged) {
	        acequire.original = root.acequire;
	        root.acequire = acequire;
	        root.acequire.packaged = true;
	    }
	}

	exportAce(ACE_NAMESPACE);

	})();

	ace.define("ace/lib/regexp",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	    var real = {
	            exec: RegExp.prototype.exec,
	            test: RegExp.prototype.test,
	            match: String.prototype.match,
	            replace: String.prototype.replace,
	            split: String.prototype.split
	        },
	        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
	        compliantLastIndexIncrement = function () {
	            var x = /^/g;
	            real.test.call(x, "");
	            return !x.lastIndex;
	        }();

	    if (compliantLastIndexIncrement && compliantExecNpcg)
	        return;
	    RegExp.prototype.exec = function (str) {
	        var match = real.exec.apply(this, arguments),
	            name, r2;
	        if ( typeof(str) == 'string' && match) {
	            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
	                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
	                real.replace.call(str.slice(match.index), r2, function () {
	                    for (var i = 1; i < arguments.length - 2; i++) {
	                        if (arguments[i] === undefined)
	                            match[i] = undefined;
	                    }
	                });
	            }
	            if (this._xregexp && this._xregexp.captureNames) {
	                for (var i = 1; i < match.length; i++) {
	                    name = this._xregexp.captureNames[i - 1];
	                    if (name)
	                       match[name] = match[i];
	                }
	            }
	            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	        }
	        return match;
	    };
	    if (!compliantLastIndexIncrement) {
	        RegExp.prototype.test = function (str) {
	            var match = real.exec.call(this, str);
	            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	            return !!match;
	        };
	    }

	    function getNativeFlags (regex) {
	        return (regex.global     ? "g" : "") +
	               (regex.ignoreCase ? "i" : "") +
	               (regex.multiline  ? "m" : "") +
	               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
	               (regex.sticky     ? "y" : "");
	    }

	    function indexOf (array, item, from) {
	        if (Array.prototype.indexOf) // Use the native array method if available
	            return array.indexOf(item, from);
	        for (var i = from || 0; i < array.length; i++) {
	            if (array[i] === item)
	                return i;
	        }
	        return -1;
	    }

	});

	ace.define("ace/lib/es5-shim",["require","exports","module"], function(acequire, exports, module) {

	function Empty() {}

	if (!Function.prototype.bind) {
	    Function.prototype.bind = function bind(that) { // .length is 1
	        var target = this;
	        if (typeof target != "function") {
	            throw new TypeError("Function.prototype.bind called on incompatible " + target);
	        }
	        var args = slice.call(arguments, 1); // for normal call
	        var bound = function () {

	            if (this instanceof bound) {

	                var result = target.apply(
	                    this,
	                    args.concat(slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;

	            } else {
	                return target.apply(
	                    that,
	                    args.concat(slice.call(arguments))
	                );

	            }

	        };
	        if(target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            Empty.prototype = null;
	        }
	        return bound;
	    };
	}
	var call = Function.prototype.call;
	var prototypeOfArray = Array.prototype;
	var prototypeOfObject = Object.prototype;
	var slice = prototypeOfArray.slice;
	var _toString = call.bind(prototypeOfObject.toString);
	var owns = call.bind(prototypeOfObject.hasOwnProperty);
	var defineGetter;
	var defineSetter;
	var lookupGetter;
	var lookupSetter;
	var supportsAccessors;
	if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
	    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
	    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
	    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
	    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	}
	if ([1,2].splice(0).length != 2) {
	    if(function() { // test IE < 9 to splice bug - see issue #138
	        function makeArray(l) {
	            var a = new Array(l+2);
	            a[0] = a[1] = 0;
	            return a;
	        }
	        var array = [], lengthBefore;
	        
	        array.splice.apply(array, makeArray(20));
	        array.splice.apply(array, makeArray(26));

	        lengthBefore = array.length; //46
	        array.splice(5, 0, "XXX"); // add one element

	        lengthBefore + 1 == array.length

	        if (lengthBefore + 1 == array.length) {
	            return true;// has right splice implementation without bugs
	        }
	    }()) {//IE 6/7
	        var array_splice = Array.prototype.splice;
	        Array.prototype.splice = function(start, deleteCount) {
	            if (!arguments.length) {
	                return [];
	            } else {
	                return array_splice.apply(this, [
	                    start === void 0 ? 0 : start,
	                    deleteCount === void 0 ? (this.length - start) : deleteCount
	                ].concat(slice.call(arguments, 2)))
	            }
	        };
	    } else {//IE8
	        Array.prototype.splice = function(pos, removeCount){
	            var length = this.length;
	            if (pos > 0) {
	                if (pos > length)
	                    pos = length;
	            } else if (pos == void 0) {
	                pos = 0;
	            } else if (pos < 0) {
	                pos = Math.max(length + pos, 0);
	            }

	            if (!(pos+removeCount < length))
	                removeCount = length - pos;

	            var removed = this.slice(pos, pos+removeCount);
	            var insert = slice.call(arguments, 2);
	            var add = insert.length;            
	            if (pos === length) {
	                if (add) {
	                    this.push.apply(this, insert);
	                }
	            } else {
	                var remove = Math.min(removeCount, length - pos);
	                var tailOldPos = pos + remove;
	                var tailNewPos = tailOldPos + add - remove;
	                var tailCount = length - tailOldPos;
	                var lengthAfterRemove = length - remove;

	                if (tailNewPos < tailOldPos) { // case A
	                    for (var i = 0; i < tailCount; ++i) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } else if (tailNewPos > tailOldPos) { // case B
	                    for (i = tailCount; i--; ) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } // else, add == remove (nothing to do)

	                if (add && pos === lengthAfterRemove) {
	                    this.length = lengthAfterRemove; // truncate array
	                    this.push.apply(this, insert);
	                } else {
	                    this.length = lengthAfterRemove + add; // reserves space
	                    for (i = 0; i < add; ++i) {
	                        this[pos+i] = insert[i];
	                    }
	                }
	            }
	            return removed;
	        };
	    }
	}
	if (!Array.isArray) {
	    Array.isArray = function isArray(obj) {
	        return _toString(obj) == "[object Array]";
	    };
	}
	var boxedString = Object("a"),
	    splitString = boxedString[0] != "a" || !(0 in boxedString);

	if (!Array.prototype.forEach) {
	    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(); // TODO message
	        }

	        while (++i < length) {
	            if (i in self) {
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    };
	}
	if (!Array.prototype.map) {
	    Array.prototype.map = function map(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            result = Array(length),
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self)
	                result[i] = fun.call(thisp, self[i], i, object);
	        }
	        return result;
	    };
	}
	if (!Array.prototype.filter) {
	    Array.prototype.filter = function filter(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                    object,
	            length = self.length >>> 0,
	            result = [],
	            value,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (fun.call(thisp, value, i, object)) {
	                    result.push(value);
	                }
	            }
	        }
	        return result;
	    };
	}
	if (!Array.prototype.every) {
	    Array.prototype.every = function every(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && !fun.call(thisp, self[i], i, object)) {
	                return false;
	            }
	        }
	        return true;
	    };
	}
	if (!Array.prototype.some) {
	    Array.prototype.some = function some(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && fun.call(thisp, self[i], i, object)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	if (!Array.prototype.reduce) {
	    Array.prototype.reduce = function reduce(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduce of empty array with no initial value");
	        }

	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	                if (++i >= length) {
	                    throw new TypeError("reduce of empty array with no initial value");
	                }
	            } while (true);
	        }

	        for (; i < length; i++) {
	            if (i in self) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        }

	        return result;
	    };
	}
	if (!Array.prototype.reduceRight) {
	    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduceRight of empty array with no initial value");
	        }

	        var result, i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	                if (--i < 0) {
	                    throw new TypeError("reduceRight of empty array with no initial value");
	                }
	            } while (true);
	        }

	        do {
	            if (i in this) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        } while (i--);

	        return result;
	    };
	}
	if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
	    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }

	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
	    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = Math.min(i, toInteger(arguments[1]));
	        }
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && sought === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Object.getPrototypeOf) {
	    Object.getPrototypeOf = function getPrototypeOf(object) {
	        return object.__proto__ || (
	            object.constructor ?
	            object.constructor.prototype :
	            prototypeOfObject
	        );
	    };
	}
	if (!Object.getOwnPropertyDescriptor) {
	    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
	                         "non-object: ";
	    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT + object);
	        if (!owns(object, property))
	            return;

	        var descriptor, getter, setter;
	        descriptor =  { enumerable: true, configurable: true };
	        if (supportsAccessors) {
	            var prototype = object.__proto__;
	            object.__proto__ = prototypeOfObject;

	            var getter = lookupGetter(object, property);
	            var setter = lookupSetter(object, property);
	            object.__proto__ = prototype;

	            if (getter || setter) {
	                if (getter) descriptor.get = getter;
	                if (setter) descriptor.set = setter;
	                return descriptor;
	            }
	        }
	        descriptor.value = object[property];
	        return descriptor;
	    };
	}
	if (!Object.getOwnPropertyNames) {
	    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	        return Object.keys(object);
	    };
	}
	if (!Object.create) {
	    var createEmpty;
	    if (Object.prototype.__proto__ === null) {
	        createEmpty = function () {
	            return { "__proto__": null };
	        };
	    } else {
	        createEmpty = function () {
	            var empty = {};
	            for (var i in empty)
	                empty[i] = null;
	            empty.constructor =
	            empty.hasOwnProperty =
	            empty.propertyIsEnumerable =
	            empty.isPrototypeOf =
	            empty.toLocaleString =
	            empty.toString =
	            empty.valueOf =
	            empty.__proto__ = null;
	            return empty;
	        }
	    }

	    Object.create = function create(prototype, properties) {
	        var object;
	        if (prototype === null) {
	            object = createEmpty();
	        } else {
	            if (typeof prototype != "object")
	                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
	            var Type = function () {};
	            Type.prototype = prototype;
	            object = new Type();
	            object.__proto__ = prototype;
	        }
	        if (properties !== void 0)
	            Object.defineProperties(object, properties);
	        return object;
	    };
	}

	function doesDefinePropertyWork(object) {
	    try {
	        Object.defineProperty(object, "sentinel", {});
	        return "sentinel" in object;
	    } catch (exception) {
	    }
	}
	if (Object.defineProperty) {
	    var definePropertyWorksOnObject = doesDefinePropertyWork({});
	    var definePropertyWorksOnDom = typeof document == "undefined" ||
	        doesDefinePropertyWork(document.createElement("div"));
	    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
	        var definePropertyFallback = Object.defineProperty;
	    }
	}

	if (!Object.defineProperty || definePropertyFallback) {
	    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
	    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
	    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
	                                      "on this javascript engine";

	    Object.defineProperty = function defineProperty(object, property, descriptor) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
	        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
	            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
	        if (definePropertyFallback) {
	            try {
	                return definePropertyFallback.call(Object, object, property, descriptor);
	            } catch (exception) {
	            }
	        }
	        if (owns(descriptor, "value")) {

	            if (supportsAccessors && (lookupGetter(object, property) ||
	                                      lookupSetter(object, property)))
	            {
	                var prototype = object.__proto__;
	                object.__proto__ = prototypeOfObject;
	                delete object[property];
	                object[property] = descriptor.value;
	                object.__proto__ = prototype;
	            } else {
	                object[property] = descriptor.value;
	            }
	        } else {
	            if (!supportsAccessors)
	                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
	            if (owns(descriptor, "get"))
	                defineGetter(object, property, descriptor.get);
	            if (owns(descriptor, "set"))
	                defineSetter(object, property, descriptor.set);
	        }

	        return object;
	    };
	}
	if (!Object.defineProperties) {
	    Object.defineProperties = function defineProperties(object, properties) {
	        for (var property in properties) {
	            if (owns(properties, property))
	                Object.defineProperty(object, property, properties[property]);
	        }
	        return object;
	    };
	}
	if (!Object.seal) {
	    Object.seal = function seal(object) {
	        return object;
	    };
	}
	if (!Object.freeze) {
	    Object.freeze = function freeze(object) {
	        return object;
	    };
	}
	try {
	    Object.freeze(function () {});
	} catch (exception) {
	    Object.freeze = (function freeze(freezeObject) {
	        return function freeze(object) {
	            if (typeof object == "function") {
	                return object;
	            } else {
	                return freezeObject(object);
	            }
	        };
	    })(Object.freeze);
	}
	if (!Object.preventExtensions) {
	    Object.preventExtensions = function preventExtensions(object) {
	        return object;
	    };
	}
	if (!Object.isSealed) {
	    Object.isSealed = function isSealed(object) {
	        return false;
	    };
	}
	if (!Object.isFrozen) {
	    Object.isFrozen = function isFrozen(object) {
	        return false;
	    };
	}
	if (!Object.isExtensible) {
	    Object.isExtensible = function isExtensible(object) {
	        if (Object(object) === object) {
	            throw new TypeError(); // TODO message
	        }
	        var name = '';
	        while (owns(object, name)) {
	            name += '?';
	        }
	        object[name] = true;
	        var returnValue = owns(object, name);
	        delete object[name];
	        return returnValue;
	    };
	}
	if (!Object.keys) {
	    var hasDontEnumBug = true,
	        dontEnums = [
	            "toString",
	            "toLocaleString",
	            "valueOf",
	            "hasOwnProperty",
	            "isPrototypeOf",
	            "propertyIsEnumerable",
	            "constructor"
	        ],
	        dontEnumsLength = dontEnums.length;

	    for (var key in {"toString": null}) {
	        hasDontEnumBug = false;
	    }

	    Object.keys = function keys(object) {

	        if (
	            (typeof object != "object" && typeof object != "function") ||
	            object === null
	        ) {
	            throw new TypeError("Object.keys called on a non-object");
	        }

	        var keys = [];
	        for (var name in object) {
	            if (owns(object, name)) {
	                keys.push(name);
	            }
	        }

	        if (hasDontEnumBug) {
	            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
	                var dontEnum = dontEnums[i];
	                if (owns(object, dontEnum)) {
	                    keys.push(dontEnum);
	                }
	            }
	        }
	        return keys;
	    };

	}
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
	    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
	    "\u2029\uFEFF";
	if (!String.prototype.trim || ws.trim()) {
	    ws = "[" + ws + "]";
	    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
	        trimEndRegexp = new RegExp(ws + ws + "*$");
	    String.prototype.trim = function trim() {
	        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
	    };
	}

	function toInteger(n) {
	    n = +n;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}

	function isPrimitive(input) {
	    var type = typeof input;
	    return (
	        input === null ||
	        type === "undefined" ||
	        type === "boolean" ||
	        type === "number" ||
	        type === "string"
	    );
	}

	function toPrimitive(input) {
	    var val, valueOf, toString;
	    if (isPrimitive(input)) {
	        return input;
	    }
	    valueOf = input.valueOf;
	    if (typeof valueOf === "function") {
	        val = valueOf.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    toString = input.toString;
	    if (typeof toString === "function") {
	        val = toString.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    throw new TypeError();
	}
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert "+o+" to object");
	    }
	    return Object(o);
	};

	});

	ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(acequire, exports, module) {
	"use strict";

	acequire("./regexp");
	acequire("./es5-shim");

	});

	ace.define("ace/lib/dom",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var XHTML_NS = "http://www.w3.org/1999/xhtml";

	exports.getDocumentHead = function(doc) {
	    if (!doc)
	        doc = document;
	    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
	};

	exports.createElement = function(tag, ns) {
	    return document.createElementNS ?
	           document.createElementNS(ns || XHTML_NS, tag) :
	           document.createElement(tag);
	};

	exports.hasCssClass = function(el, name) {
	    var classes = (el.className || "").split(/\s+/g);
	    return classes.indexOf(name) !== -1;
	};
	exports.addCssClass = function(el, name) {
	    if (!exports.hasCssClass(el, name)) {
	        el.className += " " + name;
	    }
	};
	exports.removeCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g);
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        classes.splice(index, 1);
	    }
	    el.className = classes.join(" ");
	};

	exports.toggleCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g), add = true;
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        add = false;
	        classes.splice(index, 1);
	    }
	    if (add)
	        classes.push(name);

	    el.className = classes.join(" ");
	    return add;
	};
	exports.setCssClass = function(node, className, include) {
	    if (include) {
	        exports.addCssClass(node, className);
	    } else {
	        exports.removeCssClass(node, className);
	    }
	};

	exports.hasCssString = function(id, doc) {
	    var index = 0, sheets;
	    doc = doc || document;

	    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
	        while (index < sheets.length)
	            if (sheets[index++].owningElement.id === id) return true;
	    } else if ((sheets = doc.getElementsByTagName("style"))) {
	        while (index < sheets.length)
	            if (sheets[index++].id === id) return true;
	    }

	    return false;
	};

	exports.importCssString = function importCssString(cssText, id, doc) {
	    doc = doc || document;
	    if (id && exports.hasCssString(id, doc))
	        return null;
	    
	    var style;
	    
	    if (id)
	        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
	    
	    if (doc.createStyleSheet) {
	        style = doc.createStyleSheet();
	        style.cssText = cssText;
	        if (id)
	            style.owningElement.id = id;
	    } else {
	        style = exports.createElement("style");
	        style.appendChild(doc.createTextNode(cssText));
	        if (id)
	            style.id = id;

	        exports.getDocumentHead(doc).appendChild(style);
	    }
	};

	exports.importCssStylsheet = function(uri, doc) {
	    if (doc.createStyleSheet) {
	        doc.createStyleSheet(uri);
	    } else {
	        var link = exports.createElement('link');
	        link.rel = 'stylesheet';
	        link.href = uri;

	        exports.getDocumentHead(doc).appendChild(link);
	    }
	};

	exports.getInnerWidth = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
	        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
	        element.clientWidth
	    );
	};

	exports.getInnerHeight = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
	        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
	        element.clientHeight
	    );
	};

	exports.scrollbarWidth = function(document) {
	    var inner = exports.createElement("ace_inner");
	    inner.style.width = "100%";
	    inner.style.minWidth = "0px";
	    inner.style.height = "200px";
	    inner.style.display = "block";

	    var outer = exports.createElement("ace_outer");
	    var style = outer.style;

	    style.position = "absolute";
	    style.left = "-10000px";
	    style.overflow = "hidden";
	    style.width = "200px";
	    style.minWidth = "0px";
	    style.height = "150px";
	    style.display = "block";

	    outer.appendChild(inner);

	    var body = document.documentElement;
	    body.appendChild(outer);

	    var noScrollbar = inner.offsetWidth;

	    style.overflow = "scroll";
	    var withScrollbar = inner.offsetWidth;

	    if (noScrollbar == withScrollbar) {
	        withScrollbar = outer.clientWidth;
	    }

	    body.removeChild(outer);

	    return noScrollbar-withScrollbar;
	};

	if (typeof document == "undefined") {
	    exports.importCssString = function() {};
	    return;
	}

	if (window.pageYOffset !== undefined) {
	    exports.getPageScrollTop = function() {
	        return window.pageYOffset;
	    };

	    exports.getPageScrollLeft = function() {
	        return window.pageXOffset;
	    };
	}
	else {
	    exports.getPageScrollTop = function() {
	        return document.body.scrollTop;
	    };

	    exports.getPageScrollLeft = function() {
	        return document.body.scrollLeft;
	    };
	}

	if (window.getComputedStyle)
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return (window.getComputedStyle(element, "") || {})[style] || "";
	        return window.getComputedStyle(element, "") || {};
	    };
	else
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return element.currentStyle[style];
	        return element.currentStyle;
	    };
	exports.setInnerHtml = function(el, innerHtml) {
	    var element = el.cloneNode(false);//document.createElement("div");
	    element.innerHTML = innerHtml;
	    el.parentNode.replaceChild(element, el);
	    return element;
	};

	if ("textContent" in document.documentElement) {
	    exports.setInnerText = function(el, innerText) {
	        el.textContent = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.textContent;
	    };
	}
	else {
	    exports.setInnerText = function(el, innerText) {
	        el.innerText = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.innerText;
	    };
	}

	exports.getParentWindow = function(document) {
	    return document.defaultView || document.parentWindow;
	};

	});

	ace.define("ace/lib/oop",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.inherits = function(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	            value: ctor,
	            enumerable: false,
	            writable: true,
	            configurable: true
	        }
	    });
	};

	exports.mixin = function(obj, mixin) {
	    for (var key in mixin) {
	        obj[key] = mixin[key];
	    }
	    return obj;
	};

	exports.implement = function(proto, mixin) {
	    exports.mixin(proto, mixin);
	};

	});

	ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	acequire("./fixoldbrowsers");

	var oop = acequire("./oop");
	var Keys = (function() {
	    var ret = {
	        MODIFIER_KEYS: {
	            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
	        },

	        KEY_MODS: {
	            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
	            "super": 8, "meta": 8, "command": 8, "cmd": 8
	        },

	        FUNCTION_KEYS : {
	            8  : "Backspace",
	            9  : "Tab",
	            13 : "Return",
	            19 : "Pause",
	            27 : "Esc",
	            32 : "Space",
	            33 : "PageUp",
	            34 : "PageDown",
	            35 : "End",
	            36 : "Home",
	            37 : "Left",
	            38 : "Up",
	            39 : "Right",
	            40 : "Down",
	            44 : "Print",
	            45 : "Insert",
	            46 : "Delete",
	            96 : "Numpad0",
	            97 : "Numpad1",
	            98 : "Numpad2",
	            99 : "Numpad3",
	            100: "Numpad4",
	            101: "Numpad5",
	            102: "Numpad6",
	            103: "Numpad7",
	            104: "Numpad8",
	            105: "Numpad9",
	            '-13': "NumpadEnter",
	            112: "F1",
	            113: "F2",
	            114: "F3",
	            115: "F4",
	            116: "F5",
	            117: "F6",
	            118: "F7",
	            119: "F8",
	            120: "F9",
	            121: "F10",
	            122: "F11",
	            123: "F12",
	            144: "Numlock",
	            145: "Scrolllock"
	        },

	        PRINTABLE_KEYS: {
	           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
	           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
	           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
	           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
	           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
	           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
	          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
	          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
	        }
	    };
	    var name, i;
	    for (i in ret.FUNCTION_KEYS) {
	        name = ret.FUNCTION_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    for (i in ret.PRINTABLE_KEYS) {
	        name = ret.PRINTABLE_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    oop.mixin(ret, ret.MODIFIER_KEYS);
	    oop.mixin(ret, ret.PRINTABLE_KEYS);
	    oop.mixin(ret, ret.FUNCTION_KEYS);
	    ret.enter = ret["return"];
	    ret.escape = ret.esc;
	    ret.del = ret["delete"];
	    ret[173] = '-';
	    
	    (function() {
	        var mods = ["cmd", "ctrl", "alt", "shift"];
	        for (var i = Math.pow(2, mods.length); i--;) {            
	            ret.KEY_MODS[i] = mods.filter(function(x) {
	                return i & ret.KEY_MODS[x];
	            }).join("-") + "-";
	        }
	    })();

	    ret.KEY_MODS[0] = "";
	    ret.KEY_MODS[-1] = "input-";

	    return ret;
	})();
	oop.mixin(exports, Keys);

	exports.keyCodeToString = function(keyCode) {
	    var keyString = Keys[keyCode];
	    if (typeof keyString != "string")
	        keyString = String.fromCharCode(keyCode);
	    return keyString.toLowerCase();
	};

	});

	ace.define("ace/lib/useragent",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.OS = {
	    LINUX: "LINUX",
	    MAC: "MAC",
	    WINDOWS: "WINDOWS"
	};
	exports.getOS = function() {
	    if (exports.isMac) {
	        return exports.OS.MAC;
	    } else if (exports.isLinux) {
	        return exports.OS.LINUX;
	    } else {
	        return exports.OS.WINDOWS;
	    }
	};
	if (typeof navigator != "object")
	    return;

	var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
	var ua = navigator.userAgent;
	exports.isWin = (os == "win");
	exports.isMac = (os == "mac");
	exports.isLinux = (os == "linux");
	exports.isIE = 
	    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
	    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
	    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
	    
	exports.isOldIE = exports.isIE && exports.isIE < 9;
	exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
	exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
	exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
	exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

	exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

	exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

	exports.isIPad = ua.indexOf("iPad") >= 0;

	exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

	exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

	});

	ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keys = acequire("./keys");
	var useragent = acequire("./useragent");

	var pressedKeys = null;
	var ts = 0;

	exports.addListener = function(elem, type, callback) {
	    if (elem.addEventListener) {
	        return elem.addEventListener(type, callback, false);
	    }
	    if (elem.attachEvent) {
	        var wrapper = function() {
	            callback.call(elem, window.event);
	        };
	        callback._wrapper = wrapper;
	        elem.attachEvent("on" + type, wrapper);
	    }
	};

	exports.removeListener = function(elem, type, callback) {
	    if (elem.removeEventListener) {
	        return elem.removeEventListener(type, callback, false);
	    }
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, callback._wrapper || callback);
	    }
	};
	exports.stopEvent = function(e) {
	    exports.stopPropagation(e);
	    exports.preventDefault(e);
	    return false;
	};

	exports.stopPropagation = function(e) {
	    if (e.stopPropagation)
	        e.stopPropagation();
	    else
	        e.cancelBubble = true;
	};

	exports.preventDefault = function(e) {
	    if (e.preventDefault)
	        e.preventDefault();
	    else
	        e.returnValue = false;
	};
	exports.getButton = function(e) {
	    if (e.type == "dblclick")
	        return 0;
	    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
	        return 2;
	    if (e.preventDefault) {
	        return e.button;
	    }
	    else {
	        return {1:0, 2:2, 4:1}[e.button];
	    }
	};

	exports.capture = function(el, eventHandler, releaseCaptureHandler) {
	    function onMouseUp(e) {
	        eventHandler && eventHandler(e);
	        releaseCaptureHandler && releaseCaptureHandler(e);

	        exports.removeListener(document, "mousemove", eventHandler, true);
	        exports.removeListener(document, "mouseup", onMouseUp, true);
	        exports.removeListener(document, "dragstart", onMouseUp, true);
	    }

	    exports.addListener(document, "mousemove", eventHandler, true);
	    exports.addListener(document, "mouseup", onMouseUp, true);
	    exports.addListener(document, "dragstart", onMouseUp, true);
	    
	    return onMouseUp;
	};

	exports.addTouchMoveListener = function (el, callback) {
	    if ("ontouchmove" in el) {
	        var startx, starty;
	        exports.addListener(el, "touchstart", function (e) {
	            var touchObj = e.changedTouches[0];
	            startx = touchObj.clientX;
	            starty = touchObj.clientY;
	        });
	        exports.addListener(el, "touchmove", function (e) {
	            var factor = 1,
	            touchObj = e.changedTouches[0];

	            e.wheelX = -(touchObj.clientX - startx) / factor;
	            e.wheelY = -(touchObj.clientY - starty) / factor;

	            startx = touchObj.clientX;
	            starty = touchObj.clientY;

	            callback(e);
	        });
	    } 
	};

	exports.addMouseWheelListener = function(el, callback) {
	    if ("onmousewheel" in el) {
	        exports.addListener(el, "mousewheel", function(e) {
	            var factor = 8;
	            if (e.wheelDeltaX !== undefined) {
	                e.wheelX = -e.wheelDeltaX / factor;
	                e.wheelY = -e.wheelDeltaY / factor;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = -e.wheelDelta / factor;
	            }
	            callback(e);
	        });
	    } else if ("onwheel" in el) {
	        exports.addListener(el, "wheel",  function(e) {
	            var factor = 0.35;
	            switch (e.deltaMode) {
	                case e.DOM_DELTA_PIXEL:
	                    e.wheelX = e.deltaX * factor || 0;
	                    e.wheelY = e.deltaY * factor || 0;
	                    break;
	                case e.DOM_DELTA_LINE:
	                case e.DOM_DELTA_PAGE:
	                    e.wheelX = (e.deltaX || 0) * 5;
	                    e.wheelY = (e.deltaY || 0) * 5;
	                    break;
	            }
	            
	            callback(e);
	        });
	    } else {
	        exports.addListener(el, "DOMMouseScroll", function(e) {
	            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
	                e.wheelX = (e.detail || 0) * 5;
	                e.wheelY = 0;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = (e.detail || 0) * 5;
	            }
	            callback(e);
	        });
	    }
	};

	exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
	    var clicks = 0;
	    var startX, startY, timer; 
	    var eventNames = {
	        2: "dblclick",
	        3: "tripleclick",
	        4: "quadclick"
	    };

	    function onMousedown(e) {
	        if (exports.getButton(e) !== 0) {
	            clicks = 0;
	        } else if (e.detail > 1) {
	            clicks++;
	            if (clicks > 4)
	                clicks = 1;
	        } else {
	            clicks = 1;
	        }
	        if (useragent.isIE) {
	            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
	            if (!timer || isNewClick)
	                clicks = 1;
	            if (timer)
	                clearTimeout(timer);
	            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

	            if (clicks == 1) {
	                startX = e.clientX;
	                startY = e.clientY;
	            }
	        }
	        
	        e._clicks = clicks;

	        eventHandler[callbackName]("mousedown", e);

	        if (clicks > 4)
	            clicks = 0;
	        else if (clicks > 1)
	            return eventHandler[callbackName](eventNames[clicks], e);
	    }
	    function onDblclick(e) {
	        clicks = 2;
	        if (timer)
	            clearTimeout(timer);
	        timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
	        eventHandler[callbackName]("mousedown", e);
	        eventHandler[callbackName](eventNames[clicks], e);
	    }
	    if (!Array.isArray(elements))
	        elements = [elements];
	    elements.forEach(function(el) {
	        exports.addListener(el, "mousedown", onMousedown);
	        if (useragent.isOldIE)
	            exports.addListener(el, "dblclick", onDblclick);
	    });
	};

	var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
	    ? function(e) {
	        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
	    }
	    : function(e) {
	        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
	    };

	exports.getModifierString = function(e) {
	    return keys.KEY_MODS[getModifierHash(e)];
	};

	function normalizeCommandKeys(callback, e, keyCode) {
	    var hashId = getModifierHash(e);

	    if (!useragent.isMac && pressedKeys) {
	        if (pressedKeys.OSKey)
	            hashId |= 8;
	        if (pressedKeys.altGr) {
	            if ((3 & hashId) != 3)
	                pressedKeys.altGr = 0;
	            else
	                return;
	        }
	        if (keyCode === 18 || keyCode === 17) {
	            var location = "location" in e ? e.location : e.keyLocation;
	            if (keyCode === 17 && location === 1) {
	                if (pressedKeys[keyCode] == 1)
	                    ts = e.timeStamp;
	            } else if (keyCode === 18 && hashId === 3 && location === 2) {
	                var dt = e.timeStamp - ts;
	                if (dt < 50)
	                    pressedKeys.altGr = true;
	            }
	        }
	    }
	    
	    if (keyCode in keys.MODIFIER_KEYS) {
	        keyCode = -1;
	    }
	    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
	        keyCode = -1;
	    }
	    
	    if (!hashId && keyCode === 13) {
	        var location = "location" in e ? e.location : e.keyLocation;
	        if (location === 3) {
	            callback(e, hashId, -keyCode);
	            if (e.defaultPrevented)
	                return;
	        }
	    }
	    
	    if (useragent.isChromeOS && hashId & 8) {
	        callback(e, hashId, keyCode);
	        if (e.defaultPrevented)
	            return;
	        else
	            hashId &= ~8;
	    }
	    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
	        return false;
	    }
	    
	    return callback(e, hashId, keyCode);
	}


	exports.addCommandKeyListener = function(el, callback) {
	    var addListener = exports.addListener;
	    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
	        var lastKeyDownKeyCode = null;
	        addListener(el, "keydown", function(e) {
	            lastKeyDownKeyCode = e.keyCode;
	        });
	        addListener(el, "keypress", function(e) {
	            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
	        });
	    } else {
	        var lastDefaultPrevented = null;

	        addListener(el, "keydown", function(e) {
	            var keyCode = e.keyCode;
	            pressedKeys[keyCode] = (pressedKeys[keyCode] || 0) + 1;
	            if (keyCode == 91 || keyCode == 92) {
	                pressedKeys.OSKey = true;
	            } else if (pressedKeys.OSKey) {
	                if (e.timeStamp - pressedKeys.lastT > 200 && pressedKeys.count == 1)
	                    resetPressedKeys();
	            }
	            if (pressedKeys[keyCode] == 1)
	                pressedKeys.count++;
	            pressedKeys.lastT = e.timeStamp;
	            var result = normalizeCommandKeys(callback, e, keyCode);
	            lastDefaultPrevented = e.defaultPrevented;
	            return result;
	        });

	        addListener(el, "keypress", function(e) {
	            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
	                exports.stopEvent(e);
	                lastDefaultPrevented = null;
	            }
	        });

	        addListener(el, "keyup", function(e) {
	            var keyCode = e.keyCode;
	            if (!pressedKeys[keyCode]) {
	                resetPressedKeys();
	            } else {
	                pressedKeys.count = Math.max(pressedKeys.count - 1, 0);
	            }
	            if (keyCode == 91 || keyCode == 92) {
	                pressedKeys.OSKey = false;
	            }
	            pressedKeys[keyCode] = null;
	        });

	        if (!pressedKeys) {
	            resetPressedKeys();
	            addListener(window, "focus", resetPressedKeys);
	        }
	    }
	};
	function resetPressedKeys() {
	    pressedKeys = Object.create(null);
	    pressedKeys.count = 0;
	    pressedKeys.lastT = 0;
	}

	if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
	    var postMessageId = 1;
	    exports.nextTick = function(callback, win) {
	        win = win || window;
	        var messageName = "zero-timeout-message-" + postMessageId;
	        exports.addListener(win, "message", function listener(e) {
	            if (e.data == messageName) {
	                exports.stopPropagation(e);
	                exports.removeListener(win, "message", listener);
	                callback();
	            }
	        });
	        win.postMessage(messageName, "*");
	    };
	}


	exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
	    || window.mozRequestAnimationFrame
	    || window.webkitRequestAnimationFrame
	    || window.msRequestAnimationFrame
	    || window.oRequestAnimationFrame);

	if (exports.nextFrame)
	    exports.nextFrame = exports.nextFrame.bind(window);
	else
	    exports.nextFrame = function(callback) {
	        setTimeout(callback, 17);
	    };
	});

	ace.define("ace/lib/lang",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.last = function(a) {
	    return a[a.length - 1];
	};

	exports.stringReverse = function(string) {
	    return string.split("").reverse().join("");
	};

	exports.stringRepeat = function (string, count) {
	    var result = '';
	    while (count > 0) {
	        if (count & 1)
	            result += string;

	        if (count >>= 1)
	            string += string;
	    }
	    return result;
	};

	var trimBeginRegexp = /^\s\s*/;
	var trimEndRegexp = /\s\s*$/;

	exports.stringTrimLeft = function (string) {
	    return string.replace(trimBeginRegexp, '');
	};

	exports.stringTrimRight = function (string) {
	    return string.replace(trimEndRegexp, '');
	};

	exports.copyObject = function(obj) {
	    var copy = {};
	    for (var key in obj) {
	        copy[key] = obj[key];
	    }
	    return copy;
	};

	exports.copyArray = function(array){
	    var copy = [];
	    for (var i=0, l=array.length; i<l; i++) {
	        if (array[i] && typeof array[i] == "object")
	            copy[i] = this.copyObject( array[i] );
	        else 
	            copy[i] = array[i];
	    }
	    return copy;
	};

	exports.deepCopy = function deepCopy(obj) {
	    if (typeof obj !== "object" || !obj)
	        return obj;
	    var copy;
	    if (Array.isArray(obj)) {
	        copy = [];
	        for (var key = 0; key < obj.length; key++) {
	            copy[key] = deepCopy(obj[key]);
	        }
	        return copy;
	    }
	    var cons = obj.constructor;
	    if (cons === RegExp)
	        return obj;
	    
	    copy = cons();
	    for (var key in obj) {
	        copy[key] = deepCopy(obj[key]);
	    }
	    return copy;
	};

	exports.arrayToMap = function(arr) {
	    var map = {};
	    for (var i=0; i<arr.length; i++) {
	        map[arr[i]] = 1;
	    }
	    return map;

	};

	exports.createMap = function(props) {
	    var map = Object.create(null);
	    for (var i in props) {
	        map[i] = props[i];
	    }
	    return map;
	};
	exports.arrayRemove = function(array, value) {
	  for (var i = 0; i <= array.length; i++) {
	    if (value === array[i]) {
	      array.splice(i, 1);
	    }
	  }
	};

	exports.escapeRegExp = function(str) {
	    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
	};

	exports.escapeHTML = function(str) {
	    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
	};

	exports.getMatchOffsets = function(string, regExp) {
	    var matches = [];

	    string.replace(regExp, function(str) {
	        matches.push({
	            offset: arguments[arguments.length-2],
	            length: str.length
	        });
	    });

	    return matches;
	};
	exports.deferredCall = function(fcn) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var deferred = function(timeout) {
	        deferred.cancel();
	        timer = setTimeout(callback, timeout || 0);
	        return deferred;
	    };

	    deferred.schedule = deferred;

	    deferred.call = function() {
	        this.cancel();
	        fcn();
	        return deferred;
	    };

	    deferred.cancel = function() {
	        clearTimeout(timer);
	        timer = null;
	        return deferred;
	    };
	    
	    deferred.isPending = function() {
	        return timer;
	    };

	    return deferred;
	};


	exports.delayedCall = function(fcn, defaultTimeout) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var _self = function(timeout) {
	        if (timer == null)
	            timer = setTimeout(callback, timeout || defaultTimeout);
	    };

	    _self.delay = function(timeout) {
	        timer && clearTimeout(timer);
	        timer = setTimeout(callback, timeout || defaultTimeout);
	    };
	    _self.schedule = _self;

	    _self.call = function() {
	        this.cancel();
	        fcn();
	    };

	    _self.cancel = function() {
	        timer && clearTimeout(timer);
	        timer = null;
	    };

	    _self.isPending = function() {
	        return timer;
	    };

	    return _self;
	};
	});

	ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var BROKEN_SETDATA = useragent.isChrome < 18;
	var USE_IE_MIME_TYPE =  useragent.isIE;

	var TextInput = function(parentNode, host) {
	    var text = dom.createElement("textarea");
	    text.className = "ace_text-input";

	    if (useragent.isTouchPad)
	        text.setAttribute("x-palm-disable-auto-cap", true);

	    text.setAttribute("wrap", "off");
	    text.setAttribute("autocorrect", "off");
	    text.setAttribute("autocapitalize", "off");
	    text.setAttribute("spellcheck", false);

	    text.style.opacity = "0";
	    if (useragent.isOldIE) text.style.top = "-1000px";
	    parentNode.insertBefore(text, parentNode.firstChild);

	    var PLACEHOLDER = "\x01\x01";

	    var copied = false;
	    var pasted = false;
	    var inComposition = false;
	    var tempStyle = '';
	    var isSelectionEmpty = true;
	    try { var isFocused = document.activeElement === text; } catch(e) {}
	    
	    event.addListener(text, "blur", function(e) {
	        host.onBlur(e);
	        isFocused = false;
	    });
	    event.addListener(text, "focus", function(e) {
	        isFocused = true;
	        host.onFocus(e);
	        resetSelection();
	    });
	    this.focus = function() {
	        if (tempStyle) return text.focus();
	        var top = text.style.top;
	        text.style.position = "fixed";
	        text.style.top = "0px";
	        text.focus();
	        setTimeout(function() {
	            text.style.position = "";
	            if (text.style.top == "0px")
	                text.style.top = top;
	        }, 0);
	    };
	    this.blur = function() {
	        text.blur();
	    };
	    this.isFocused = function() {
	        return isFocused;
	    };
	    var syncSelection = lang.delayedCall(function() {
	        isFocused && resetSelection(isSelectionEmpty);
	    });
	    var syncValue = lang.delayedCall(function() {
	         if (!inComposition) {
	            text.value = PLACEHOLDER;
	            isFocused && resetSelection();
	         }
	    });

	    function resetSelection(isEmpty) {
	        if (inComposition)
	            return;
	        inComposition = true;
	        
	        if (inputHandler) {
	            selectionStart = 0;
	            selectionEnd = isEmpty ? 0 : text.value.length - 1;
	        } else {
	            var selectionStart = isEmpty ? 2 : 1;
	            var selectionEnd = 2;
	        }
	        try {
	            text.setSelectionRange(selectionStart, selectionEnd);
	        } catch(e){}
	        
	        inComposition = false;
	    }

	    function resetValue() {
	        if (inComposition)
	            return;
	        text.value = PLACEHOLDER;
	        if (useragent.isWebKit)
	            syncValue.schedule();
	    }

	    useragent.isWebKit || host.addEventListener('changeSelection', function() {
	        if (host.selection.isEmpty() != isSelectionEmpty) {
	            isSelectionEmpty = !isSelectionEmpty;
	            syncSelection.schedule();
	        }
	    });

	    resetValue();
	    if (isFocused)
	        host.onFocus();


	    var isAllSelected = function(text) {
	        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
	    };
	    if (!text.setSelectionRange && text.createTextRange) {
	        text.setSelectionRange = function(selectionStart, selectionEnd) {
	            var range = this.createTextRange();
	            range.collapse(true);
	            range.moveStart('character', selectionStart);
	            range.moveEnd('character', selectionEnd);
	            range.select();
	        };
	        isAllSelected = function(text) {
	            try {
	                var range = text.ownerDocument.selection.createRange();
	            }catch(e) {}
	            if (!range || range.parentElement() != text) return false;
	                return range.text == text.value;
	        }
	    }
	    if (useragent.isOldIE) {
	        var inPropertyChange = false;
	        var onPropertyChange = function(e){
	            if (inPropertyChange)
	                return;
	            var data = text.value;
	            if (inComposition || !data || data == PLACEHOLDER)
	                return;
	            if (e && data == PLACEHOLDER[0])
	                return syncProperty.schedule();

	            sendText(data);
	            inPropertyChange = true;
	            resetValue();
	            inPropertyChange = false;
	        };
	        var syncProperty = lang.delayedCall(onPropertyChange);
	        event.addListener(text, "propertychange", onPropertyChange);

	        var keytable = { 13:1, 27:1 };
	        event.addListener(text, "keyup", function (e) {
	            if (inComposition && (!text.value || keytable[e.keyCode]))
	                setTimeout(onCompositionEnd, 0);
	            if ((text.value.charCodeAt(0)||0) < 129) {
	                return syncProperty.call();
	            }
	            inComposition ? onCompositionUpdate() : onCompositionStart();
	        });
	        event.addListener(text, "keydown", function (e) {
	            syncProperty.schedule(50);
	        });
	    }

	    var onSelect = function(e) {
	        if (copied) {
	            copied = false;
	        } else if (isAllSelected(text)) {
	            host.selectAll();
	            resetSelection();
	        } else if (inputHandler) {
	            resetSelection(host.selection.isEmpty());
	        }
	    };

	    var inputHandler = null;
	    this.setInputHandler = function(cb) {inputHandler = cb};
	    this.getInputHandler = function() {return inputHandler};
	    var afterContextMenu = false;
	    
	    var sendText = function(data) {
	        if (inputHandler) {
	            data = inputHandler(data);
	            inputHandler = null;
	        }
	        if (pasted) {
	            resetSelection();
	            if (data)
	                host.onPaste(data);
	            pasted = false;
	        } else if (data == PLACEHOLDER.charAt(0)) {
	            if (afterContextMenu)
	                host.execCommand("del", {source: "ace"});
	            else // some versions of android do not fire keydown when pressing backspace
	                host.execCommand("backspace", {source: "ace"});
	        } else {
	            if (data.substring(0, 2) == PLACEHOLDER)
	                data = data.substr(2);
	            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
	                data = data.substr(1);
	            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            
	            if (data)
	                host.onTextInput(data);
	        }
	        if (afterContextMenu)
	            afterContextMenu = false;
	    };
	    var onInput = function(e) {
	        if (inComposition)
	            return;
	        var data = text.value;
	        sendText(data);
	        resetValue();
	    };
	    
	    var handleClipboardData = function(e, data) {
	        var clipboardData = e.clipboardData || window.clipboardData;
	        if (!clipboardData || BROKEN_SETDATA)
	            return;
	        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
	        if (data) {
	            return clipboardData.setData(mime, data) !== false;
	        } else {
	            return clipboardData.getData(mime);
	        }
	    };

	    var doCopy = function(e, isCut) {
	        var data = host.getCopyText();
	        if (!data)
	            return event.preventDefault(e);

	        if (handleClipboardData(e, data)) {
	            isCut ? host.onCut() : host.onCopy();
	            event.preventDefault(e);
	        } else {
	            copied = true;
	            text.value = data;
	            text.select();
	            setTimeout(function(){
	                copied = false;
	                resetValue();
	                resetSelection();
	                isCut ? host.onCut() : host.onCopy();
	            });
	        }
	    };
	    
	    var onCut = function(e) {
	        doCopy(e, true);
	    };
	    
	    var onCopy = function(e) {
	        doCopy(e, false);
	    };
	    
	    var onPaste = function(e) {
	        var data = handleClipboardData(e);
	        if (typeof data == "string") {
	            if (data)
	                host.onPaste(data, e);
	            if (useragent.isIE)
	                setTimeout(resetSelection);
	            event.preventDefault(e);
	        }
	        else {
	            text.value = "";
	            pasted = true;
	        }
	    };

	    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

	    event.addListener(text, "select", onSelect);

	    event.addListener(text, "input", onInput);

	    event.addListener(text, "cut", onCut);
	    event.addListener(text, "copy", onCopy);
	    event.addListener(text, "paste", onPaste);
	    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
	        event.addListener(parentNode, "keydown", function(e) {
	            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
	                return;

	            switch (e.keyCode) {
	                case 67:
	                    onCopy(e);
	                    break;
	                case 86:
	                    onPaste(e);
	                    break;
	                case 88:
	                    onCut(e);
	                    break;
	            }
	        });
	    }
	    var onCompositionStart = function(e) {
	        if (inComposition || !host.onCompositionStart || host.$readOnly) 
	            return;
	        inComposition = {};
	        host.onCompositionStart();
	        setTimeout(onCompositionUpdate, 0);
	        host.on("mousedown", onCompositionEnd);
	        if (!host.selection.isEmpty()) {
	            host.insert("");
	            host.session.markUndoGroup();
	            host.selection.clearSelection();
	        }
	        host.session.markUndoGroup();
	    };

	    var onCompositionUpdate = function() {
	        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
	            return;
	        var val = text.value.replace(/\x01/g, "");
	        if (inComposition.lastValue === val) return;
	        
	        host.onCompositionUpdate(val);
	        if (inComposition.lastValue)
	            host.undo();
	        inComposition.lastValue = val;
	        if (inComposition.lastValue) {
	            var r = host.selection.getRange();
	            host.insert(inComposition.lastValue);
	            host.session.markUndoGroup();
	            inComposition.range = host.selection.getRange();
	            host.selection.setRange(r);
	            host.selection.clearSelection();
	        }
	    };

	    var onCompositionEnd = function(e) {
	        if (!host.onCompositionEnd || host.$readOnly) return;
	        var c = inComposition;
	        inComposition = false;
	        var timer = setTimeout(function() {
	            timer = null;
	            var str = text.value.replace(/\x01/g, "");
	            if (inComposition)
	                return;
	            else if (str == c.lastValue)
	                resetValue();
	            else if (!c.lastValue && str) {
	                resetValue();
	                sendText(str);
	            }
	        });
	        inputHandler = function compositionInputHandler(str) {
	            if (timer)
	                clearTimeout(timer);
	            str = str.replace(/\x01/g, "");
	            if (str == c.lastValue)
	                return "";
	            if (c.lastValue && timer)
	                host.undo();
	            return str;
	        };
	        host.onCompositionEnd();
	        host.removeListener("mousedown", onCompositionEnd);
	        if (e.type == "compositionend" && c.range) {
	            host.selection.setRange(c.range);
	        }
	    };
	    
	    

	    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

	    event.addListener(text, "compositionstart", onCompositionStart);
	    if (useragent.isGecko) {
	        event.addListener(text, "text", function(){syncComposition.schedule()});
	    } else {
	        event.addListener(text, "keyup", function(){syncComposition.schedule()});
	        event.addListener(text, "keydown", function(){syncComposition.schedule()});
	    }
	    event.addListener(text, "compositionend", onCompositionEnd);

	    this.getElement = function() {
	        return text;
	    };

	    this.setReadOnly = function(readOnly) {
	       text.readOnly = readOnly;
	    };

	    this.onContextMenu = function(e) {
	        afterContextMenu = true;
	        resetSelection(host.selection.isEmpty());
	        host._emit("nativecontextmenu", {target: host, domEvent: e});
	        this.moveToMouse(e, true);
	    };
	    
	    this.moveToMouse = function(e, bringToFront) {
	        if (!bringToFront && useragent.isOldIE)
	            return;
	        if (!tempStyle)
	            tempStyle = text.style.cssText;
	        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
	            + "height:" + text.style.height + ";"
	            + (useragent.isIE ? "opacity:0.1;" : "");

	        var rect = host.container.getBoundingClientRect();
	        var style = dom.computedStyle(host.container);
	        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
	        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
	        var maxTop = rect.bottom - top - text.clientHeight -2;
	        var move = function(e) {
	            text.style.left = e.clientX - left - 2 + "px";
	            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
	        }; 
	        move(e);

	        if (e.type != "mousedown")
	            return;

	        if (host.renderer.$keepTextAreaAtCursor)
	            host.renderer.$keepTextAreaAtCursor = null;

	        clearTimeout(closeTimeout);
	        if (useragent.isWin && !useragent.isOldIE)
	            event.capture(host.container, move, onContextMenuClose);
	    };

	    this.onContextMenuClose = onContextMenuClose;
	    var closeTimeout;
	    function onContextMenuClose() {
	        clearTimeout(closeTimeout);
	        closeTimeout = setTimeout(function () {
	            if (tempStyle) {
	                text.style.cssText = tempStyle;
	                tempStyle = '';
	            }
	            if (host.renderer.$keepTextAreaAtCursor == null) {
	                host.renderer.$keepTextAreaAtCursor = true;
	                host.renderer.$moveTextAreaToCursor();
	            }
	        }, useragent.isOldIE ? 200 : 0);
	    }

	    var onContextMenu = function(e) {
	        host.textInput.onContextMenu(e);
	        onContextMenuClose();
	    };
	    event.addListener(text, "mouseup", onContextMenu);
	    event.addListener(text, "mousedown", function(e) {
	        e.preventDefault();
	        onContextMenuClose();
	    });
	    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
	    event.addListener(text, "contextmenu", onContextMenu);
	};

	exports.TextInput = TextInput;
	});

	ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var DRAG_OFFSET = 0; // pixels

	function DefaultHandlers(mouseHandler) {
	    mouseHandler.$clickSelection = null;

	    var editor = mouseHandler.editor;
	    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
	    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
	    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
	    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
	    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
	    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

	    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
	        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

	    exports.forEach(function(x) {
	        mouseHandler[x] = this[x];
	    }, this);

	    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
	    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
	}

	(function() {

	    this.onMouseDown = function(ev) {
	        var inSelection = ev.inSelection();
	        var pos = ev.getDocumentPosition();
	        this.mousedownEvent = ev;
	        var editor = this.editor;

	        var button = ev.getButton();
	        if (button !== 0) {
	            var selectionRange = editor.getSelectionRange();
	            var selectionEmpty = selectionRange.isEmpty();
	            editor.$blockScrolling++;
	            if (selectionEmpty || button == 1)
	                editor.selection.moveToPosition(pos);
	            editor.$blockScrolling--;
	            if (button == 2)
	                editor.textInput.onContextMenu(ev.domEvent);
	            return; // stopping event here breaks contextmenu on ff mac
	        }

	        this.mousedownEvent.time = Date.now();
	        if (inSelection && !editor.isFocused()) {
	            editor.focus();
	            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
	                this.setState("focusWait");
	                this.captureMouse(ev);
	                return;
	            }
	        }

	        this.captureMouse(ev);
	        this.startSelect(pos, ev.domEvent._clicks > 1);
	        return ev.preventDefault();
	    };

	    this.startSelect = function(pos, waitForClickSelection) {
	        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var editor = this.editor;
	        editor.$blockScrolling++;
	        if (this.mousedownEvent.getShiftKey())
	            editor.selection.selectToPosition(pos);
	        else if (!waitForClickSelection)
	            editor.selection.moveToPosition(pos);
	        if (!waitForClickSelection)
	            this.select();
	        if (editor.renderer.scroller.setCapture) {
	            editor.renderer.scroller.setCapture();
	        }
	        editor.setStyle("ace_selecting");
	        this.setState("select");
	        editor.$blockScrolling--;
	    };

	    this.select = function() {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmp = this.$clickSelection.comparePoint(cursor);

	            if (cmp == -1) {
	                anchor = this.$clickSelection.end;
	            } else if (cmp == 1) {
	                anchor = this.$clickSelection.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.extendSelectionBy = function(unitName) {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var range = editor.selection[unitName](cursor.row, cursor.column);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmpStart = this.$clickSelection.comparePoint(range.start);
	            var cmpEnd = this.$clickSelection.comparePoint(range.end);

	            if (cmpStart == -1 && cmpEnd <= 0) {
	                anchor = this.$clickSelection.end;
	                if (range.end.row != cursor.row || range.end.column != cursor.column)
	                    cursor = range.start;
	            } else if (cmpEnd == 1 && cmpStart >= 0) {
	                anchor = this.$clickSelection.start;
	                if (range.start.row != cursor.row || range.start.column != cursor.column)
	                    cursor = range.end;
	            } else if (cmpStart == -1 && cmpEnd == 1) {
	                cursor = range.end;
	                anchor = range.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.selectEnd =
	    this.selectAllEnd =
	    this.selectByWordsEnd =
	    this.selectByLinesEnd = function() {
	        this.$clickSelection = null;
	        this.editor.unsetStyle("ace_selecting");
	        if (this.editor.renderer.scroller.releaseCapture) {
	            this.editor.renderer.scroller.releaseCapture();
	        }
	    };

	    this.focusWait = function() {
	        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	        var time = Date.now();

	        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
	            this.startSelect(this.mousedownEvent.getDocumentPosition());
	    };

	    this.onDoubleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;
	        var session = editor.session;

	        var range = session.getBracketRange(pos);
	        if (range) {
	            if (range.isEmpty()) {
	                range.start.column--;
	                range.end.column++;
	            }
	            this.setState("select");
	        } else {
	            range = editor.selection.getWordRange(pos.row, pos.column);
	            this.setState("selectByWords");
	        }
	        this.$clickSelection = range;
	        this.select();
	    };

	    this.onTripleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;

	        this.setState("selectByLines");
	        var range = editor.getSelectionRange();
	        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
	            this.$clickSelection = editor.selection.getLineRange(range.start.row);
	            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
	        } else {
	            this.$clickSelection = editor.selection.getLineRange(pos.row);
	        }
	        this.select();
	    };

	    this.onQuadClick = function(ev) {
	        var editor = this.editor;

	        editor.selectAll();
	        this.$clickSelection = editor.getSelectionRange();
	        this.setState("selectAll");
	    };

	    this.onMouseWheel = function(ev) {
	        if (ev.getAccelKey())
	            return;
	        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
	            ev.wheelX = ev.wheelY;
	            ev.wheelY = 0;
	        }

	        var t = ev.domEvent.timeStamp;
	        var dt = t - (this.$lastScrollTime||0);
	        
	        var editor = this.editor;
	        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	        if (isScrolable || dt < 200) {
	            this.$lastScrollTime = t;
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };
	    
	    this.onTouchMove = function (ev) {
	        var t = ev.domEvent.timeStamp;
	        var dt = t - (this.$lastScrollTime || 0);

	        var editor = this.editor;
	        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	        if (isScrolable || dt < 200) {
	            this.$lastScrollTime = t;
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };

	}).call(DefaultHandlers.prototype);

	exports.DefaultHandlers = DefaultHandlers;

	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	function calcRangeOrientation(range, cursor) {
	    if (range.start.row == range.end.row)
	        var cmp = 2 * cursor.column - range.start.column - range.end.column;
	    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
	        var cmp = cursor.column - 4;
	    else
	        var cmp = 2 * cursor.row - range.start.row - range.end.row;

	    if (cmp < 0)
	        return {cursor: range.start, anchor: range.end};
	    else
	        return {cursor: range.end, anchor: range.start};
	}

	});

	ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	function Tooltip (parentNode) {
	    this.isOpen = false;
	    this.$element = null;
	    this.$parentNode = parentNode;
	}

	(function() {
	    this.$init = function() {
	        this.$element = dom.createElement("div");
	        this.$element.className = "ace_tooltip";
	        this.$element.style.display = "none";
	        this.$parentNode.appendChild(this.$element);
	        return this.$element;
	    };
	    this.getElement = function() {
	        return this.$element || this.$init();
	    };
	    this.setText = function(text) {
	        dom.setInnerText(this.getElement(), text);
	    };
	    this.setHtml = function(html) {
	        this.getElement().innerHTML = html;
	    };
	    this.setPosition = function(x, y) {
	        this.getElement().style.left = x + "px";
	        this.getElement().style.top = y + "px";
	    };
	    this.setClassName = function(className) {
	        dom.addCssClass(this.getElement(), className);
	    };
	    this.show = function(text, x, y) {
	        if (text != null)
	            this.setText(text);
	        if (x != null && y != null)
	            this.setPosition(x, y);
	        if (!this.isOpen) {
	            this.getElement().style.display = "block";
	            this.isOpen = true;
	        }
	    };

	    this.hide = function() {
	        if (this.isOpen) {
	            this.getElement().style.display = "none";
	            this.isOpen = false;
	        }
	    };
	    this.getHeight = function() {
	        return this.getElement().offsetHeight;
	    };
	    this.getWidth = function() {
	        return this.getElement().offsetWidth;
	    };

	}).call(Tooltip.prototype);

	exports.Tooltip = Tooltip;
	});

	ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var event = acequire("../lib/event");
	var Tooltip = acequire("../tooltip").Tooltip;

	function GutterHandler(mouseHandler) {
	    var editor = mouseHandler.editor;
	    var gutter = editor.renderer.$gutterLayer;
	    var tooltip = new GutterTooltip(editor.container);

	    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
	        if (!editor.isFocused() || e.getButton() != 0)
	            return;
	        var gutterRegion = gutter.getRegion(e);

	        if (gutterRegion == "foldWidgets")
	            return;

	        var row = e.getDocumentPosition().row;
	        var selection = editor.session.selection;

	        if (e.getShiftKey())
	            selection.selectTo(row, 0);
	        else {
	            if (e.domEvent.detail == 2) {
	                editor.selectAll();
	                return e.preventDefault();
	            }
	            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
	        }
	        mouseHandler.setState("selectByLines");
	        mouseHandler.captureMouse(e);
	        return e.preventDefault();
	    });


	    var tooltipTimeout, mouseEvent, tooltipAnnotation;

	    function showTooltip() {
	        var row = mouseEvent.getDocumentPosition().row;
	        var annotation = gutter.$annotations[row];
	        if (!annotation)
	            return hideTooltip();

	        var maxRow = editor.session.getLength();
	        if (row == maxRow) {
	            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
	            var pos = mouseEvent.$pos;
	            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
	                return hideTooltip();
	        }

	        if (tooltipAnnotation == annotation)
	            return;
	        tooltipAnnotation = annotation.text.join("<br/>");

	        tooltip.setHtml(tooltipAnnotation);
	        tooltip.show();
	        editor.on("mousewheel", hideTooltip);

	        if (mouseHandler.$tooltipFollowsMouse) {
	            moveTooltip(mouseEvent);
	        } else {
	            var gutterElement = mouseEvent.domEvent.target;
	            var rect = gutterElement.getBoundingClientRect();
	            var style = tooltip.getElement().style;
	            style.left = rect.right + "px";
	            style.top = rect.bottom + "px";
	        }
	    }

	    function hideTooltip() {
	        if (tooltipTimeout)
	            tooltipTimeout = clearTimeout(tooltipTimeout);
	        if (tooltipAnnotation) {
	            tooltip.hide();
	            tooltipAnnotation = null;
	            editor.removeEventListener("mousewheel", hideTooltip);
	        }
	    }

	    function moveTooltip(e) {
	        tooltip.setPosition(e.x, e.y);
	    }

	    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
	        var target = e.domEvent.target || e.domEvent.srcElement;
	        if (dom.hasCssClass(target, "ace_fold-widget"))
	            return hideTooltip();

	        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
	            moveTooltip(e);

	        mouseEvent = e;
	        if (tooltipTimeout)
	            return;
	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            if (mouseEvent && !mouseHandler.isMousePressed)
	                showTooltip();
	            else
	                hideTooltip();
	        }, 50);
	    });

	    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
	        mouseEvent = null;
	        if (!tooltipAnnotation || tooltipTimeout)
	            return;

	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            hideTooltip();
	        }, 50);
	    });
	    
	    editor.on("changeSession", hideTooltip);
	}

	function GutterTooltip(parentNode) {
	    Tooltip.call(this, parentNode);
	}

	oop.inherits(GutterTooltip, Tooltip);

	(function(){
	    this.setPosition = function(x, y) {
	        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
	        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
	        var width = this.getWidth();
	        var height = this.getHeight();
	        x += 15;
	        y += 15;
	        if (x + width > windowWidth) {
	            x -= (x + width) - windowWidth;
	        }
	        if (y + height > windowHeight) {
	            y -= 20 + height;
	        }
	        Tooltip.prototype.setPosition.call(this, x, y);
	    };

	}).call(GutterTooltip.prototype);



	exports.GutterHandler = GutterHandler;

	});

	ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
	    this.domEvent = domEvent;
	    this.editor = editor;
	    
	    this.x = this.clientX = domEvent.clientX;
	    this.y = this.clientY = domEvent.clientY;

	    this.$pos = null;
	    this.$inSelection = null;
	    
	    this.propagationStopped = false;
	    this.defaultPrevented = false;
	};

	(function() {  
	    
	    this.stopPropagation = function() {
	        event.stopPropagation(this.domEvent);
	        this.propagationStopped = true;
	    };
	    
	    this.preventDefault = function() {
	        event.preventDefault(this.domEvent);
	        this.defaultPrevented = true;
	    };
	    
	    this.stop = function() {
	        this.stopPropagation();
	        this.preventDefault();
	    };
	    this.getDocumentPosition = function() {
	        if (this.$pos)
	            return this.$pos;
	        
	        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
	        return this.$pos;
	    };
	    this.inSelection = function() {
	        if (this.$inSelection !== null)
	            return this.$inSelection;
	            
	        var editor = this.editor;
	        

	        var selectionRange = editor.getSelectionRange();
	        if (selectionRange.isEmpty())
	            this.$inSelection = false;
	        else {
	            var pos = this.getDocumentPosition();
	            this.$inSelection = selectionRange.contains(pos.row, pos.column);
	        }

	        return this.$inSelection;
	    };
	    this.getButton = function() {
	        return event.getButton(this.domEvent);
	    };
	    this.getShiftKey = function() {
	        return this.domEvent.shiftKey;
	    };
	    
	    this.getAccelKey = useragent.isMac
	        ? function() { return this.domEvent.metaKey; }
	        : function() { return this.domEvent.ctrlKey; };
	    
	}).call(MouseEvent.prototype);

	});

	ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var AUTOSCROLL_DELAY = 200;
	var SCROLL_CURSOR_DELAY = 200;
	var SCROLL_CURSOR_HYSTERESIS = 5;

	function DragdropHandler(mouseHandler) {

	    var editor = mouseHandler.editor;

	    var blankImage = dom.createElement("img");
	    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (useragent.isOpera)
	        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

	    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

	     exports.forEach(function(x) {
	         mouseHandler[x] = this[x];
	    }, this);
	    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


	    var mouseTarget = editor.container;
	    var dragSelectionMarker, x, y;
	    var timerId, range;
	    var dragCursor, counter = 0;
	    var dragOperation;
	    var isInternal;
	    var autoScrollStartTime;
	    var cursorMovedTime;
	    var cursorPointOnCaretMoved;

	    this.onDragStart = function(e) {
	        if (this.cancelDrag || !mouseTarget.draggable) {
	            var self = this;
	            setTimeout(function(){
	                self.startSelect();
	                self.captureMouse(e);
	            }, 0);
	            return e.preventDefault();
	        }
	        range = editor.getSelectionRange();

	        var dataTransfer = e.dataTransfer;
	        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
	        if (useragent.isOpera) {
	            editor.container.appendChild(blankImage);
	            blankImage.scrollTop = 0;
	        }
	        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
	        if (useragent.isOpera) {
	            editor.container.removeChild(blankImage);
	        }
	        dataTransfer.clearData();
	        dataTransfer.setData("Text", editor.session.getTextRange());

	        isInternal = true;
	        this.setState("drag");
	    };

	    this.onDragEnd = function(e) {
	        mouseTarget.draggable = false;
	        isInternal = false;
	        this.setState(null);
	        if (!editor.getReadOnly()) {
	            var dropEffect = e.dataTransfer.dropEffect;
	            if (!dragOperation && dropEffect == "move")
	                editor.session.remove(editor.getSelectionRange());
	            editor.renderer.$cursorLayer.setBlinking(true);
	        }
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	    };

	    this.onDragEnter = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker)
	            addDragMarker();
	        counter++;
	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragOver = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker) {
	            addDragMarker();
	            counter++;
	        }
	        if (onMouseMoveTimer !== null)
	            onMouseMoveTimer = null;

	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragLeave = function(e) {
	        counter--;
	        if (counter <= 0 && dragSelectionMarker) {
	            clearDragMarker();
	            dragOperation = null;
	            return event.preventDefault(e);
	        }
	    };

	    this.onDrop = function(e) {
	        if (!dragCursor)
	            return;
	        var dataTransfer = e.dataTransfer;
	        if (isInternal) {
	            switch (dragOperation) {
	                case "move":
	                    if (range.contains(dragCursor.row, dragCursor.column)) {
	                        range = {
	                            start: dragCursor,
	                            end: dragCursor
	                        };
	                    } else {
	                        range = editor.moveText(range, dragCursor);
	                    }
	                    break;
	                case "copy":
	                    range = editor.moveText(range, dragCursor, true);
	                    break;
	            }
	        } else {
	            var dropData = dataTransfer.getData('Text');
	            range = {
	                start: dragCursor,
	                end: editor.session.insert(dragCursor, dropData)
	            };
	            editor.focus();
	            dragOperation = null;
	        }
	        clearDragMarker();
	        return event.preventDefault(e);
	    };

	    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
	    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

	    function scrollCursorIntoView(cursor, prevCursor) {
	        var now = Date.now();
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        var hMovement = !prevCursor || cursor.column != prevCursor.column;
	        if (!cursorMovedTime || vMovement || hMovement) {
	            editor.$blockScrolling += 1;
	            editor.moveCursorToPosition(cursor);
	            editor.$blockScrolling -= 1;
	            cursorMovedTime = now;
	            cursorPointOnCaretMoved = {x: x, y: y};
	        } else {
	            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
	            if (distance > SCROLL_CURSOR_HYSTERESIS) {
	                cursorMovedTime = null;
	            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
	                editor.renderer.scrollCursorIntoView();
	                cursorMovedTime = null;
	            }
	        }
	    }

	    function autoScroll(cursor, prevCursor) {
	        var now = Date.now();
	        var lineHeight = editor.renderer.layerConfig.lineHeight;
	        var characterWidth = editor.renderer.layerConfig.characterWidth;
	        var editorRect = editor.renderer.scroller.getBoundingClientRect();
	        var offsets = {
	           x: {
	               left: x - editorRect.left,
	               right: editorRect.right - x
	           },
	           y: {
	               top: y - editorRect.top,
	               bottom: editorRect.bottom - y
	           }
	        };
	        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
	        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
	        var scrollCursor = {row: cursor.row, column: cursor.column};
	        if (nearestXOffset / characterWidth <= 2) {
	            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
	        }
	        if (nearestYOffset / lineHeight <= 1) {
	            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
	        }
	        var vScroll = cursor.row != scrollCursor.row;
	        var hScroll = cursor.column != scrollCursor.column;
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        if (vScroll || (hScroll && !vMovement)) {
	            if (!autoScrollStartTime)
	                autoScrollStartTime = now;
	            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
	                editor.renderer.scrollCursorIntoView(scrollCursor);
	        } else {
	            autoScrollStartTime = null;
	        }
	    }

	    function onDragInterval() {
	        var prevCursor = dragCursor;
	        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
	        scrollCursorIntoView(dragCursor, prevCursor);
	        autoScroll(dragCursor, prevCursor);
	    }

	    function addDragMarker() {
	        range = editor.selection.toOrientedRange();
	        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
	        editor.clearSelection();
	        if (editor.isFocused())
	            editor.renderer.$cursorLayer.setBlinking(false);
	        clearInterval(timerId);
	        onDragInterval();
	        timerId = setInterval(onDragInterval, 20);
	        counter = 0;
	        event.addListener(document, "mousemove", onMouseMove);
	    }

	    function clearDragMarker() {
	        clearInterval(timerId);
	        editor.session.removeMarker(dragSelectionMarker);
	        dragSelectionMarker = null;
	        editor.$blockScrolling += 1;
	        editor.selection.fromOrientedRange(range);
	        editor.$blockScrolling -= 1;
	        if (editor.isFocused() && !isInternal)
	            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
	        range = null;
	        dragCursor = null;
	        counter = 0;
	        autoScrollStartTime = null;
	        cursorMovedTime = null;
	        event.removeListener(document, "mousemove", onMouseMove);
	    }
	    var onMouseMoveTimer = null;
	    function onMouseMove() {
	        if (onMouseMoveTimer == null) {
	            onMouseMoveTimer = setTimeout(function() {
	                if (onMouseMoveTimer != null && dragSelectionMarker)
	                    clearDragMarker();
	            }, 20);
	        }
	    }

	    function canAccept(dataTransfer) {
	        var types = dataTransfer.types;
	        return !types || Array.prototype.some.call(types, function(type) {
	            return type == 'text/plain' || type == 'Text';
	        });
	    }

	    function getDropEffect(e) {
	        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
	        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

	        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
	        var effectAllowed = "uninitialized";
	        try {
	            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
	        } catch (e) {}
	        var dropEffect = "none";

	        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";
	        else if (moveAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "move";
	        else if (copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";

	        return dropEffect;
	    }
	}

	(function() {

	    this.dragWait = function() {
	        var interval = Date.now() - this.mousedownEvent.time;
	        if (interval > this.editor.getDragDelay())
	            this.startDrag();
	    };

	    this.dragWaitEnd = function() {
	        var target = this.editor.container;
	        target.draggable = false;
	        this.startSelect(this.mousedownEvent.getDocumentPosition());
	        this.selectEnd();
	    };

	    this.dragReadyEnd = function(e) {
	        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	        this.dragWaitEnd();
	    };

	    this.startDrag = function(){
	        this.cancelDrag = false;
	        var editor = this.editor;
	        var target = editor.container;
	        target.draggable = true;
	        editor.renderer.$cursorLayer.setBlinking(false);
	        editor.setStyle("ace_dragging");
	        var cursorStyle = useragent.isWin ? "default" : "move";
	        editor.renderer.setCursorStyle(cursorStyle);
	        this.setState("dragReady");
	    };

	    this.onMouseDrag = function(e) {
	        var target = this.editor.container;
	        if (useragent.isIE && this.state == "dragReady") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 3)
	                target.dragDrop();
	        }
	        if (this.state === "dragWait") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 0) {
	                target.draggable = false;
	                this.startSelect(this.mousedownEvent.getDocumentPosition());
	            }
	        }
	    };

	    this.onMouseDown = function(e) {
	        if (!this.$dragEnabled)
	            return;
	        this.mousedownEvent = e;
	        var editor = this.editor;

	        var inSelection = e.inSelection();
	        var button = e.getButton();
	        var clickCount = e.domEvent.detail || 1;
	        if (clickCount === 1 && button === 0 && inSelection) {
	            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
	                return;
	            this.mousedownEvent.time = Date.now();
	            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
	            if ("unselectable" in eventTarget)
	                eventTarget.unselectable = "on";
	            if (editor.getDragDelay()) {
	                if (useragent.isWebKit) {
	                    this.cancelDrag = true;
	                    var mouseTarget = editor.container;
	                    mouseTarget.draggable = true;
	                }
	                this.setState("dragWait");
	            } else {
	                this.startDrag();
	            }
	            this.captureMouse(e, this.onMouseDrag.bind(this));
	            e.defaultPrevented = true;
	        }
	    };

	}).call(DragdropHandler.prototype);


	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	exports.DragdropHandler = DragdropHandler;

	});

	ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("./dom");

	exports.get = function (url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	            callback(xhr.responseText);
	        }
	    };
	    xhr.send(null);
	};

	exports.loadScript = function(path, callback) {
	    var head = dom.getDocumentHead();
	    var s = document.createElement('script');

	    s.src = path;
	    head.appendChild(s);

	    s.onload = s.onreadystatechange = function(_, isAbort) {
	        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
	            s = s.onload = s.onreadystatechange = null;
	            if (!isAbort)
	                callback();
	        }
	    };
	};
	exports.qualifyURL = function(url) {
	    var a = document.createElement('a');
	    a.href = url;
	    return a.href;
	}

	});

	ace.define("ace/lib/event_emitter",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var EventEmitter = {};
	var stopPropagation = function() { this.propagationStopped = true; };
	var preventDefault = function() { this.defaultPrevented = true; };

	EventEmitter._emit =
	EventEmitter._dispatchEvent = function(eventName, e) {
	    this._eventRegistry || (this._eventRegistry = {});
	    this._defaultHandlers || (this._defaultHandlers = {});

	    var listeners = this._eventRegistry[eventName] || [];
	    var defaultHandler = this._defaultHandlers[eventName];
	    if (!listeners.length && !defaultHandler)
	        return;

	    if (typeof e != "object" || !e)
	        e = {};

	    if (!e.type)
	        e.type = eventName;
	    if (!e.stopPropagation)
	        e.stopPropagation = stopPropagation;
	    if (!e.preventDefault)
	        e.preventDefault = preventDefault;

	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++) {
	        listeners[i](e, this);
	        if (e.propagationStopped)
	            break;
	    }
	    
	    if (defaultHandler && !e.defaultPrevented)
	        return defaultHandler(e, this);
	};


	EventEmitter._signal = function(eventName, e) {
	    var listeners = (this._eventRegistry || {})[eventName];
	    if (!listeners)
	        return;
	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++)
	        listeners[i](e, this);
	};

	EventEmitter.once = function(eventName, callback) {
	    var _self = this;
	    callback && this.addEventListener(eventName, function newCallback() {
	        _self.removeEventListener(eventName, newCallback);
	        callback.apply(null, arguments);
	    });
	};


	EventEmitter.setDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        handlers = this._defaultHandlers = {_disabled_: {}};
	    
	    if (handlers[eventName]) {
	        var old = handlers[eventName];
	        var disabled = handlers._disabled_[eventName];
	        if (!disabled)
	            handlers._disabled_[eventName] = disabled = [];
	        disabled.push(old);
	        var i = disabled.indexOf(callback);
	        if (i != -1) 
	            disabled.splice(i, 1);
	    }
	    handlers[eventName] = callback;
	};
	EventEmitter.removeDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        return;
	    var disabled = handlers._disabled_[eventName];
	    
	    if (handlers[eventName] == callback) {
	        var old = handlers[eventName];
	        if (disabled)
	            this.setDefaultHandler(eventName, disabled.pop());
	    } else if (disabled) {
	        var i = disabled.indexOf(callback);
	        if (i != -1)
	            disabled.splice(i, 1);
	    }
	};

	EventEmitter.on =
	EventEmitter.addEventListener = function(eventName, callback, capturing) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        listeners = this._eventRegistry[eventName] = [];

	    if (listeners.indexOf(callback) == -1)
	        listeners[capturing ? "unshift" : "push"](callback);
	    return callback;
	};

	EventEmitter.off =
	EventEmitter.removeListener =
	EventEmitter.removeEventListener = function(eventName, callback) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        return;

	    var index = listeners.indexOf(callback);
	    if (index !== -1)
	        listeners.splice(index, 1);
	};

	EventEmitter.removeAllListeners = function(eventName) {
	    if (this._eventRegistry) this._eventRegistry[eventName] = [];
	};

	exports.EventEmitter = EventEmitter;

	});

	ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"no use strict";

	var oop = acequire("./oop");
	var EventEmitter = acequire("./event_emitter").EventEmitter;

	var optionsProvider = {
	    setOptions: function(optList) {
	        Object.keys(optList).forEach(function(key) {
	            this.setOption(key, optList[key]);
	        }, this);
	    },
	    getOptions: function(optionNames) {
	        var result = {};
	        if (!optionNames) {
	            optionNames = Object.keys(this.$options);
	        } else if (!Array.isArray(optionNames)) {
	            result = optionNames;
	            optionNames = Object.keys(result);
	        }
	        optionNames.forEach(function(key) {
	            result[key] = this.getOption(key);
	        }, this);
	        return result;
	    },
	    setOption: function(name, value) {
	        if (this["$" + name] === value)
	            return;
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

	        if (!opt.handlesSet)
	            this["$" + name] = value;
	        if (opt && opt.set)
	            opt.set.call(this, value);
	    },
	    getOption: function(name) {
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
	        return opt && opt.get ? opt.get.call(this) : this["$" + name];
	    }
	};

	function warn(message) {
	    if (typeof console != "undefined" && console.warn)
	        console.warn.apply(console, arguments);
	}

	function reportError(msg, data) {
	    var e = new Error(msg);
	    e.data = data;
	    if (typeof console == "object" && console.error)
	        console.error(e);
	    setTimeout(function() { throw e; });
	}

	var AppConfig = function() {
	    this.$defaultOptions = {};
	};

	(function() {
	    oop.implement(this, EventEmitter);
	    this.defineOptions = function(obj, path, options) {
	        if (!obj.$options)
	            this.$defaultOptions[path] = obj.$options = {};

	        Object.keys(options).forEach(function(key) {
	            var opt = options[key];
	            if (typeof opt == "string")
	                opt = {forwardTo: opt};

	            opt.name || (opt.name = key);
	            obj.$options[opt.name] = opt;
	            if ("initialValue" in opt)
	                obj["$" + opt.name] = opt.initialValue;
	        });
	        oop.implement(obj, optionsProvider);

	        return this;
	    };

	    this.resetOptions = function(obj) {
	        Object.keys(obj.$options).forEach(function(key) {
	            var opt = obj.$options[key];
	            if ("value" in opt)
	                obj.setOption(key, opt.value);
	        });
	    };

	    this.setDefaultValue = function(path, name, value) {
	        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
	        if (opts[name]) {
	            if (opts.forwardTo)
	                this.setDefaultValue(opts.forwardTo, name, value);
	            else
	                opts[name].value = value;
	        }
	    };

	    this.setDefaultValues = function(path, optionHash) {
	        Object.keys(optionHash).forEach(function(key) {
	            this.setDefaultValue(path, key, optionHash[key]);
	        }, this);
	    };
	    
	    this.warn = warn;
	    this.reportError = reportError;
	    
	}).call(AppConfig.prototype);

	exports.AppConfig = AppConfig;

	});

	ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(acequire, exports, module) {
	"no use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var net = acequire("./lib/net");
	var AppConfig = acequire("./lib/app_config").AppConfig;

	module.exports = exports = new AppConfig();

	var global = (function() {
	    return this || typeof window != "undefined" && window;
	})();

	var options = {
	    packaged: false,
	    workerPath: null,
	    modePath: null,
	    themePath: null,
	    basePath: "",
	    suffix: ".js",
	    $moduleUrls: {}
	};

	exports.get = function(key) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    return options[key];
	};

	exports.set = function(key, value) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    options[key] = value;
	};

	exports.all = function() {
	    return lang.copyObject(options);
	};
	exports.moduleUrl = function(name, component) {
	    if (options.$moduleUrls[name])
	        return options.$moduleUrls[name];

	    var parts = name.split("/");
	    component = component || parts[parts.length - 2] || "";
	    var sep = component == "snippets" ? "/" : "-";
	    var base = parts[parts.length - 1];
	    if (component == "worker" && sep == "-") {
	        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
	        base = base.replace(re, "");
	    }

	    if ((!base || base == component) && parts.length > 1)
	        base = parts[parts.length - 2];
	    var path = options[component + "Path"];
	    if (path == null) {
	        path = options.basePath;
	    } else if (sep == "/") {
	        component = sep = "";
	    }
	    if (path && path.slice(-1) != "/")
	        path += "/";
	    return path + component + sep + base + this.get("suffix");
	};

	exports.setModuleUrl = function(name, subst) {
	    return options.$moduleUrls[name] = subst;
	};

	exports.$loading = {};
	exports.loadModule = function(moduleName, onLoad) {
	    var module, moduleType;
	    if (Array.isArray(moduleName)) {
	        moduleType = moduleName[0];
	        moduleName = moduleName[1];
	    }

	    try {
	        module = acequire(moduleName);
	    } catch (e) {}
	    if (module && !exports.$loading[moduleName])
	        return onLoad && onLoad(module);

	    if (!exports.$loading[moduleName])
	        exports.$loading[moduleName] = [];

	    exports.$loading[moduleName].push(onLoad);

	    if (exports.$loading[moduleName].length > 1)
	        return;

	    var afterLoad = function() {
	        acequire([moduleName], function(module) {
	            exports._emit("load.module", {name: moduleName, module: module});
	            var listeners = exports.$loading[moduleName];
	            exports.$loading[moduleName] = null;
	            listeners.forEach(function(onLoad) {
	                onLoad && onLoad(module);
	            });
	        });
	    };

	    if (!exports.get("packaged"))
	        return afterLoad();
	    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
	};
	init(true);function init(packaged) {

	    if (!global || !global.document)
	        return;
	    
	    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && __webpack_require__(28).packaged);

	    var scriptOptions = {};
	    var scriptUrl = "";
	    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
	    var currentDocument = currentScript && currentScript.ownerDocument || document;
	    
	    var scripts = currentDocument.getElementsByTagName("script");
	    for (var i=0; i<scripts.length; i++) {
	        var script = scripts[i];

	        var src = script.src || script.getAttribute("src");
	        if (!src)
	            continue;

	        var attributes = script.attributes;
	        for (var j=0, l=attributes.length; j < l; j++) {
	            var attr = attributes[j];
	            if (attr.name.indexOf("data-ace-") === 0) {
	                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
	            }
	        }

	        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
	        if (m)
	            scriptUrl = m[1];
	    }

	    if (scriptUrl) {
	        scriptOptions.base = scriptOptions.base || scriptUrl;
	        scriptOptions.packaged = true;
	    }

	    scriptOptions.basePath = scriptOptions.base;
	    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
	    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
	    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
	    delete scriptOptions.base;

	    for (var key in scriptOptions)
	        if (typeof scriptOptions[key] !== "undefined")
	            exports.set(key, scriptOptions[key]);
	}

	exports.init = init;

	function deHyphenate(str) {
	    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
	}

	});

	ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
	var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
	var MouseEvent = acequire("./mouse_event").MouseEvent;
	var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
	var config = acequire("../config");

	var MouseHandler = function(editor) {
	    var _self = this;
	    this.editor = editor;

	    new DefaultHandlers(this);
	    new DefaultGutterHandler(this);
	    new DragdropHandler(this);

	    var focusEditor = function(e) {
	        var windowBlurred = !document.hasFocus || !document.hasFocus()
	            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement())
	        if (windowBlurred)
	            window.focus();
	        editor.focus();
	    };

	    var mouseTarget = editor.renderer.getMouseEventTarget();
	    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
	    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
	    event.addMultiMouseDownListener([
	        mouseTarget,
	        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
	        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
	        editor.textInput && editor.textInput.getElement()
	    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
	    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
	    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

	    var gutterEl = editor.renderer.$gutter;
	    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
	    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
	    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
	    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

	    event.addListener(mouseTarget, "mousedown", focusEditor);
	    event.addListener(gutterEl, "mousedown", focusEditor);
	    if (useragent.isIE && editor.renderer.scrollBarV) {
	        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
	        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
	    }

	    editor.on("mousemove", function(e){
	        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
	            return;

	        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
	        var range = editor.session.selection.getRange();
	        var renderer = editor.renderer;

	        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
	            renderer.setCursorStyle("default");
	        } else {
	            renderer.setCursorStyle("");
	        }
	    });
	};

	(function() {
	    this.onMouseEvent = function(name, e) {
	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseMove = function(name, e) {
	        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
	        if (!listeners || !listeners.length)
	            return;

	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseWheel = function(name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;

	        this.editor._emit(name, mouseEvent);
	    };
	    
	    this.onTouchMove = function (name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;
	        this.editor._emit(name, mouseEvent);
	    };

	    this.setState = function(state) {
	        this.state = state;
	    };

	    this.captureMouse = function(ev, mouseMoveHandler) {
	        this.x = ev.x;
	        this.y = ev.y;

	        this.isMousePressed = true;
	        var renderer = this.editor.renderer;
	        if (renderer.$keepTextAreaAtCursor)
	            renderer.$keepTextAreaAtCursor = null;

	        var self = this;
	        var onMouseMove = function(e) {
	            if (!e) return;
	            if (useragent.isWebKit && !e.which && self.releaseMouse)
	                return self.releaseMouse();

	            self.x = e.clientX;
	            self.y = e.clientY;
	            mouseMoveHandler && mouseMoveHandler(e);
	            self.mouseEvent = new MouseEvent(e, self.editor);
	            self.$mouseMoved = true;
	        };

	        var onCaptureEnd = function(e) {
	            clearInterval(timerId);
	            onCaptureInterval();
	            self[self.state + "End"] && self[self.state + "End"](e);
	            self.state = "";
	            if (renderer.$keepTextAreaAtCursor == null) {
	                renderer.$keepTextAreaAtCursor = true;
	                renderer.$moveTextAreaToCursor();
	            }
	            self.isMousePressed = false;
	            self.$onCaptureMouseMove = self.releaseMouse = null;
	            e && self.onMouseEvent("mouseup", e);
	        };

	        var onCaptureInterval = function() {
	            self[self.state] && self[self.state]();
	            self.$mouseMoved = false;
	        };

	        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
	            return setTimeout(function() {onCaptureEnd(ev);});
	        }

	        self.$onCaptureMouseMove = onMouseMove;
	        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
	        var timerId = setInterval(onCaptureInterval, 20);
	    };
	    this.releaseMouse = null;
	    this.cancelContextMenu = function() {
	        var stop = function(e) {
	            if (e && e.domEvent && e.domEvent.type != "contextmenu")
	                return;
	            this.editor.off("nativecontextmenu", stop);
	            if (e && e.domEvent)
	                event.stopEvent(e.domEvent);
	        }.bind(this);
	        setTimeout(stop, 10);
	        this.editor.on("nativecontextmenu", stop);
	    };
	}).call(MouseHandler.prototype);

	config.defineOptions(MouseHandler.prototype, "mouseHandler", {
	    scrollSpeed: {initialValue: 2},
	    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
	    dragEnabled: {initialValue: true},
	    focusTimout: {initialValue: 0},
	    tooltipFollowsMouse: {initialValue: true}
	});


	exports.MouseHandler = MouseHandler;
	});

	ace.define("ace/mouse/fold_handler",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	function FoldHandler(editor) {

	    editor.on("click", function(e) {
	        var position = e.getDocumentPosition();
	        var session = editor.session;
	        var fold = session.getFoldAt(position.row, position.column, 1);
	        if (fold) {
	            if (e.getAccelKey())
	                session.removeFold(fold);
	            else
	                session.expandFold(fold);

	            e.stop();
	        }
	    });

	    editor.on("gutterclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            if (session.foldWidgets && session.foldWidgets[row])
	                editor.session.onFoldWidgetClick(row, e);
	            if (!editor.isFocused())
	                editor.focus();
	            e.stop();
	        }
	    });

	    editor.on("gutterdblclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            var data = session.getParentFoldRangeData(row, true);
	            var range = data.range || data.firstRange;

	            if (range) {
	                row = range.start.row;
	                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

	                if (fold) {
	                    session.removeFold(fold);
	                } else {
	                    session.addFold("...", range);
	                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
	                }
	            }
	            e.stop();
	        }
	    });
	}

	exports.FoldHandler = FoldHandler;

	});

	ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var keyUtil  = acequire("../lib/keys");
	var event = acequire("../lib/event");

	var KeyBinding = function(editor) {
	    this.$editor = editor;
	    this.$data = {editor: editor};
	    this.$handlers = [];
	    this.setDefaultHandler(editor.commands);
	};

	(function() {
	    this.setDefaultHandler = function(kb) {
	        this.removeKeyboardHandler(this.$defaultHandler);
	        this.$defaultHandler = kb;
	        this.addKeyboardHandler(kb, 0);
	    };

	    this.setKeyboardHandler = function(kb) {
	        var h = this.$handlers;
	        if (h[h.length - 1] == kb)
	            return;

	        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
	            this.removeKeyboardHandler(h[h.length - 1]);

	        this.addKeyboardHandler(kb, 1);
	    };

	    this.addKeyboardHandler = function(kb, pos) {
	        if (!kb)
	            return;
	        if (typeof kb == "function" && !kb.handleKeyboard)
	            kb.handleKeyboard = kb;
	        var i = this.$handlers.indexOf(kb);
	        if (i != -1)
	            this.$handlers.splice(i, 1);

	        if (pos == undefined)
	            this.$handlers.push(kb);
	        else
	            this.$handlers.splice(pos, 0, kb);

	        if (i == -1 && kb.attach)
	            kb.attach(this.$editor);
	    };

	    this.removeKeyboardHandler = function(kb) {
	        var i = this.$handlers.indexOf(kb);
	        if (i == -1)
	            return false;
	        this.$handlers.splice(i, 1);
	        kb.detach && kb.detach(this.$editor);
	        return true;
	    };

	    this.getKeyboardHandler = function() {
	        return this.$handlers[this.$handlers.length - 1];
	    };
	    
	    this.getStatusText = function() {
	        var data = this.$data;
	        var editor = data.editor;
	        return this.$handlers.map(function(h) {
	            return h.getStatusText && h.getStatusText(editor, data) || "";
	        }).filter(Boolean).join(" ");
	    };

	    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
	        var toExecute;
	        var success = false;
	        var commands = this.$editor.commands;

	        for (var i = this.$handlers.length; i--;) {
	            toExecute = this.$handlers[i].handleKeyboard(
	                this.$data, hashId, keyString, keyCode, e
	            );
	            if (!toExecute || !toExecute.command)
	                continue;
	            if (toExecute.command == "null") {
	                success = true;
	            } else {
	                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
	            }
	            if (success && e && hashId != -1 && 
	                toExecute.passEvent != true && toExecute.command.passEvent != true
	            ) {
	                event.stopEvent(e);
	            }
	            if (success)
	                break;
	        }
	        
	        if (!success && hashId == -1) {
	            toExecute = {command: "insertstring"};
	            success = commands.exec("insertstring", this.$editor, keyString);
	        }
	        
	        if (success)
	            this.$editor._signal("keyboardActivity", toExecute);
	        
	        return success;
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        var keyString = keyUtil.keyCodeToString(keyCode);
	        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
	    };

	    this.onTextInput = function(text) {
	        this.$callKeyboardHandlers(-1, text);
	    };

	}).call(KeyBinding.prototype);

	exports.KeyBinding = KeyBinding;
	});

	ace.define("ace/range",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};
	var Range = function(startRow, startColumn, endRow, endColumn) {
	    this.start = {
	        row: startRow,
	        column: startColumn
	    };

	    this.end = {
	        row: endRow,
	        column: endColumn
	    };
	};

	(function() {
	    this.isEqual = function(range) {
	        return this.start.row === range.start.row &&
	            this.end.row === range.end.row &&
	            this.start.column === range.start.column &&
	            this.end.column === range.end.column;
	    };
	    this.toString = function() {
	        return ("Range: [" + this.start.row + "/" + this.start.column +
	            "] -> [" + this.end.row + "/" + this.end.column + "]");
	    };

	    this.contains = function(row, column) {
	        return this.compare(row, column) == 0;
	    };
	    this.compareRange = function(range) {
	        var cmp,
	            end = range.end,
	            start = range.start;

	        cmp = this.compare(end.row, end.column);
	        if (cmp == 1) {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == 1) {
	                return 2;
	            } else if (cmp == 0) {
	                return 1;
	            } else {
	                return 0;
	            }
	        } else if (cmp == -1) {
	            return -2;
	        } else {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == -1) {
	                return -1;
	            } else if (cmp == 1) {
	                return 42;
	            } else {
	                return 0;
	            }
	        }
	    };
	    this.comparePoint = function(p) {
	        return this.compare(p.row, p.column);
	    };
	    this.containsRange = function(range) {
	        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
	    };
	    this.intersects = function(range) {
	        var cmp = this.compareRange(range);
	        return (cmp == -1 || cmp == 0 || cmp == 1);
	    };
	    this.isEnd = function(row, column) {
	        return this.end.row == row && this.end.column == column;
	    };
	    this.isStart = function(row, column) {
	        return this.start.row == row && this.start.column == column;
	    };
	    this.setStart = function(row, column) {
	        if (typeof row == "object") {
	            this.start.column = row.column;
	            this.start.row = row.row;
	        } else {
	            this.start.row = row;
	            this.start.column = column;
	        }
	    };
	    this.setEnd = function(row, column) {
	        if (typeof row == "object") {
	            this.end.column = row.column;
	            this.end.row = row.row;
	        } else {
	            this.end.row = row;
	            this.end.column = column;
	        }
	    };
	    this.inside = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column) || this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideStart = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideEnd = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.compare = function(row, column) {
	        if (!this.isMultiLine()) {
	            if (row === this.start.row) {
	                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
	            }
	        }

	        if (row < this.start.row)
	            return -1;

	        if (row > this.end.row)
	            return 1;

	        if (this.start.row === row)
	            return column >= this.start.column ? 0 : -1;

	        if (this.end.row === row)
	            return column <= this.end.column ? 0 : 1;

	        return 0;
	    };
	    this.compareStart = function(row, column) {
	        if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareEnd = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareInside = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.clipRows = function(firstRow, lastRow) {
	        if (this.end.row > lastRow)
	            var end = {row: lastRow + 1, column: 0};
	        else if (this.end.row < firstRow)
	            var end = {row: firstRow, column: 0};

	        if (this.start.row > lastRow)
	            var start = {row: lastRow + 1, column: 0};
	        else if (this.start.row < firstRow)
	            var start = {row: firstRow, column: 0};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };
	    this.extend = function(row, column) {
	        var cmp = this.compare(row, column);

	        if (cmp == 0)
	            return this;
	        else if (cmp == -1)
	            var start = {row: row, column: column};
	        else
	            var end = {row: row, column: column};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };

	    this.isEmpty = function() {
	        return (this.start.row === this.end.row && this.start.column === this.end.column);
	    };
	    this.isMultiLine = function() {
	        return (this.start.row !== this.end.row);
	    };
	    this.clone = function() {
	        return Range.fromPoints(this.start, this.end);
	    };
	    this.collapseRows = function() {
	        if (this.end.column == 0)
	            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
	        else
	            return new Range(this.start.row, 0, this.end.row, 0)
	    };
	    this.toScreenRange = function(session) {
	        var screenPosStart = session.documentToScreenPosition(this.start);
	        var screenPosEnd = session.documentToScreenPosition(this.end);

	        return new Range(
	            screenPosStart.row, screenPosStart.column,
	            screenPosEnd.row, screenPosEnd.column
	        );
	    };
	    this.moveBy = function(row, column) {
	        this.start.row += row;
	        this.start.column += column;
	        this.end.row += row;
	        this.end.column += column;
	    };

	}).call(Range.prototype);
	Range.fromPoints = function(start, end) {
	    return new Range(start.row, start.column, end.row, end.column);
	};
	Range.comparePoints = comparePoints;

	Range.comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};


	exports.Range = Range;
	});

	ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Selection = function(session) {
	    this.session = session;
	    this.doc = session.getDocument();

	    this.clearSelection();
	    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
	    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

	    var self = this;
	    this.lead.on("change", function(e) {
	        self._emit("changeCursor");
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
	            self.$desiredColumn = null;
	    });

	    this.selectionAnchor.on("change", function() {
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	    });
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.isEmpty = function() {
	        return (this.$isEmpty || (
	            this.anchor.row == this.lead.row &&
	            this.anchor.column == this.lead.column
	        ));
	    };
	    this.isMultiLine = function() {
	        if (this.isEmpty()) {
	            return false;
	        }

	        return this.getRange().isMultiLine();
	    };
	    this.getCursor = function() {
	        return this.lead.getPosition();
	    };
	    this.setSelectionAnchor = function(row, column) {
	        this.anchor.setPosition(row, column);

	        if (this.$isEmpty) {
	            this.$isEmpty = false;
	            this._emit("changeSelection");
	        }
	    };
	    this.getSelectionAnchor = function() {
	        if (this.$isEmpty)
	            return this.getSelectionLead();
	        else
	            return this.anchor.getPosition();
	    };
	    this.getSelectionLead = function() {
	        return this.lead.getPosition();
	    };
	    this.shiftSelection = function(columns) {
	        if (this.$isEmpty) {
	            this.moveCursorTo(this.lead.row, this.lead.column + columns);
	            return;
	        }

	        var anchor = this.getSelectionAnchor();
	        var lead = this.getSelectionLead();

	        var isBackwards = this.isBackwards();

	        if (!isBackwards || anchor.column !== 0)
	            this.setSelectionAnchor(anchor.row, anchor.column + columns);

	        if (isBackwards || lead.column !== 0) {
	            this.$moveSelection(function() {
	                this.moveCursorTo(lead.row, lead.column + columns);
	            });
	        }
	    };
	    this.isBackwards = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;
	        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
	    };
	    this.getRange = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;

	        if (this.isEmpty())
	            return Range.fromPoints(lead, lead);

	        if (this.isBackwards()) {
	            return Range.fromPoints(lead, anchor);
	        }
	        else {
	            return Range.fromPoints(anchor, lead);
	        }
	    };
	    this.clearSelection = function() {
	        if (!this.$isEmpty) {
	            this.$isEmpty = true;
	            this._emit("changeSelection");
	        }
	    };
	    this.selectAll = function() {
	        var lastRow = this.doc.getLength() - 1;
	        this.setSelectionAnchor(0, 0);
	        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
	    };
	    this.setRange =
	    this.setSelectionRange = function(range, reverse) {
	        if (reverse) {
	            this.setSelectionAnchor(range.end.row, range.end.column);
	            this.selectTo(range.start.row, range.start.column);
	        } else {
	            this.setSelectionAnchor(range.start.row, range.start.column);
	            this.selectTo(range.end.row, range.end.column);
	        }
	        if (this.getRange().isEmpty())
	            this.$isEmpty = true;
	        this.$desiredColumn = null;
	    };

	    this.$moveSelection = function(mover) {
	        var lead = this.lead;
	        if (this.$isEmpty)
	            this.setSelectionAnchor(lead.row, lead.column);

	        mover.call(this);
	    };
	    this.selectTo = function(row, column) {
	        this.$moveSelection(function() {
	            this.moveCursorTo(row, column);
	        });
	    };
	    this.selectToPosition = function(pos) {
	        this.$moveSelection(function() {
	            this.moveCursorToPosition(pos);
	        });
	    };
	    this.moveTo = function(row, column) {
	        this.clearSelection();
	        this.moveCursorTo(row, column);
	    };
	    this.moveToPosition = function(pos) {
	        this.clearSelection();
	        this.moveCursorToPosition(pos);
	    };
	    this.selectUp = function() {
	        this.$moveSelection(this.moveCursorUp);
	    };
	    this.selectDown = function() {
	        this.$moveSelection(this.moveCursorDown);
	    };
	    this.selectRight = function() {
	        this.$moveSelection(this.moveCursorRight);
	    };
	    this.selectLeft = function() {
	        this.$moveSelection(this.moveCursorLeft);
	    };
	    this.selectLineStart = function() {
	        this.$moveSelection(this.moveCursorLineStart);
	    };
	    this.selectLineEnd = function() {
	        this.$moveSelection(this.moveCursorLineEnd);
	    };
	    this.selectFileEnd = function() {
	        this.$moveSelection(this.moveCursorFileEnd);
	    };
	    this.selectFileStart = function() {
	        this.$moveSelection(this.moveCursorFileStart);
	    };
	    this.selectWordRight = function() {
	        this.$moveSelection(this.moveCursorWordRight);
	    };
	    this.selectWordLeft = function() {
	        this.$moveSelection(this.moveCursorWordLeft);
	    };
	    this.getWordRange = function(row, column) {
	        if (typeof column == "undefined") {
	            var cursor = row || this.lead;
	            row = cursor.row;
	            column = cursor.column;
	        }
	        return this.session.getWordRange(row, column);
	    };
	    this.selectWord = function() {
	        this.setSelectionRange(this.getWordRange());
	    };
	    this.selectAWord = function() {
	        var cursor = this.getCursor();
	        var range = this.session.getAWordRange(cursor.row, cursor.column);
	        this.setSelectionRange(range);
	    };

	    this.getLineRange = function(row, excludeLastChar) {
	        var rowStart = typeof row == "number" ? row : this.lead.row;
	        var rowEnd;

	        var foldLine = this.session.getFoldLine(rowStart);
	        if (foldLine) {
	            rowStart = foldLine.start.row;
	            rowEnd = foldLine.end.row;
	        } else {
	            rowEnd = rowStart;
	        }
	        if (excludeLastChar === true)
	            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
	        else
	            return new Range(rowStart, 0, rowEnd + 1, 0);
	    };
	    this.selectLine = function() {
	        this.setSelectionRange(this.getLineRange());
	    };
	    this.moveCursorUp = function() {
	        this.moveCursorBy(-1, 0);
	    };
	    this.moveCursorDown = function() {
	        this.moveCursorBy(1, 0);
	    };
	    this.moveCursorLeft = function() {
	        var cursor = this.lead.getPosition(),
	            fold;

	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	        } else if (cursor.column === 0) {
	            if (cursor.row > 0) {
	                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, -tabSize);
	            else
	                this.moveCursorBy(0, -1);
	        }
	    };
	    this.moveCursorRight = function() {
	        var cursor = this.lead.getPosition(),
	            fold;
	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	        }
	        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
	            if (this.lead.row < this.doc.getLength() - 1) {
	                this.moveCursorTo(this.lead.row + 1, 0);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            var cursor = this.lead;
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, tabSize);
	            else
	                this.moveCursorBy(0, 1);
	        }
	    };
	    this.moveCursorLineStart = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var screenRow = this.session.documentToScreenRow(row, column);
	        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
	        var beforeCursor = this.session.getDisplayLine(
	            row, null, firstColumnPosition.row,
	            firstColumnPosition.column
	        );

	        var leadingSpace = beforeCursor.match(/^\s*/);
	        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
	            firstColumnPosition.column += leadingSpace[0].length;
	        this.moveCursorToPosition(firstColumnPosition);
	    };
	    this.moveCursorLineEnd = function() {
	        var lead = this.lead;
	        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
	        if (this.lead.column == lineEnd.column) {
	            var line = this.session.getLine(lineEnd.row);
	            if (lineEnd.column == line.length) {
	                var textEnd = line.search(/\s+$/);
	                if (textEnd > 0)
	                    lineEnd.column = textEnd;
	            }
	        }

	        this.moveCursorTo(lineEnd.row, lineEnd.column);
	    };
	    this.moveCursorFileEnd = function() {
	        var row = this.doc.getLength() - 1;
	        var column = this.doc.getLine(row).length;
	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorFileStart = function() {
	        this.moveCursorTo(0, 0);
	    };
	    this.moveCursorLongWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	            return;
	        }
	        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
	            column += this.session.nonTokenRe.lastIndex;
	            this.session.nonTokenRe.lastIndex = 0;
	            rightOfCursor = line.substring(column);
	        }
	        if (column >= line.length) {
	            this.moveCursorTo(row, line.length);
	            this.moveCursorRight();
	            if (row < this.doc.getLength() - 1)
	                this.moveCursorWordRight();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            column += this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorLongWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	            return;
	        }

	        var str = this.session.getFoldStringAt(row, column, -1);
	        if (str == null) {
	            str = this.doc.getLine(row).substring(0, column);
	        }

	        var leftOfCursor = lang.stringReverse(str);
	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
	            column -= this.session.nonTokenRe.lastIndex;
	            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
	            this.session.nonTokenRe.lastIndex = 0;
	        }
	        if (column <= 0) {
	            this.moveCursorTo(row, 0);
	            this.moveCursorLeft();
	            if (row > 0)
	                this.moveCursorWordLeft();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(leftOfCursor)) {
	            column -= this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };

	    this.$shortWordEndIndex = function(rightOfCursor) {
	        var match, index = 0, ch;
	        var whitespaceRe = /\s/;
	        var tokenRe = this.session.tokenRe;

	        tokenRe.lastIndex = 0;
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            index = this.session.tokenRe.lastIndex;
	        } else {
	            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                index ++;

	            if (index < 1) {
	                tokenRe.lastIndex = 0;
	                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
	                    tokenRe.lastIndex = 0;
	                    index ++;
	                    if (whitespaceRe.test(ch)) {
	                        if (index > 2) {
	                            index--;
	                            break;
	                        } else {
	                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                                index ++;
	                            if (index > 2)
	                                break;
	                        }
	                    }
	                }
	            }
	        }
	        tokenRe.lastIndex = 0;

	        return index;
	    };

	    this.moveCursorShortWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold)
	            return this.moveCursorTo(fold.end.row, fold.end.column);

	        if (column == line.length) {
	            var l = this.doc.getLength();
	            do {
	                row++;
	                rightOfCursor = this.doc.getLine(row);
	            } while (row < l && /^\s*$/.test(rightOfCursor));

	            if (!/^\s+/.test(rightOfCursor))
	                rightOfCursor = "";
	            column = 0;
	        }

	        var index = this.$shortWordEndIndex(rightOfCursor);

	        this.moveCursorTo(row, column + index);
	    };

	    this.moveCursorShortWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;

	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1))
	            return this.moveCursorTo(fold.start.row, fold.start.column);

	        var line = this.session.getLine(row).substring(0, column);
	        if (column === 0) {
	            do {
	                row--;
	                line = this.doc.getLine(row);
	            } while (row > 0 && /^\s*$/.test(line));

	            column = line.length;
	            if (!/\s+$/.test(line))
	                line = "";
	        }

	        var leftOfCursor = lang.stringReverse(line);
	        var index = this.$shortWordEndIndex(leftOfCursor);

	        return this.moveCursorTo(row, column - index);
	    };

	    this.moveCursorWordRight = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordRight();
	        else
	            this.moveCursorShortWordRight();
	    };

	    this.moveCursorWordLeft = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordLeft();
	        else
	            this.moveCursorShortWordLeft();
	    };
	    this.moveCursorBy = function(rows, chars) {
	        var screenPos = this.session.documentToScreenPosition(
	            this.lead.row,
	            this.lead.column
	        );

	        if (chars === 0) {
	            if (this.$desiredColumn)
	                screenPos.column = this.$desiredColumn;
	            else
	                this.$desiredColumn = screenPos.column;
	        }

	        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
	        
	        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
	            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
	                if (docPos.row > 0 || rows > 0)
	                    docPos.row++;
	            }
	        }
	        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
	    };
	    this.moveCursorToPosition = function(position) {
	        this.moveCursorTo(position.row, position.column);
	    };
	    this.moveCursorTo = function(row, column, keepDesiredColumn) {
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            row = fold.start.row;
	            column = fold.start.column;
	        }

	        this.$keepDesiredColumnOnChange = true;
	        this.lead.setPosition(row, column);
	        this.$keepDesiredColumnOnChange = false;

	        if (!keepDesiredColumn)
	            this.$desiredColumn = null;
	    };
	    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
	        var pos = this.session.screenToDocumentPosition(row, column);
	        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
	    };
	    this.detach = function() {
	        this.lead.detach();
	        this.anchor.detach();
	        this.session = this.doc = null;
	    };

	    this.fromOrientedRange = function(range) {
	        this.setSelectionRange(range, range.cursor == range.start);
	        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
	    };

	    this.toOrientedRange = function(range) {
	        var r = this.getRange();
	        if (range) {
	            range.start.column = r.start.column;
	            range.start.row = r.start.row;
	            range.end.column = r.end.column;
	            range.end.row = r.end.row;
	        } else {
	            range = r;
	        }

	        range.cursor = this.isBackwards() ? range.start : range.end;
	        range.desiredColumn = this.$desiredColumn;
	        return range;
	    };
	    this.getRangeOfMovements = function(func) {
	        var start = this.getCursor();
	        try {
	            func(this);
	            var end = this.getCursor();
	            return Range.fromPoints(start,end);
	        } catch(e) {
	            return Range.fromPoints(start,start);
	        } finally {
	            this.moveCursorToPosition(start);
	        }
	    };

	    this.toJSON = function() {
	        if (this.rangeCount) {
	            var data = this.ranges.map(function(r) {
	                var r1 = r.clone();
	                r1.isBackwards = r.cursor == r.start;
	                return r1;
	            });
	        } else {
	            var data = this.getRange();
	            data.isBackwards = this.isBackwards();
	        }
	        return data;
	    };

	    this.fromJSON = function(data) {
	        if (data.start == undefined) {
	            if (this.rangeList) {
	                this.toSingleRange(data[0]);
	                for (var i = data.length; i--; ) {
	                    var r = Range.fromPoints(data[i].start, data[i].end);
	                    if (data[i].isBackwards)
	                        r.cursor = r.start;
	                    this.addRange(r, true);
	                }
	                return;
	            } else
	                data = data[0];
	        }
	        if (this.rangeList)
	            this.toSingleRange(data);
	        this.setSelectionRange(data, data.isBackwards);
	    };

	    this.isEqual = function(data) {
	        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
	            return false;
	        if (!data.length || !this.ranges)
	            return this.getRange().isEqual(data);

	        for (var i = this.ranges.length; i--; ) {
	            if (!this.ranges[i].isEqual(data[i]))
	                return false;
	        }
	        return true;
	    };

	}).call(Selection.prototype);

	exports.Selection = Selection;
	});

	ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(acequire, exports, module) {
	"use strict";

	var config = acequire("./config");
	var MAX_TOKEN_COUNT = 2000;
	var Tokenizer = function(rules) {
	    this.states = rules;

	    this.regExps = {};
	    this.matchMappings = {};
	    for (var key in this.states) {
	        var state = this.states[key];
	        var ruleRegExps = [];
	        var matchTotal = 0;
	        var mapping = this.matchMappings[key] = {defaultToken: "text"};
	        var flag = "g";

	        var splitterRurles = [];
	        for (var i = 0; i < state.length; i++) {
	            var rule = state[i];
	            if (rule.defaultToken)
	                mapping.defaultToken = rule.defaultToken;
	            if (rule.caseInsensitive)
	                flag = "gi";
	            if (rule.regex == null)
	                continue;

	            if (rule.regex instanceof RegExp)
	                rule.regex = rule.regex.toString().slice(1, -1);
	            var adjustedregex = rule.regex;
	            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
	            if (Array.isArray(rule.token)) {
	                if (rule.token.length == 1 || matchcount == 1) {
	                    rule.token = rule.token[0];
	                } else if (matchcount - 1 != rule.token.length) {
	                    this.reportError("number of classes and regexp groups doesn't match", { 
	                        rule: rule,
	                        groupCount: matchcount - 1
	                    });
	                    rule.token = rule.token[0];
	                } else {
	                    rule.tokenArray = rule.token;
	                    rule.token = null;
	                    rule.onMatch = this.$arrayTokens;
	                }
	            } else if (typeof rule.token == "function" && !rule.onMatch) {
	                if (matchcount > 1)
	                    rule.onMatch = this.$applyToken;
	                else
	                    rule.onMatch = rule.token;
	            }

	            if (matchcount > 1) {
	                if (/\\\d/.test(rule.regex)) {
	                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
	                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
	                    });
	                } else {
	                    matchcount = 1;
	                    adjustedregex = this.removeCapturingGroups(rule.regex);
	                }
	                if (!rule.splitRegex && typeof rule.token != "string")
	                    splitterRurles.push(rule); // flag will be known only at the very end
	            }

	            mapping[matchTotal] = i;
	            matchTotal += matchcount;

	            ruleRegExps.push(adjustedregex);
	            if (!rule.onMatch)
	                rule.onMatch = null;
	        }
	        
	        if (!ruleRegExps.length) {
	            mapping[0] = 0;
	            ruleRegExps.push("$");
	        }
	        
	        splitterRurles.forEach(function(rule) {
	            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
	        }, this);

	        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
	    }
	};

	(function() {
	    this.$setMaxTokenCount = function(m) {
	        MAX_TOKEN_COUNT = m | 0;
	    };
	    
	    this.$applyToken = function(str) {
	        var values = this.splitRegex.exec(str).slice(1);
	        var types = this.token.apply(this, values);
	        if (typeof types === "string")
	            return [{type: types, value: str}];

	        var tokens = [];
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i]
	                };
	        }
	        return tokens;
	    };

	    this.$arrayTokens = function(str) {
	        if (!str)
	            return [];
	        var values = this.splitRegex.exec(str);
	        if (!values)
	            return "text";
	        var tokens = [];
	        var types = this.tokenArray;
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i + 1])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i + 1]
	                };
	        }
	        return tokens;
	    };

	    this.removeCapturingGroups = function(src) {
	        var r = src.replace(
	            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
	            function(x, y) {return y ? "(?:" : x;}
	        );
	        return r;
	    };

	    this.createSplitterRegexp = function(src, flag) {
	        if (src.indexOf("(?=") != -1) {
	            var stack = 0;
	            var inChClass = false;
	            var lastCapture = {};
	            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
	                m, esc, parenOpen, parenClose, square, index
	            ) {
	                if (inChClass) {
	                    inChClass = square != "]";
	                } else if (square) {
	                    inChClass = true;
	                } else if (parenClose) {
	                    if (stack == lastCapture.stack) {
	                        lastCapture.end = index+1;
	                        lastCapture.stack = -1;
	                    }
	                    stack--;
	                } else if (parenOpen) {
	                    stack++;
	                    if (parenOpen.length != 1) {
	                        lastCapture.stack = stack
	                        lastCapture.start = index;
	                    }
	                }
	                return m;
	            });

	            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
	                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
	        }
	        if (src.charAt(0) != "^") src = "^" + src;
	        if (src.charAt(src.length - 1) != "$") src += "$";
	        
	        return new RegExp(src, (flag||"").replace("g", ""));
	    };
	    this.getLineTokens = function(line, startState) {
	        if (startState && typeof startState != "string") {
	            var stack = startState.slice(0);
	            startState = stack[0];
	            if (startState === "#tmp") {
	                stack.shift()
	                startState = stack.shift()
	            }
	        } else
	            var stack = [];

	        var currentState = startState || "start";
	        var state = this.states[currentState];
	        if (!state) {
	            currentState = "start";
	            state = this.states[currentState];
	        }
	        var mapping = this.matchMappings[currentState];
	        var re = this.regExps[currentState];
	        re.lastIndex = 0;

	        var match, tokens = [];
	        var lastIndex = 0;
	        var matchAttempts = 0;

	        var token = {type: null, value: ""};

	        while (match = re.exec(line)) {
	            var type = mapping.defaultToken;
	            var rule = null;
	            var value = match[0];
	            var index = re.lastIndex;

	            if (index - value.length > lastIndex) {
	                var skipped = line.substring(lastIndex, index - value.length);
	                if (token.type == type) {
	                    token.value += skipped;
	                } else {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: type, value: skipped};
	                }
	            }

	            for (var i = 0; i < match.length-2; i++) {
	                if (match[i + 1] === undefined)
	                    continue;

	                rule = state[mapping[i]];

	                if (rule.onMatch)
	                    type = rule.onMatch(value, currentState, stack);
	                else
	                    type = rule.token;

	                if (rule.next) {
	                    if (typeof rule.next == "string") {
	                        currentState = rule.next;
	                    } else {
	                        currentState = rule.next(currentState, stack);
	                    }
	                    
	                    state = this.states[currentState];
	                    if (!state) {
	                        this.reportError("state doesn't exist", currentState);
	                        currentState = "start";
	                        state = this.states[currentState];
	                    }
	                    mapping = this.matchMappings[currentState];
	                    lastIndex = index;
	                    re = this.regExps[currentState];
	                    re.lastIndex = index;
	                }
	                break;
	            }

	            if (value) {
	                if (typeof type === "string") {
	                    if ((!rule || rule.merge !== false) && token.type === type) {
	                        token.value += value;
	                    } else {
	                        if (token.type)
	                            tokens.push(token);
	                        token = {type: type, value: value};
	                    }
	                } else if (type) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: null, value: ""};
	                    for (var i = 0; i < type.length; i++)
	                        tokens.push(type[i]);
	                }
	            }

	            if (lastIndex == line.length)
	                break;

	            lastIndex = index;

	            if (matchAttempts++ > MAX_TOKEN_COUNT) {
	                if (matchAttempts > 2 * line.length) {
	                    this.reportError("infinite loop with in ace tokenizer", {
	                        startState: startState,
	                        line: line
	                    });
	                }
	                while (lastIndex < line.length) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {
	                        value: line.substring(lastIndex, lastIndex += 2000),
	                        type: "overflow"
	                    };
	                }
	                currentState = "start";
	                stack = [];
	                break;
	            }
	        }

	        if (token.type)
	            tokens.push(token);
	        
	        if (stack.length > 1) {
	            if (stack[0] !== currentState)
	                stack.unshift("#tmp", currentState);
	        }
	        return {
	            tokens : tokens,
	            state : stack.length ? stack : currentState
	        };
	    };
	    
	    this.reportError = config.reportError;
	    
	}).call(Tokenizer.prototype);

	exports.Tokenizer = Tokenizer;
	});

	ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");

	var TextHighlightRules = function() {

	    this.$rules = {
	        "start" : [{
	            token : "empty_line",
	            regex : '^$'
	        }, {
	            defaultToken : "text"
	        }]
	    };
	};

	(function() {

	    this.addRules = function(rules, prefix) {
	        if (!prefix) {
	            for (var key in rules)
	                this.$rules[key] = rules[key];
	            return;
	        }
	        for (var key in rules) {
	            var state = rules[key];
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (rule.next || rule.onMatch) {
	                    if (typeof rule.next == "string") {
	                        if (rule.next.indexOf(prefix) !== 0)
	                            rule.next = prefix + rule.next;
	                    }
	                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
	                        rule.nextState = prefix + rule.nextState;
	                }
	            }
	            this.$rules[prefix + key] = state;
	        }
	    };

	    this.getRules = function() {
	        return this.$rules;
	    };

	    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
	        var embedRules = typeof HighlightRules == "function"
	            ? new HighlightRules().getRules()
	            : HighlightRules;
	        if (states) {
	            for (var i = 0; i < states.length; i++)
	                states[i] = prefix + states[i];
	        } else {
	            states = [];
	            for (var key in embedRules)
	                states.push(prefix + key);
	        }

	        this.addRules(embedRules, prefix);

	        if (escapeRules) {
	            var addRules = Array.prototype[append ? "push" : "unshift"];
	            for (var i = 0; i < states.length; i++)
	                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
	        }

	        if (!this.$embeds)
	            this.$embeds = [];
	        this.$embeds.push(prefix);
	    };

	    this.getEmbeds = function() {
	        return this.$embeds;
	    };

	    var pushState = function(currentState, stack) {
	        if (currentState != "start" || stack.length)
	            stack.unshift(this.nextState, currentState);
	        return this.nextState;
	    };
	    var popState = function(currentState, stack) {
	        stack.shift();
	        return stack.shift() || "start";
	    };

	    this.normalizeRules = function() {
	        var id = 0;
	        var rules = this.$rules;
	        function processState(key) {
	            var state = rules[key];
	            state.processed = true;
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (!rule.regex && rule.start) {
	                    rule.regex = rule.start;
	                    if (!rule.next)
	                        rule.next = [];
	                    rule.next.push({
	                        defaultToken: rule.token
	                    }, {
	                        token: rule.token + ".end",
	                        regex: rule.end || rule.start,
	                        next: "pop"
	                    });
	                    rule.token = rule.token + ".start";
	                    rule.push = true;
	                }
	                var next = rule.next || rule.push;
	                if (next && Array.isArray(next)) {
	                    var stateName = rule.stateName;
	                    if (!stateName)  {
	                        stateName = rule.token;
	                        if (typeof stateName != "string")
	                            stateName = stateName[0] || "";
	                        if (rules[stateName])
	                            stateName += id++;
	                    }
	                    rules[stateName] = next;
	                    rule.next = stateName;
	                    processState(stateName);
	                } else if (next == "pop") {
	                    rule.next = popState;
	                }

	                if (rule.push) {
	                    rule.nextState = rule.next || rule.push;
	                    rule.next = pushState;
	                    delete rule.push;
	                }

	                if (rule.rules) {
	                    for (var r in rule.rules) {
	                        if (rules[r]) {
	                            if (rules[r].push)
	                                rules[r].push.apply(rules[r], rule.rules[r]);
	                        } else {
	                            rules[r] = rule.rules[r];
	                        }
	                    }
	                }
	                if (rule.include || typeof rule == "string") {
	                    var includeName = rule.include || rule;
	                    var toInsert = rules[includeName];
	                } else if (Array.isArray(rule))
	                    toInsert = rule;

	                if (toInsert) {
	                    var args = [i, 1].concat(toInsert);
	                    if (rule.noEscape)
	                        args = args.filter(function(x) {return !x.next;});
	                    state.splice.apply(state, args);
	                    i--;
	                    toInsert = null;
	                }
	                
	                if (rule.keywordMap) {
	                    rule.token = this.createKeywordMapper(
	                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
	                    );
	                    delete rule.defaultToken;
	                }
	            }
	        }
	        Object.keys(rules).forEach(processState, this);
	    };

	    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
	        var keywords = Object.create(null);
	        Object.keys(map).forEach(function(className) {
	            var a = map[className];
	            if (ignoreCase)
	                a = a.toLowerCase();
	            var list = a.split(splitChar || "|");
	            for (var i = list.length; i--; )
	                keywords[list[i]] = className;
	        });
	        if (Object.getPrototypeOf(keywords)) {
	            keywords.__proto__ = null;
	        }
	        this.$keywordList = Object.keys(keywords);
	        map = null;
	        return ignoreCase
	            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
	            : function(value) {return keywords[value] || defaultToken };
	    };

	    this.getKeywords = function() {
	        return this.$keywords;
	    };

	}).call(TextHighlightRules.prototype);

	exports.TextHighlightRules = TextHighlightRules;
	});

	ace.define("ace/mode/behaviour",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var Behaviour = function() {
	   this.$behaviours = {};
	};

	(function () {

	    this.add = function (name, action, callback) {
	        switch (undefined) {
	          case this.$behaviours:
	              this.$behaviours = {};
	          case this.$behaviours[name]:
	              this.$behaviours[name] = {};
	        }
	        this.$behaviours[name][action] = callback;
	    }
	    
	    this.addBehaviours = function (behaviours) {
	        for (var key in behaviours) {
	            for (var action in behaviours[key]) {
	                this.add(key, action, behaviours[key][action]);
	            }
	        }
	    }
	    
	    this.remove = function (name) {
	        if (this.$behaviours && this.$behaviours[name]) {
	            delete this.$behaviours[name];
	        }
	    }
	    
	    this.inherit = function (mode, filter) {
	        if (typeof mode === "function") {
	            var behaviours = new mode().getBehaviours(filter);
	        } else {
	            var behaviours = mode.getBehaviours(filter);
	        }
	        this.addBehaviours(behaviours);
	    }
	    
	    this.getBehaviours = function (filter) {
	        if (!filter) {
	            return this.$behaviours;
	        } else {
	            var ret = {}
	            for (var i = 0; i < filter.length; i++) {
	                if (this.$behaviours[filter[i]]) {
	                    ret[filter[i]] = this.$behaviours[filter[i]];
	                }
	            }
	            return ret;
	        }
	    }

	}).call(Behaviour.prototype);

	exports.Behaviour = Behaviour;
	});

	ace.define("ace/unicode",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.packages = {};

	addUnicodePackage({
	    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
	    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
	    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
	    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
	    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
	    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
	    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
	    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
	    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
	    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
	    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
	    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
	    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
	    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
	    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
	    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
	    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
	    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
	    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
	    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
	    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
	    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
	    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
	    Z:  "002000A01680180E2000-200A20282029202F205F3000",
	    Zs: "002000A01680180E2000-200A202F205F3000",
	    Zl: "2028",
	    Zp: "2029",
	    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
	    Cc: "0000-001F007F-009F",
	    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
	    Co: "E000-F8FF",
	    Cs: "D800-DFFF",
	    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
	});

	function addUnicodePackage (pack) {
	    var codePoint = /\w{4}/g;
	    for (var name in pack)
	        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
	}

	});

	ace.define("ace/token_iterator",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var TokenIterator = function(session, initialRow, initialColumn) {
	    this.$session = session;
	    this.$row = initialRow;
	    this.$rowTokens = session.getTokens(initialRow);

	    var token = session.getTokenAt(initialRow, initialColumn);
	    this.$tokenIndex = token ? token.index : -1;
	};

	(function() { 
	    this.stepBackward = function() {
	        this.$tokenIndex -= 1;
	        
	        while (this.$tokenIndex < 0) {
	            this.$row -= 1;
	            if (this.$row < 0) {
	                this.$row = 0;
	                return null;
	            }
	                
	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = this.$rowTokens.length - 1;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };   
	    this.stepForward = function() {
	        this.$tokenIndex += 1;
	        var rowCount;
	        while (this.$tokenIndex >= this.$rowTokens.length) {
	            this.$row += 1;
	            if (!rowCount)
	                rowCount = this.$session.getLength();
	            if (this.$row >= rowCount) {
	                this.$row = rowCount - 1;
	                return null;
	            }

	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = 0;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentToken = function () {
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentTokenRow = function () {
	        return this.$row;
	    };     
	    this.getCurrentTokenColumn = function() {
	        var rowTokens = this.$rowTokens;
	        var tokenIndex = this.$tokenIndex;
	        var column = rowTokens[tokenIndex].start;
	        if (column !== undefined)
	            return column;
	            
	        column = 0;
	        while (tokenIndex > 0) {
	            tokenIndex -= 1;
	            column += rowTokens[tokenIndex].value.length;
	        }
	        
	        return column;  
	    };
	    this.getCurrentTokenPosition = function() {
	        return {row: this.$row, column: this.getCurrentTokenColumn()};
	    };
	            
	}).call(TokenIterator.prototype);

	exports.TokenIterator = TokenIterator;
	});

	ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Tokenizer = acequire("../tokenizer").Tokenizer;
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var Behaviour = acequire("./behaviour").Behaviour;
	var unicode = acequire("../unicode");
	var lang = acequire("../lib/lang");
	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;

	var Mode = function() {
	    this.HighlightRules = TextHighlightRules;
	    this.$behaviour = new Behaviour();
	};

	(function() {

	    this.tokenRe = new RegExp("^["
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]+", "g"
	    );

	    this.nonTokenRe = new RegExp("^(?:[^"
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
	    );

	    this.getTokenizer = function() {
	        if (!this.$tokenizer) {
	            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
	            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
	        }
	        return this.$tokenizer;
	    };

	    this.lineCommentStart = "";
	    this.blockComment = "";

	    this.toggleCommentLines = function(state, session, startRow, endRow) {
	        var doc = session.doc;

	        var ignoreBlankLines = true;
	        var shouldRemove = true;
	        var minIndent = Infinity;
	        var tabSize = session.getTabSize();
	        var insertAtTabStop = false;

	        if (!this.lineCommentStart) {
	            if (!this.blockComment)
	                return false;
	            var lineCommentStart = this.blockComment.start;
	            var lineCommentEnd = this.blockComment.end;
	            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
	            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

	            var comment = function(line, i) {
	                if (testRemove(line, i))
	                    return;
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
	                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };

	            var uncomment = function(line, i) {
	                var m;
	                if (m = line.match(regexpEnd))
	                    doc.removeInLine(i, line.length - m[0].length, line.length);
	                if (m = line.match(regexpStart))
	                    doc.removeInLine(i, m[1].length, m[0].length);
	            };

	            var testRemove = function(line, row) {
	                if (regexpStart.test(line))
	                    return true;
	                var tokens = session.getTokens(row);
	                for (var i = 0; i < tokens.length; i++) {
	                    if (tokens[i].type === "comment")
	                        return true;
	                }
	            };
	        } else {
	            if (Array.isArray(this.lineCommentStart)) {
	                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
	                var lineCommentStart = this.lineCommentStart[0];
	            } else {
	                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
	                var lineCommentStart = this.lineCommentStart;
	            }
	            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
	            
	            insertAtTabStop = session.getUseSoftTabs();

	            var uncomment = function(line, i) {
	                var m = line.match(regexpStart);
	                if (!m) return;
	                var start = m[1].length, end = m[0].length;
	                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
	                    end--;
	                doc.removeInLine(i, start, end);
	            };
	            var commentWithSpace = lineCommentStart + " ";
	            var comment = function(line, i) {
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    if (shouldInsertSpace(line, minIndent, minIndent))
	                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
	                    else
	                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };
	            var testRemove = function(line, i) {
	                return regexpStart.test(line);
	            };
	            
	            var shouldInsertSpace = function(line, before, after) {
	                var spaces = 0;
	                while (before-- && line.charAt(before) == " ")
	                    spaces++;
	                if (spaces % tabSize != 0)
	                    return false;
	                var spaces = 0;
	                while (line.charAt(after++) == " ")
	                    spaces++;
	                if (tabSize > 2)
	                    return spaces % tabSize != tabSize - 1;
	                else
	                    return spaces % tabSize == 0;
	                return true;
	            };
	        }

	        function iter(fun) {
	            for (var i = startRow; i <= endRow; i++)
	                fun(doc.getLine(i), i);
	        }


	        var minEmptyLength = Infinity;
	        iter(function(line, i) {
	            var indent = line.search(/\S/);
	            if (indent !== -1) {
	                if (indent < minIndent)
	                    minIndent = indent;
	                if (shouldRemove && !testRemove(line, i))
	                    shouldRemove = false;
	            } else if (minEmptyLength > line.length) {
	                minEmptyLength = line.length;
	            }
	        });

	        if (minIndent == Infinity) {
	            minIndent = minEmptyLength;
	            ignoreBlankLines = false;
	            shouldRemove = false;
	        }

	        if (insertAtTabStop && minIndent % tabSize != 0)
	            minIndent = Math.floor(minIndent / tabSize) * tabSize;

	        iter(shouldRemove ? uncomment : comment);
	    };

	    this.toggleBlockComment = function(state, session, range, cursor) {
	        var comment = this.blockComment;
	        if (!comment)
	            return;
	        if (!comment.start && comment[0])
	            comment = comment[0];

	        var iterator = new TokenIterator(session, cursor.row, cursor.column);
	        var token = iterator.getCurrentToken();

	        var sel = session.selection;
	        var initialRange = session.selection.toOrientedRange();
	        var startRow, colDiff;

	        if (token && /comment/.test(token.type)) {
	            var startRange, endRange;
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.start);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    startRange = new Range(row, column, row, column + comment.start.length);
	                    break;
	                }
	                token = iterator.stepBackward();
	            }

	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.end);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    endRange = new Range(row, column, row, column + comment.end.length);
	                    break;
	                }
	                token = iterator.stepForward();
	            }
	            if (endRange)
	                session.remove(endRange);
	            if (startRange) {
	                session.remove(startRange);
	                startRow = startRange.start.row;
	                colDiff = -comment.start.length;
	            }
	        } else {
	            colDiff = comment.start.length;
	            startRow = range.start.row;
	            session.insert(range.end, comment.end);
	            session.insert(range.start, comment.start);
	        }
	        if (initialRange.start.row == startRow)
	            initialRange.start.column += colDiff;
	        if (initialRange.end.row == startRow)
	            initialRange.end.column += colDiff;
	        session.selection.fromOrientedRange(initialRange);
	    };

	    this.getNextLineIndent = function(state, line, tab) {
	        return this.$getIndent(line);
	    };

	    this.checkOutdent = function(state, line, input) {
	        return false;
	    };

	    this.autoOutdent = function(state, doc, row) {
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	    this.createWorker = function(session) {
	        return null;
	    };

	    this.createModeDelegates = function (mapping) {
	        this.$embeds = [];
	        this.$modes = {};
	        for (var i in mapping) {
	            if (mapping[i]) {
	                this.$embeds.push(i);
	                this.$modes[i] = new mapping[i]();
	            }
	        }

	        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
	            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

	        for (var i = 0; i < delegations.length; i++) {
	            (function(scope) {
	              var functionName = delegations[i];
	              var defaultHandler = scope[functionName];
	              scope[delegations[i]] = function() {
	                  return this.$delegator(functionName, arguments, defaultHandler);
	              };
	            }(this));
	        }
	    };

	    this.$delegator = function(method, args, defaultHandler) {
	        var state = args[0];
	        if (typeof state != "string")
	            state = state[0];
	        for (var i = 0; i < this.$embeds.length; i++) {
	            if (!this.$modes[this.$embeds[i]]) continue;

	            var split = state.split(this.$embeds[i]);
	            if (!split[0] && split[1]) {
	                args[0] = split[1];
	                var mode = this.$modes[this.$embeds[i]];
	                return mode[method].apply(mode, args);
	            }
	        }
	        var ret = defaultHandler.apply(this, args);
	        return defaultHandler ? ret : undefined;
	    };

	    this.transformAction = function(state, action, editor, session, param) {
	        if (this.$behaviour) {
	            var behaviours = this.$behaviour.getBehaviours();
	            for (var key in behaviours) {
	                if (behaviours[key][action]) {
	                    var ret = behaviours[key][action].apply(this, arguments);
	                    if (ret) {
	                        return ret;
	                    }
	                }
	            }
	        }
	    };
	    
	    this.getKeywords = function(append) {
	        if (!this.completionKeywords) {
	            var rules = this.$tokenizer.rules;
	            var completionKeywords = [];
	            for (var rule in rules) {
	                var ruleItr = rules[rule];
	                for (var r = 0, l = ruleItr.length; r < l; r++) {
	                    if (typeof ruleItr[r].token === "string") {
	                        if (/keyword|support|storage/.test(ruleItr[r].token))
	                            completionKeywords.push(ruleItr[r].regex);
	                    }
	                    else if (typeof ruleItr[r].token === "object") {
	                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
	                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
	                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
	                                completionKeywords.push(rule.substr(1, rule.length - 2));
	                            }
	                        }
	                    }
	                }
	            }
	            this.completionKeywords = completionKeywords;
	        }
	        if (!append)
	            return this.$keywordList;
	        return completionKeywords.concat(this.$keywordList || []);
	    };
	    
	    this.$createKeywordList = function() {
	        if (!this.$highlightRules)
	            this.getTokenizer();
	        return this.$keywordList = this.$highlightRules.$keywordList || [];
	    };

	    this.getCompletions = function(state, session, pos, prefix) {
	        var keywords = this.$keywordList || this.$createKeywordList();
	        return keywords.map(function(word) {
	            return {
	                name: word,
	                value: word,
	                score: 0,
	                meta: "keyword"
	            };
	        });
	    };

	    this.$id = "ace/mode/text";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/apply_delta",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	function throwDeltaError(delta, errorText){
	    console.log("Invalid Delta:", delta);
	    throw "Invalid Delta: " + errorText;
	}

	function positionInDocument(docLines, position) {
	    return position.row    >= 0 && position.row    <  docLines.length &&
	           position.column >= 0 && position.column <= docLines[position.row].length;
	}

	function validateDelta(docLines, delta) {
	    if (delta.action != "insert" && delta.action != "remove")
	        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
	    if (!(delta.lines instanceof Array))
	        throwDeltaError(delta, "delta.lines must be an Array");
	    if (!delta.start || !delta.end)
	       throwDeltaError(delta, "delta.start/end must be an present");
	    var start = delta.start;
	    if (!positionInDocument(docLines, delta.start))
	        throwDeltaError(delta, "delta.start must be contained in document");
	    var end = delta.end;
	    if (delta.action == "remove" && !positionInDocument(docLines, end))
	        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
	    var numRangeRows = end.row - start.row;
	    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
	    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
	        throwDeltaError(delta, "delta.range must match delta lines");
	}

	exports.applyDelta = function(docLines, delta, doNotValidate) {
	    
	    var row = delta.start.row;
	    var startColumn = delta.start.column;
	    var line = docLines[row] || "";
	    switch (delta.action) {
	        case "insert":
	            var lines = delta.lines;
	            if (lines.length === 1) {
	                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
	            } else {
	                var args = [row, 1].concat(delta.lines);
	                docLines.splice.apply(docLines, args);
	                docLines[row] = line.substring(0, startColumn) + docLines[row];
	                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
	            }
	            break;
	        case "remove":
	            var endColumn = delta.end.column;
	            var endRow = delta.end.row;
	            if (row === endRow) {
	                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
	            } else {
	                docLines.splice(
	                    row, endRow - row + 1,
	                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
	                );
	            }
	            break;
	    }
	}
	});

	ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var Anchor = exports.Anchor = function(doc, row, column) {
	    this.$onChange = this.onChange.bind(this);
	    this.attach(doc);
	    
	    if (typeof column == "undefined")
	        this.setPosition(row.row, row.column);
	    else
	        this.setPosition(row, column);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.getPosition = function() {
	        return this.$clipPositionToDocument(this.row, this.column);
	    };
	    this.getDocument = function() {
	        return this.document;
	    };
	    this.$insertRight = false;
	    this.onChange = function(delta) {
	        if (delta.start.row == delta.end.row && delta.start.row != this.row)
	            return;

	        if (delta.start.row > this.row)
	            return;
	            
	        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
	        this.setPosition(point.row, point.column, true);
	    };
	    
	    function $pointsInOrder(point1, point2, equalPointsInOrder) {
	        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
	        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
	    }
	            
	    function $getTransformedPoint(delta, point, moveIfEqual) {
	        var deltaIsInsert = delta.action == "insert";
	        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
	        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
	        var deltaStart = delta.start;
	        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
	        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
	            return {
	                row: point.row,
	                column: point.column
	            };
	        }
	        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
	            return {
	                row: point.row + deltaRowShift,
	                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
	            };
	        }
	        
	        return {
	            row: deltaStart.row,
	            column: deltaStart.column
	        };
	    }
	    this.setPosition = function(row, column, noClip) {
	        var pos;
	        if (noClip) {
	            pos = {
	                row: row,
	                column: column
	            };
	        } else {
	            pos = this.$clipPositionToDocument(row, column);
	        }

	        if (this.row == pos.row && this.column == pos.column)
	            return;

	        var old = {
	            row: this.row,
	            column: this.column
	        };

	        this.row = pos.row;
	        this.column = pos.column;
	        this._signal("change", {
	            old: old,
	            value: pos
	        });
	    };
	    this.detach = function() {
	        this.document.removeEventListener("change", this.$onChange);
	    };
	    this.attach = function(doc) {
	        this.document = doc || this.document;
	        this.document.on("change", this.$onChange);
	    };
	    this.$clipPositionToDocument = function(row, column) {
	        var pos = {};

	        if (row >= this.document.getLength()) {
	            pos.row = Math.max(0, this.document.getLength() - 1);
	            pos.column = this.document.getLine(pos.row).length;
	        }
	        else if (row < 0) {
	            pos.row = 0;
	            pos.column = 0;
	        }
	        else {
	            pos.row = row;
	            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
	        }

	        if (column < 0)
	            pos.column = 0;

	        return pos;
	    };

	}).call(Anchor.prototype);

	});

	ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var applyDelta = acequire("./apply_delta").applyDelta;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Anchor = acequire("./anchor").Anchor;

	var Document = function(textOrLines) {
	    this.$lines = [""];
	    if (textOrLines.length === 0) {
	        this.$lines = [""];
	    } else if (Array.isArray(textOrLines)) {
	        this.insertMergedLines({row: 0, column: 0}, textOrLines);
	    } else {
	        this.insert({row: 0, column:0}, textOrLines);
	    }
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setValue = function(text) {
	        var len = this.getLength() - 1;
	        this.remove(new Range(0, 0, len, this.getLine(len).length));
	        this.insert({row: 0, column: 0}, text);
	    };
	    this.getValue = function() {
	        return this.getAllLines().join(this.getNewLineCharacter());
	    };
	    this.createAnchor = function(row, column) {
	        return new Anchor(this, row, column);
	    };
	    if ("aaa".split(/a/).length === 0) {
	        this.$split = function(text) {
	            return text.replace(/\r\n|\r/g, "\n").split("\n");
	        };
	    } else {
	        this.$split = function(text) {
	            return text.split(/\r\n|\r|\n/);
	        };
	    }


	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r\n|\r|\n)/m);
	        this.$autoNewLine = match ? match[1] : "\n";
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineCharacter = function() {
	        switch (this.$newLineMode) {
	          case "windows":
	            return "\r\n";
	          case "unix":
	            return "\n";
	          default:
	            return this.$autoNewLine || "\n";
	        }
	    };

	    this.$autoNewLine = "";
	    this.$newLineMode = "auto";
	    this.setNewLineMode = function(newLineMode) {
	        if (this.$newLineMode === newLineMode)
	            return;

	        this.$newLineMode = newLineMode;
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineMode = function() {
	        return this.$newLineMode;
	    };
	    this.isNewLine = function(text) {
	        return (text == "\r\n" || text == "\r" || text == "\n");
	    };
	    this.getLine = function(row) {
	        return this.$lines[row] || "";
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.$lines.slice(firstRow, lastRow + 1);
	    };
	    this.getAllLines = function() {
	        return this.getLines(0, this.getLength());
	    };
	    this.getLength = function() {
	        return this.$lines.length;
	    };
	    this.getTextRange = function(range) {
	        return this.getLinesForRange(range).join(this.getNewLineCharacter());
	    };
	    this.getLinesForRange = function(range) {
	        var lines;
	        if (range.start.row === range.end.row) {
	            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
	        } else {
	            lines = this.getLines(range.start.row, range.end.row);
	            lines[0] = (lines[0] || "").substring(range.start.column);
	            var l = lines.length - 1;
	            if (range.end.row - range.start.row == l)
	                lines[l] = lines[l].substring(0, range.end.column);
	        }
	        return lines;
	    };
	    this.insertLines = function(row, lines) {
	        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
	        return this.insertFullLines(row, lines);
	    };
	    this.removeLines = function(firstRow, lastRow) {
	        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
	        return this.removeFullLines(firstRow, lastRow);
	    };
	    this.insertNewLine = function(position) {
	        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead.");
	        return this.insertMergedLines(position, ["", ""]);
	    };
	    this.insert = function(position, text) {
	        if (this.getLength() <= 1)
	            this.$detectNewLine(text);
	        
	        return this.insertMergedLines(position, this.$split(text));
	    };
	    this.insertInLine = function(position, text) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = this.pos(position.row, position.column + text.length);
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: [text]
	        }, true);
	        
	        return this.clonePos(end);
	    };
	    
	    this.clippedPos = function(row, column) {
	        var length = this.getLength();
	        if (row === undefined) {
	            row = length;
	        } else if (row < 0) {
	            row = 0;
	        } else if (row >= length) {
	            row = length - 1;
	            column = undefined;
	        }
	        var line = this.getLine(row);
	        if (column == undefined)
	            column = line.length;
	        column = Math.min(Math.max(column, 0), line.length);
	        return {row: row, column: column};
	    };
	    
	    this.clonePos = function(pos) {
	        return {row: pos.row, column: pos.column};
	    };
	    
	    this.pos = function(row, column) {
	        return {row: row, column: column};
	    };
	    
	    this.$clipPosition = function(position) {
	        var length = this.getLength();
	        if (position.row >= length) {
	            position.row = Math.max(0, length - 1);
	            position.column = this.getLine(length - 1).length;
	        } else {
	            position.row = Math.max(0, position.row);
	            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
	        }
	        return position;
	    };
	    this.insertFullLines = function(row, lines) {
	        row = Math.min(Math.max(row, 0), this.getLength());
	        var column = 0;
	        if (row < this.getLength()) {
	            lines = lines.concat([""]);
	            column = 0;
	        } else {
	            lines = [""].concat(lines);
	            row--;
	            column = this.$lines[row].length;
	        }
	        this.insertMergedLines({row: row, column: column}, lines);
	    };    
	    this.insertMergedLines = function(position, lines) {
	        var start = this.clippedPos(position.row, position.column);
	        var end = {
	            row: start.row + lines.length - 1,
	            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
	        };
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "insert",
	            lines: lines
	        });
	        
	        return this.clonePos(end);
	    };
	    this.remove = function(range) {
	        var start = this.clippedPos(range.start.row, range.start.column);
	        var end = this.clippedPos(range.end.row, range.end.column);
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({start: start, end: end})
	        });
	        return this.clonePos(start);
	    };
	    this.removeInLine = function(row, startColumn, endColumn) {
	        var start = this.clippedPos(row, startColumn);
	        var end = this.clippedPos(row, endColumn);
	        
	        this.applyDelta({
	            start: start,
	            end: end,
	            action: "remove",
	            lines: this.getLinesForRange({start: start, end: end})
	        }, true);
	        
	        return this.clonePos(start);
	    };
	    this.removeFullLines = function(firstRow, lastRow) {
	        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
	        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
	        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
	        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
	        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
	        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
	        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
	        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
	        var range = new Range(startRow, startCol, endRow, endCol);
	        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
	        
	        this.applyDelta({
	            start: range.start,
	            end: range.end,
	            action: "remove",
	            lines: this.getLinesForRange(range)
	        });
	        return deletedLines;
	    };
	    this.removeNewLine = function(row) {
	        if (row < this.getLength() - 1 && row >= 0) {
	            this.applyDelta({
	                start: this.pos(row, this.getLine(row).length),
	                end: this.pos(row + 1, 0),
	                action: "remove",
	                lines: ["", ""]
	            });
	        }
	    };
	    this.replace = function(range, text) {
	        if (!(range instanceof Range))
	            range = Range.fromPoints(range.start, range.end);
	        if (text.length === 0 && range.isEmpty())
	            return range.start;
	        if (text == this.getTextRange(range))
	            return range.end;

	        this.remove(range);
	        var end;
	        if (text) {
	            end = this.insert(range.start, text);
	        }
	        else {
	            end = range.start;
	        }
	        
	        return end;
	    };
	    this.applyDeltas = function(deltas) {
	        for (var i=0; i<deltas.length; i++) {
	            this.applyDelta(deltas[i]);
	        }
	    };
	    this.revertDeltas = function(deltas) {
	        for (var i=deltas.length-1; i>=0; i--) {
	            this.revertDelta(deltas[i]);
	        }
	    };
	    this.applyDelta = function(delta, doNotValidate) {
	        var isInsert = delta.action == "insert";
	        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
	            : !Range.comparePoints(delta.start, delta.end)) {
	            return;
	        }
	        
	        if (isInsert && delta.lines.length > 20000)
	            this.$splitAndapplyLargeDelta(delta, 20000);
	        applyDelta(this.$lines, delta, doNotValidate);
	        this._signal("change", delta);
	    };
	    
	    this.$splitAndapplyLargeDelta = function(delta, MAX) {
	        var lines = delta.lines;
	        var l = lines.length;
	        var row = delta.start.row; 
	        var column = delta.start.column;
	        var from = 0, to = 0;
	        do {
	            from = to;
	            to += MAX - 1;
	            var chunk = lines.slice(from, to);
	            if (to > l) {
	                delta.lines = chunk;
	                delta.start.row = row + from;
	                delta.start.column = column;
	                break;
	            }
	            chunk.push("");
	            this.applyDelta({
	                start: this.pos(row + from, column),
	                end: this.pos(row + to, column = 0),
	                action: delta.action,
	                lines: chunk
	            }, true);
	        } while(true);
	    };
	    this.revertDelta = function(delta) {
	        this.applyDelta({
	            start: this.clonePos(delta.start),
	            end: this.clonePos(delta.end),
	            action: (delta.action == "insert" ? "remove" : "insert"),
	            lines: delta.lines.slice()
	        });
	    };
	    this.indexToPosition = function(index, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        for (var i = startRow || 0, l = lines.length; i < l; i++) {
	            index -= lines[i].length + newlineLength;
	            if (index < 0)
	                return {row: i, column: index + lines[i].length + newlineLength};
	        }
	        return {row: l-1, column: lines[l-1].length};
	    };
	    this.positionToIndex = function(pos, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        var index = 0;
	        var row = Math.min(pos.row, lines.length);
	        for (var i = startRow || 0; i < row; ++i)
	            index += lines[i].length + newlineLength;

	        return index + pos.column;
	    };

	}).call(Document.prototype);

	exports.Document = Document;
	});

	ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var BackgroundTokenizer = function(tokenizer, editor) {
	    this.running = false;
	    this.lines = [];
	    this.states = [];
	    this.currentLine = 0;
	    this.tokenizer = tokenizer;

	    var self = this;

	    this.$worker = function() {
	        if (!self.running) { return; }

	        var workerStart = new Date();
	        var currentLine = self.currentLine;
	        var endLine = -1;
	        var doc = self.doc;

	        var startLine = currentLine;
	        while (self.lines[currentLine])
	            currentLine++;
	        
	        var len = doc.getLength();
	        var processedLines = 0;
	        self.running = false;
	        while (currentLine < len) {
	            self.$tokenizeRow(currentLine);
	            endLine = currentLine;
	            do {
	                currentLine++;
	            } while (self.lines[currentLine]);
	            processedLines ++;
	            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
	                self.running = setTimeout(self.$worker, 20);
	                break;
	            }
	        }
	        self.currentLine = currentLine;
	        
	        if (startLine <= endLine)
	            self.fireUpdateEvent(startLine, endLine);
	    };
	};

	(function(){

	    oop.implement(this, EventEmitter);
	    this.setTokenizer = function(tokenizer) {
	        this.tokenizer = tokenizer;
	        this.lines = [];
	        this.states = [];

	        this.start(0);
	    };
	    this.setDocument = function(doc) {
	        this.doc = doc;
	        this.lines = [];
	        this.states = [];

	        this.stop();
	    };
	    this.fireUpdateEvent = function(firstRow, lastRow) {
	        var data = {
	            first: firstRow,
	            last: lastRow
	        };
	        this._signal("update", {data: data});
	    };
	    this.start = function(startRow) {
	        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
	        this.lines.splice(this.currentLine, this.lines.length);
	        this.states.splice(this.currentLine, this.states.length);

	        this.stop();
	        this.running = setTimeout(this.$worker, 700);
	    };
	    
	    this.scheduleStart = function() {
	        if (!this.running)
	            this.running = setTimeout(this.$worker, 700);
	    }

	    this.$updateOnChange = function(delta) {
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;

	        if (len === 0) {
	            this.lines[startRow] = null;
	        } else if (delta.action == "remove") {
	            this.lines.splice(startRow, len + 1, null);
	            this.states.splice(startRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(startRow, 1);
	            this.lines.splice.apply(this.lines, args);
	            this.states.splice.apply(this.states, args);
	        }

	        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

	        this.stop();
	    };
	    this.stop = function() {
	        if (this.running)
	            clearTimeout(this.running);
	        this.running = false;
	    };
	    this.getTokens = function(row) {
	        return this.lines[row] || this.$tokenizeRow(row);
	    };
	    this.getState = function(row) {
	        if (this.currentLine == row)
	            this.$tokenizeRow(row);
	        return this.states[row] || "start";
	    };

	    this.$tokenizeRow = function(row) {
	        var line = this.doc.getLine(row);
	        var state = this.states[row - 1];

	        var data = this.tokenizer.getLineTokens(line, state, row);

	        if (this.states[row] + "" !== data.state + "") {
	            this.states[row] = data.state;
	            this.lines[row + 1] = null;
	            if (this.currentLine > row + 1)
	                this.currentLine = row + 1;
	        } else if (this.currentLine == row) {
	            this.currentLine = row + 1;
	        }

	        return this.lines[row] = data.tokens;
	    };

	}).call(BackgroundTokenizer.prototype);

	exports.BackgroundTokenizer = BackgroundTokenizer;
	});

	ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var SearchHighlight = function(regExp, clazz, type) {
	    this.setRegexp(regExp);
	    this.clazz = clazz;
	    this.type = type || "text";
	};

	(function() {
	    this.MAX_RANGES = 500;
	    
	    this.setRegexp = function(regExp) {
	        if (this.regExp+"" == regExp+"")
	            return;
	        this.regExp = regExp;
	        this.cache = [];
	    };

	    this.update = function(html, markerLayer, session, config) {
	        if (!this.regExp)
	            return;
	        var start = config.firstRow, end = config.lastRow;

	        for (var i = start; i <= end; i++) {
	            var ranges = this.cache[i];
	            if (ranges == null) {
	                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
	                if (ranges.length > this.MAX_RANGES)
	                    ranges = ranges.slice(0, this.MAX_RANGES);
	                ranges = ranges.map(function(match) {
	                    return new Range(i, match.offset, i, match.offset + match.length);
	                });
	                this.cache[i] = ranges.length ? ranges : "";
	            }

	            for (var j = ranges.length; j --; ) {
	                markerLayer.drawSingleLineMarker(
	                    html, ranges[j].toScreenRange(session), this.clazz, config);
	            }
	        }
	    };

	}).call(SearchHighlight.prototype);

	exports.SearchHighlight = SearchHighlight;
	});

	ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	function FoldLine(foldData, folds) {
	    this.foldData = foldData;
	    if (Array.isArray(folds)) {
	        this.folds = folds;
	    } else {
	        folds = this.folds = [ folds ];
	    }

	    var last = folds[folds.length - 1];
	    this.range = new Range(folds[0].start.row, folds[0].start.column,
	                           last.end.row, last.end.column);
	    this.start = this.range.start;
	    this.end   = this.range.end;

	    this.folds.forEach(function(fold) {
	        fold.setFoldLine(this);
	    }, this);
	}

	(function() {
	    this.shiftRow = function(shift) {
	        this.start.row += shift;
	        this.end.row += shift;
	        this.folds.forEach(function(fold) {
	            fold.start.row += shift;
	            fold.end.row += shift;
	        });
	    };

	    this.addFold = function(fold) {
	        if (fold.sameRow) {
	            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
	                throw new Error("Can't add a fold to this FoldLine as it has no connection");
	            }
	            this.folds.push(fold);
	            this.folds.sort(function(a, b) {
	                return -a.range.compareEnd(b.start.row, b.start.column);
	            });
	            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
	                this.end.row = fold.end.row;
	                this.end.column =  fold.end.column;
	            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
	                this.start.row = fold.start.row;
	                this.start.column = fold.start.column;
	            }
	        } else if (fold.start.row == this.end.row) {
	            this.folds.push(fold);
	            this.end.row = fold.end.row;
	            this.end.column = fold.end.column;
	        } else if (fold.end.row == this.start.row) {
	            this.folds.unshift(fold);
	            this.start.row = fold.start.row;
	            this.start.column = fold.start.column;
	        } else {
	            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
	        }
	        fold.foldLine = this;
	    };

	    this.containsRow = function(row) {
	        return row >= this.start.row && row <= this.end.row;
	    };

	    this.walk = function(callback, endRow, endColumn) {
	        var lastEnd = 0,
	            folds = this.folds,
	            fold,
	            cmp, stop, isNewRow = true;

	        if (endRow == null) {
	            endRow = this.end.row;
	            endColumn = this.end.column;
	        }

	        for (var i = 0; i < folds.length; i++) {
	            fold = folds[i];

	            cmp = fold.range.compareStart(endRow, endColumn);
	            if (cmp == -1) {
	                callback(null, endRow, endColumn, lastEnd, isNewRow);
	                return;
	            }

	            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
	            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
	            if (stop || cmp === 0) {
	                return;
	            }
	            isNewRow = !fold.sameRow;
	            lastEnd = fold.end.column;
	        }
	        callback(null, endRow, endColumn, lastEnd, isNewRow);
	    };

	    this.getNextFoldTo = function(row, column) {
	        var fold, cmp;
	        for (var i = 0; i < this.folds.length; i++) {
	            fold = this.folds[i];
	            cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                return {
	                    fold: fold,
	                    kind: "after"
	                };
	            } else if (cmp === 0) {
	                return {
	                    fold: fold,
	                    kind: "inside"
	                };
	            }
	        }
	        return null;
	    };

	    this.addRemoveChars = function(row, column, len) {
	        var ret = this.getNextFoldTo(row, column),
	            fold, folds;
	        if (ret) {
	            fold = ret.fold;
	            if (ret.kind == "inside"
	                && fold.start.column != column
	                && fold.start.row != row)
	            {
	                window.console && window.console.log(row, column, fold);
	            } else if (fold.start.row == row) {
	                folds = this.folds;
	                var i = folds.indexOf(fold);
	                if (i === 0) {
	                    this.start.column += len;
	                }
	                for (i; i < folds.length; i++) {
	                    fold = folds[i];
	                    fold.start.column += len;
	                    if (!fold.sameRow) {
	                        return;
	                    }
	                    fold.end.column += len;
	                }
	                this.end.column += len;
	            }
	        }
	    };

	    this.split = function(row, column) {
	        var pos = this.getNextFoldTo(row, column);
	        
	        if (!pos || pos.kind == "inside")
	            return null;
	            
	        var fold = pos.fold;
	        var folds = this.folds;
	        var foldData = this.foldData;
	        
	        var i = folds.indexOf(fold);
	        var foldBefore = folds[i - 1];
	        this.end.row = foldBefore.end.row;
	        this.end.column = foldBefore.end.column;
	        folds = folds.splice(i, folds.length - i);

	        var newFoldLine = new FoldLine(foldData, folds);
	        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
	        return newFoldLine;
	    };

	    this.merge = function(foldLineNext) {
	        var folds = foldLineNext.folds;
	        for (var i = 0; i < folds.length; i++) {
	            this.addFold(folds[i]);
	        }
	        var foldData = this.foldData;
	        foldData.splice(foldData.indexOf(foldLineNext), 1);
	    };

	    this.toString = function() {
	        var ret = [this.range.toString() + ": [" ];

	        this.folds.forEach(function(fold) {
	            ret.push("  " + fold.toString());
	        });
	        ret.push("]");
	        return ret.join("\n");
	    };

	    this.idxToPosition = function(idx) {
	        var lastFoldEndColumn = 0;

	        for (var i = 0; i < this.folds.length; i++) {
	            var fold = this.folds[i];

	            idx -= fold.start.column - lastFoldEndColumn;
	            if (idx < 0) {
	                return {
	                    row: fold.start.row,
	                    column: fold.start.column + idx
	                };
	            }

	            idx -= fold.placeholder.length;
	            if (idx < 0) {
	                return fold.start;
	            }

	            lastFoldEndColumn = fold.end.column;
	        }

	        return {
	            row: this.end.row,
	            column: this.end.column + idx
	        };
	    };
	}).call(FoldLine.prototype);

	exports.FoldLine = FoldLine;
	});

	ace.define("ace/range_list",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";
	var Range = acequire("./range").Range;
	var comparePoints = Range.comparePoints;

	var RangeList = function() {
	    this.ranges = [];
	};

	(function() {
	    this.comparePoints = comparePoints;

	    this.pointIndex = function(pos, excludeEdges, startIndex) {
	        var list = this.ranges;

	        for (var i = startIndex || 0; i < list.length; i++) {
	            var range = list[i];
	            var cmpEnd = comparePoints(pos, range.end);
	            if (cmpEnd > 0)
	                continue;
	            var cmpStart = comparePoints(pos, range.start);
	            if (cmpEnd === 0)
	                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
	            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
	                return i;

	            return -i-1;
	        }
	        return -i - 1;
	    };

	    this.add = function(range) {
	        var excludeEdges = !range.isEmpty();
	        var startIndex = this.pointIndex(range.start, excludeEdges);
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;

	        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

	        if (endIndex < 0)
	            endIndex = -endIndex - 1;
	        else
	            endIndex++;
	        return this.ranges.splice(startIndex, endIndex - startIndex, range);
	    };

	    this.addList = function(list) {
	        var removed = [];
	        for (var i = list.length; i--; ) {
	            removed.push.apply(removed, this.add(list[i]));
	        }
	        return removed;
	    };

	    this.substractPoint = function(pos) {
	        var i = this.pointIndex(pos);

	        if (i >= 0)
	            return this.ranges.splice(i, 1);
	    };
	    this.merge = function() {
	        var removed = [];
	        var list = this.ranges;
	        
	        list = list.sort(function(a, b) {
	            return comparePoints(a.start, b.start);
	        });
	        
	        var next = list[0], range;
	        for (var i = 1; i < list.length; i++) {
	            range = next;
	            next = list[i];
	            var cmp = comparePoints(range.end, next.start);
	            if (cmp < 0)
	                continue;

	            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
	                continue;

	            if (comparePoints(range.end, next.end) < 0) {
	                range.end.row = next.end.row;
	                range.end.column = next.end.column;
	            }

	            list.splice(i, 1);
	            removed.push(next);
	            next = range;
	            i--;
	        }
	        
	        this.ranges = list;

	        return removed;
	    };

	    this.contains = function(row, column) {
	        return this.pointIndex({row: row, column: column}) >= 0;
	    };

	    this.containsPoint = function(pos) {
	        return this.pointIndex(pos) >= 0;
	    };

	    this.rangeAtPoint = function(pos) {
	        var i = this.pointIndex(pos);
	        if (i >= 0)
	            return this.ranges[i];
	    };


	    this.clipRows = function(startRow, endRow) {
	        var list = this.ranges;
	        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
	            return [];

	        var startIndex = this.pointIndex({row: startRow, column: 0});
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;
	        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
	        if (endIndex < 0)
	            endIndex = -endIndex - 1;

	        var clipped = [];
	        for (var i = startIndex; i < endIndex; i++) {
	            clipped.push(list[i]);
	        }
	        return clipped;
	    };

	    this.removeAll = function() {
	        return this.ranges.splice(0, this.ranges.length);
	    };

	    this.attach = function(session) {
	        if (this.session)
	            this.detach();

	        this.session = session;
	        this.onChange = this.$onChange.bind(this);

	        this.session.on('change', this.onChange);
	    };

	    this.detach = function() {
	        if (!this.session)
	            return;
	        this.session.removeListener('change', this.onChange);
	        this.session = null;
	    };

	    this.$onChange = function(delta) {
	        if (delta.action == "insert"){
	            var start = delta.start;
	            var end = delta.end;
	        } else {
	            var end = delta.start;
	            var start = delta.end;
	        }
	        var startRow = start.row;
	        var endRow = end.row;
	        var lineDif = endRow - startRow;

	        var colDiff = -start.column + end.column;
	        var ranges = this.ranges;

	        for (var i = 0, n = ranges.length; i < n; i++) {
	            var r = ranges[i];
	            if (r.end.row < startRow)
	                continue;
	            if (r.start.row > startRow)
	                break;

	            if (r.start.row == startRow && r.start.column >= start.column ) {
	                if (r.start.column == start.column && this.$insertRight) {
	                } else {
	                    r.start.column += colDiff;
	                    r.start.row += lineDif;
	                }
	            }
	            if (r.end.row == startRow && r.end.column >= start.column) {
	                if (r.end.column == start.column && this.$insertRight) {
	                    continue;
	                }
	                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
	                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
	                        r.end.column -= colDiff;
	                }
	                r.end.column += colDiff;
	                r.end.row += lineDif;
	            }
	        }

	        if (lineDif != 0 && i < n) {
	            for (; i < n; i++) {
	                var r = ranges[i];
	                r.start.row += lineDif;
	                r.end.row += lineDif;
	            }
	        }
	    };

	}).call(RangeList.prototype);

	exports.RangeList = RangeList;
	});

	ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var RangeList = acequire("../range_list").RangeList;
	var oop = acequire("../lib/oop")
	var Fold = exports.Fold = function(range, placeholder) {
	    this.foldLine = null;
	    this.placeholder = placeholder;
	    this.range = range;
	    this.start = range.start;
	    this.end = range.end;

	    this.sameRow = range.start.row == range.end.row;
	    this.subFolds = this.ranges = [];
	};

	oop.inherits(Fold, RangeList);

	(function() {

	    this.toString = function() {
	        return '"' + this.placeholder + '" ' + this.range.toString();
	    };

	    this.setFoldLine = function(foldLine) {
	        this.foldLine = foldLine;
	        this.subFolds.forEach(function(fold) {
	            fold.setFoldLine(foldLine);
	        });
	    };

	    this.clone = function() {
	        var range = this.range.clone();
	        var fold = new Fold(range, this.placeholder);
	        this.subFolds.forEach(function(subFold) {
	            fold.subFolds.push(subFold.clone());
	        });
	        fold.collapseChildren = this.collapseChildren;
	        return fold;
	    };

	    this.addSubFold = function(fold) {
	        if (this.range.isEqual(fold))
	            return;

	        if (!this.range.containsRange(fold))
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
	        consumeRange(fold, this.start);

	        var row = fold.start.row, column = fold.start.column;
	        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
	            cmp = this.subFolds[i].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterStart = this.subFolds[i];

	        if (cmp == 0)
	            return afterStart.addSubFold(fold);
	        var row = fold.range.end.row, column = fold.range.end.column;
	        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
	            cmp = this.subFolds[j].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterEnd = this.subFolds[j];

	        if (cmp == 0)
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

	        var consumedFolds = this.subFolds.splice(i, j - i, fold);
	        fold.setFoldLine(this.foldLine);

	        return fold;
	    };
	    
	    this.restoreRange = function(range) {
	        return restoreRange(range, this.start);
	    };

	}).call(Fold.prototype);

	function consumePoint(point, anchor) {
	    point.row -= anchor.row;
	    if (point.row == 0)
	        point.column -= anchor.column;
	}
	function consumeRange(range, anchor) {
	    consumePoint(range.start, anchor);
	    consumePoint(range.end, anchor);
	}
	function restorePoint(point, anchor) {
	    if (point.row == 0)
	        point.column += anchor.column;
	    point.row += anchor.row;
	}
	function restoreRange(range, anchor) {
	    restorePoint(range.start, anchor);
	    restorePoint(range.end, anchor);
	}

	});

	ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var FoldLine = acequire("./fold_line").FoldLine;
	var Fold = acequire("./fold").Fold;
	var TokenIterator = acequire("../token_iterator").TokenIterator;

	function Folding() {
	    this.getFoldAt = function(row, column, side) {
	        var foldLine = this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var folds = foldLine.folds;
	        for (var i = 0; i < folds.length; i++) {
	            var fold = folds[i];
	            if (fold.range.contains(row, column)) {
	                if (side == 1 && fold.range.isEnd(row, column)) {
	                    continue;
	                } else if (side == -1 && fold.range.isStart(row, column)) {
	                    continue;
	                }
	                return fold;
	            }
	        }
	    };
	    this.getFoldsInRange = function(range) {
	        var start = range.start;
	        var end = range.end;
	        var foldLines = this.$foldData;
	        var foundFolds = [];

	        start.column += 1;
	        end.column -= 1;

	        for (var i = 0; i < foldLines.length; i++) {
	            var cmp = foldLines[i].range.compareRange(range);
	            if (cmp == 2) {
	                continue;
	            }
	            else if (cmp == -2) {
	                break;
	            }

	            var folds = foldLines[i].folds;
	            for (var j = 0; j < folds.length; j++) {
	                var fold = folds[j];
	                cmp = fold.range.compareRange(range);
	                if (cmp == -2) {
	                    break;
	                } else if (cmp == 2) {
	                    continue;
	                } else
	                if (cmp == 42) {
	                    break;
	                }
	                foundFolds.push(fold);
	            }
	        }
	        start.column -= 1;
	        end.column += 1;

	        return foundFolds;
	    };

	    this.getFoldsInRangeList = function(ranges) {
	        if (Array.isArray(ranges)) {
	            var folds = [];
	            ranges.forEach(function(range) {
	                folds = folds.concat(this.getFoldsInRange(range));
	            }, this);
	        } else {
	            var folds = this.getFoldsInRange(ranges);
	        }
	        return folds;
	    };
	    this.getAllFolds = function() {
	        var folds = [];
	        var foldLines = this.$foldData;
	        
	        for (var i = 0; i < foldLines.length; i++)
	            for (var j = 0; j < foldLines[i].folds.length; j++)
	                folds.push(foldLines[i].folds[j]);

	        return folds;
	    };
	    this.getFoldStringAt = function(row, column, trim, foldLine) {
	        foldLine = foldLine || this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var lastFold = {
	            end: { column: 0 }
	        };
	        var str, fold;
	        for (var i = 0; i < foldLine.folds.length; i++) {
	            fold = foldLine.folds[i];
	            var cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                str = this
	                    .getLine(fold.start.row)
	                    .substring(lastFold.end.column, fold.start.column);
	                break;
	            }
	            else if (cmp === 0) {
	                return null;
	            }
	            lastFold = fold;
	        }
	        if (!str)
	            str = this.getLine(fold.start.row).substring(lastFold.end.column);

	        if (trim == -1)
	            return str.substring(0, column - lastFold.end.column);
	        else if (trim == 1)
	            return str.substring(column - lastFold.end.column);
	        else
	            return str;
	    };

	    this.getFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
	                return foldLine;
	            } else if (foldLine.end.row > docRow) {
	                return null;
	            }
	        }
	        return null;
	    };
	    this.getNextFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.end.row >= docRow) {
	                return foldLine;
	            }
	        }
	        return null;
	    };

	    this.getFoldedRowCount = function(first, last) {
	        var foldData = this.$foldData, rowCount = last-first+1;
	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i],
	                end = foldLine.end.row,
	                start = foldLine.start.row;
	            if (end >= last) {
	                if (start < last) {
	                    if (start >= first)
	                        rowCount -= last-start;
	                    else
	                        rowCount = 0; // in one fold
	                }
	                break;
	            } else if (end >= first){
	                if (start >= first) // fold inside range
	                    rowCount -=  end-start;
	                else
	                    rowCount -=  end-first+1;
	            }
	        }
	        return rowCount;
	    };

	    this.$addFoldLine = function(foldLine) {
	        this.$foldData.push(foldLine);
	        this.$foldData.sort(function(a, b) {
	            return a.start.row - b.start.row;
	        });
	        return foldLine;
	    };
	    this.addFold = function(placeholder, range) {
	        var foldData = this.$foldData;
	        var added = false;
	        var fold;
	        
	        if (placeholder instanceof Fold)
	            fold = placeholder;
	        else {
	            fold = new Fold(range, placeholder);
	            fold.collapseChildren = range.collapseChildren;
	        }
	        this.$clipRangeToDocument(fold.range);

	        var startRow = fold.start.row;
	        var startColumn = fold.start.column;
	        var endRow = fold.end.row;
	        var endColumn = fold.end.column;
	        if (!(startRow < endRow || 
	            startRow == endRow && startColumn <= endColumn - 2))
	            throw new Error("The range has to be at least 2 characters width");

	        var startFold = this.getFoldAt(startRow, startColumn, 1);
	        var endFold = this.getFoldAt(endRow, endColumn, -1);
	        if (startFold && endFold == startFold)
	            return startFold.addSubFold(fold);

	        if (startFold && !startFold.range.isStart(startRow, startColumn))
	            this.removeFold(startFold);
	        
	        if (endFold && !endFold.range.isEnd(endRow, endColumn))
	            this.removeFold(endFold);
	        var folds = this.getFoldsInRange(fold.range);
	        if (folds.length > 0) {
	            this.removeFolds(folds);
	            folds.forEach(function(subFold) {
	                fold.addSubFold(subFold);
	            });
	        }

	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (endRow == foldLine.start.row) {
	                foldLine.addFold(fold);
	                added = true;
	                break;
	            } else if (startRow == foldLine.end.row) {
	                foldLine.addFold(fold);
	                added = true;
	                if (!fold.sameRow) {
	                    var foldLineNext = foldData[i + 1];
	                    if (foldLineNext && foldLineNext.start.row == endRow) {
	                        foldLine.merge(foldLineNext);
	                        break;
	                    }
	                }
	                break;
	            } else if (endRow <= foldLine.start.row) {
	                break;
	            }
	        }

	        if (!added)
	            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

	        if (this.$useWrapMode)
	            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
	        else
	            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "add" });

	        return fold;
	    };

	    this.addFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.addFold(fold);
	        }, this);
	    };

	    this.removeFold = function(fold) {
	        var foldLine = fold.foldLine;
	        var startRow = foldLine.start.row;
	        var endRow = foldLine.end.row;

	        var foldLines = this.$foldData;
	        var folds = foldLine.folds;
	        if (folds.length == 1) {
	            foldLines.splice(foldLines.indexOf(foldLine), 1);
	        } else
	        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
	            folds.pop();
	            foldLine.end.row = folds[folds.length - 1].end.row;
	            foldLine.end.column = folds[folds.length - 1].end.column;
	        } else
	        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
	            folds.shift();
	            foldLine.start.row = folds[0].start.row;
	            foldLine.start.column = folds[0].start.column;
	        } else
	        if (fold.sameRow) {
	            folds.splice(folds.indexOf(fold), 1);
	        } else
	        {
	            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
	            folds = newFoldLine.folds;
	            folds.shift();
	            newFoldLine.start.row = folds[0].start.row;
	            newFoldLine.start.column = folds[0].start.column;
	        }

	        if (!this.$updating) {
	            if (this.$useWrapMode)
	                this.$updateWrapData(startRow, endRow);
	            else
	                this.$updateRowLengthCache(startRow, endRow);
	        }
	        this.$modified = true;
	        this._signal("changeFold", { data: fold, action: "remove" });
	    };

	    this.removeFolds = function(folds) {
	        var cloneFolds = [];
	        for (var i = 0; i < folds.length; i++) {
	            cloneFolds.push(folds[i]);
	        }

	        cloneFolds.forEach(function(fold) {
	            this.removeFold(fold);
	        }, this);
	        this.$modified = true;
	    };

	    this.expandFold = function(fold) {
	        this.removeFold(fold);
	        fold.subFolds.forEach(function(subFold) {
	            fold.restoreRange(subFold);
	            this.addFold(subFold);
	        }, this);
	        if (fold.collapseChildren > 0) {
	            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
	        }
	        fold.subFolds = [];
	    };

	    this.expandFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.expandFold(fold);
	        }, this);
	    };

	    this.unfold = function(location, expandInner) {
	        var range, folds;
	        if (location == null) {
	            range = new Range(0, 0, this.getLength(), 0);
	            expandInner = true;
	        } else if (typeof location == "number")
	            range = new Range(location, 0, location, this.getLine(location).length);
	        else if ("row" in location)
	            range = Range.fromPoints(location, location);
	        else
	            range = location;
	        
	        folds = this.getFoldsInRangeList(range);
	        if (expandInner) {
	            this.removeFolds(folds);
	        } else {
	            var subFolds = folds;
	            while (subFolds.length) {
	                this.expandFolds(subFolds);
	                subFolds = this.getFoldsInRangeList(range);
	            }
	        }
	        if (folds.length)
	            return folds;
	    };
	    this.isRowFolded = function(docRow, startFoldRow) {
	        return !!this.getFoldLine(docRow, startFoldRow);
	    };

	    this.getRowFoldEnd = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.end.row : docRow;
	    };

	    this.getRowFoldStart = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.start.row : docRow;
	    };

	    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
	        if (startRow == null)
	            startRow = foldLine.start.row;
	        if (startColumn == null)
	            startColumn = 0;
	        if (endRow == null)
	            endRow = foldLine.end.row;
	        if (endColumn == null)
	            endColumn = this.getLine(endRow).length;
	        var doc = this.doc;
	        var textLine = "";

	        foldLine.walk(function(placeholder, row, column, lastColumn) {
	            if (row < startRow)
	                return;
	            if (row == startRow) {
	                if (column < startColumn)
	                    return;
	                lastColumn = Math.max(startColumn, lastColumn);
	            }

	            if (placeholder != null) {
	                textLine += placeholder;
	            } else {
	                textLine += doc.getLine(row).substring(lastColumn, column);
	            }
	        }, endRow, endColumn);
	        return textLine;
	    };

	    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
	        var foldLine = this.getFoldLine(row);

	        if (!foldLine) {
	            var line;
	            line = this.doc.getLine(row);
	            return line.substring(startColumn || 0, endColumn || line.length);
	        } else {
	            return this.getFoldDisplayLine(
	                foldLine, row, endColumn, startRow, startColumn);
	        }
	    };

	    this.$cloneFoldData = function() {
	        var fd = [];
	        fd = this.$foldData.map(function(foldLine) {
	            var folds = foldLine.folds.map(function(fold) {
	                return fold.clone();
	            });
	            return new FoldLine(fd, folds);
	        });

	        return fd;
	    };

	    this.toggleFold = function(tryToUnfold) {
	        var selection = this.selection;
	        var range = selection.getRange();
	        var fold;
	        var bracketPos;

	        if (range.isEmpty()) {
	            var cursor = range.start;
	            fold = this.getFoldAt(cursor.row, cursor.column);

	            if (fold) {
	                this.expandFold(fold);
	                return;
	            } else if (bracketPos = this.findMatchingBracket(cursor)) {
	                if (range.comparePoint(bracketPos) == 1) {
	                    range.end = bracketPos;
	                } else {
	                    range.start = bracketPos;
	                    range.start.column++;
	                    range.end.column--;
	                }
	            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
	                if (range.comparePoint(bracketPos) == 1)
	                    range.end = bracketPos;
	                else
	                    range.start = bracketPos;

	                range.start.column++;
	            } else {
	                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
	            }
	        } else {
	            var folds = this.getFoldsInRange(range);
	            if (tryToUnfold && folds.length) {
	                this.expandFolds(folds);
	                return;
	            } else if (folds.length == 1 ) {
	                fold = folds[0];
	            }
	        }

	        if (!fold)
	            fold = this.getFoldAt(range.start.row, range.start.column);

	        if (fold && fold.range.toString() == range.toString()) {
	            this.expandFold(fold);
	            return;
	        }

	        var placeholder = "...";
	        if (!range.isMultiLine()) {
	            placeholder = this.getTextRange(range);
	            if (placeholder.length < 4)
	                return;
	            placeholder = placeholder.trim().substring(0, 2) + "..";
	        }

	        this.addFold(placeholder, range);
	    };

	    this.getCommentFoldRange = function(row, column, dir) {
	        var iterator = new TokenIterator(this, row, column);
	        var token = iterator.getCurrentToken();
	        if (token && /^comment|string/.test(token.type)) {
	            var range = new Range();
	            var re = new RegExp(token.type.replace(/\..*/, "\\."));
	            if (dir != 1) {
	                do {
	                    token = iterator.stepBackward();
	                } while (token && re.test(token.type));
	                iterator.stepForward();
	            }
	            
	            range.start.row = iterator.getCurrentTokenRow();
	            range.start.column = iterator.getCurrentTokenColumn() + 2;

	            iterator = new TokenIterator(this, row, column);
	            
	            if (dir != -1) {
	                do {
	                    token = iterator.stepForward();
	                } while (token && re.test(token.type));
	                token = iterator.stepBackward();
	            } else
	                token = iterator.getCurrentToken();

	            range.end.row = iterator.getCurrentTokenRow();
	            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
	            return range;
	        }
	    };

	    this.foldAll = function(startRow, endRow, depth) {
	        if (depth == undefined)
	            depth = 100000; // JSON.stringify doesn't hanle Infinity
	        var foldWidgets = this.foldWidgets;
	        if (!foldWidgets)
	            return; // mode doesn't support folding
	        endRow = endRow || this.getLength();
	        startRow = startRow || 0;
	        for (var row = startRow; row < endRow; row++) {
	            if (foldWidgets[row] == null)
	                foldWidgets[row] = this.getFoldWidget(row);
	            if (foldWidgets[row] != "start")
	                continue;

	            var range = this.getFoldWidgetRange(row);
	            if (range && range.isMultiLine()
	                && range.end.row <= endRow
	                && range.start.row >= startRow
	            ) {
	                row = range.end.row;
	                try {
	                    var fold = this.addFold("...", range);
	                    if (fold)
	                        fold.collapseChildren = depth;
	                } catch(e) {}
	            }
	        }
	    };
	    this.$foldStyles = {
	        "manual": 1,
	        "markbegin": 1,
	        "markbeginend": 1
	    };
	    this.$foldStyle = "markbegin";
	    this.setFoldStyle = function(style) {
	        if (!this.$foldStyles[style])
	            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
	        
	        if (this.$foldStyle == style)
	            return;

	        this.$foldStyle = style;
	        
	        if (style == "manual")
	            this.unfold();
	        var mode = this.$foldMode;
	        this.$setFolding(null);
	        this.$setFolding(mode);
	    };

	    this.$setFolding = function(foldMode) {
	        if (this.$foldMode == foldMode)
	            return;
	            
	        this.$foldMode = foldMode;
	        
	        this.off('change', this.$updateFoldWidgets);
	        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	        this._signal("changeAnnotation");
	        
	        if (!foldMode || this.$foldStyle == "manual") {
	            this.foldWidgets = null;
	            return;
	        }
	        
	        this.foldWidgets = [];
	        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
	        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
	        
	        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
	        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
	        this.on('change', this.$updateFoldWidgets);
	        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	    };

	    this.getParentFoldRangeData = function (row, ignoreCurrent) {
	        var fw = this.foldWidgets;
	        if (!fw || (ignoreCurrent && fw[row]))
	            return {};

	        var i = row - 1, firstRange;
	        while (i >= 0) {
	            var c = fw[i];
	            if (c == null)
	                c = fw[i] = this.getFoldWidget(i);

	            if (c == "start") {
	                var range = this.getFoldWidgetRange(i);
	                if (!firstRange)
	                    firstRange = range;
	                if (range && range.end.row >= row)
	                    break;
	            }
	            i--;
	        }

	        return {
	            range: i !== -1 && range,
	            firstRange: firstRange
	        };
	    };

	    this.onFoldWidgetClick = function(row, e) {
	        e = e.domEvent;
	        var options = {
	            children: e.shiftKey,
	            all: e.ctrlKey || e.metaKey,
	            siblings: e.altKey
	        };
	        
	        var range = this.$toggleFoldWidget(row, options);
	        if (!range) {
	            var el = (e.target || e.srcElement);
	            if (el && /ace_fold-widget/.test(el.className))
	                el.className += " ace_invalid";
	        }
	    };
	    
	    this.$toggleFoldWidget = function(row, options) {
	        if (!this.getFoldWidget)
	            return;
	        var type = this.getFoldWidget(row);
	        var line = this.getLine(row);

	        var dir = type === "end" ? -1 : 1;
	        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

	        if (fold) {
	            if (options.children || options.all)
	                this.removeFold(fold);
	            else
	                this.expandFold(fold);
	            return;
	        }

	        var range = this.getFoldWidgetRange(row, true);
	        if (range && !range.isMultiLine()) {
	            fold = this.getFoldAt(range.start.row, range.start.column, 1);
	            if (fold && range.isEqual(fold.range)) {
	                this.removeFold(fold);
	                return;
	            }
	        }
	        
	        if (options.siblings) {
	            var data = this.getParentFoldRangeData(row);
	            if (data.range) {
	                var startRow = data.range.start.row + 1;
	                var endRow = data.range.end.row;
	            }
	            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
	        } else if (options.children) {
	            endRow = range ? range.end.row : this.getLength();
	            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
	        } else if (range) {
	            if (options.all) 
	                range.collapseChildren = 10000;
	            this.addFold("...", range);
	        }
	        
	        return range;
	    };
	    
	    
	    
	    this.toggleFoldWidget = function(toggleParent) {
	        var row = this.selection.getCursor().row;
	        row = this.getRowFoldStart(row);
	        var range = this.$toggleFoldWidget(row, {});
	        
	        if (range)
	            return;
	        var data = this.getParentFoldRangeData(row, true);
	        range = data.range || data.firstRange;
	        
	        if (range) {
	            row = range.start.row;
	            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

	            if (fold) {
	                this.removeFold(fold);
	            } else {
	                this.addFold("...", range);
	            }
	        }
	    };

	    this.updateFoldWidgets = function(delta) {
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;

	        if (len === 0) {
	            this.foldWidgets[firstRow] = null;
	        } else if (delta.action == 'remove') {
	            this.foldWidgets.splice(firstRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.foldWidgets.splice.apply(this.foldWidgets, args);
	        }
	    };
	    this.tokenizerUpdateFoldWidgets = function(e) {
	        var rows = e.data;
	        if (rows.first != rows.last) {
	            if (this.foldWidgets.length > rows.first)
	                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
	        }
	    };
	}

	exports.Folding = Folding;

	});

	ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;


	function BracketMatch() {

	    this.findMatchingBracket = function(position, chr) {
	        if (position.column == 0) return null;

	        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
	        if (charBeforeCursor == "") return null;

	        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match)
	            return null;

	        if (match[1])
	            return this.$findClosingBracket(match[1], position);
	        else
	            return this.$findOpeningBracket(match[2], position);
	    };
	    
	    this.getBracketRange = function(pos) {
	        var line = this.getLine(pos.row);
	        var before = true, range;

	        var chr = line.charAt(pos.column-1);
	        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match) {
	            chr = line.charAt(pos.column);
	            pos = {row: pos.row, column: pos.column + 1};
	            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	            before = false;
	        }
	        if (!match)
	            return null;

	        if (match[1]) {
	            var bracketPos = this.$findClosingBracket(match[1], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(pos, bracketPos);
	            if (!before) {
	                range.end.column++;
	                range.start.column--;
	            }
	            range.cursor = range.end;
	        } else {
	            var bracketPos = this.$findOpeningBracket(match[2], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(bracketPos, pos);
	            if (!before) {
	                range.start.column++;
	                range.end.column--;
	            }
	            range.cursor = range.start;
	        }
	        
	        return range;
	    };

	    this.$brackets = {
	        ")": "(",
	        "(": ")",
	        "]": "[",
	        "[": "]",
	        "{": "}",
	        "}": "{"
	    };

	    this.$findOpeningBracket = function(bracket, position, typeRe) {
	        var openBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;
	        
	         if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("rparen", ".paren")
	                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
	        var value = token.value;
	        
	        while (true) {
	        
	            while (valueIndex >= 0) {
	                var chr = value.charAt(valueIndex);
	                if (chr == openBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex -= 1;
	            }
	            do {
	                token = iterator.stepBackward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;
	                
	            value = token.value;
	            valueIndex = value.length - 1;
	        }
	        
	        return null;
	    };

	    this.$findClosingBracket = function(bracket, position, typeRe) {
	        var closingBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;

	        if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("lparen", ".paren")
	                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn();

	        while (true) {

	            var value = token.value;
	            var valueLength = value.length;
	            while (valueIndex < valueLength) {
	                var chr = value.charAt(valueIndex);
	                if (chr == closingBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex += 1;
	            }
	            do {
	                token = iterator.stepForward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;

	            valueIndex = 0;
	        }
	        
	        return null;
	    };
	}
	exports.BracketMatch = BracketMatch;

	});

	ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var config = acequire("./config");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Selection = acequire("./selection").Selection;
	var TextMode = acequire("./mode/text").Mode;
	var Range = acequire("./range").Range;
	var Document = acequire("./document").Document;
	var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
	var SearchHighlight = acequire("./search_highlight").SearchHighlight;

	var EditSession = function(text, mode) {
	    this.$breakpoints = [];
	    this.$decorations = [];
	    this.$frontMarkers = {};
	    this.$backMarkers = {};
	    this.$markerId = 1;
	    this.$undoSelect = true;

	    this.$foldData = [];
	    this.$foldData.toString = function() {
	        return this.join("\n");
	    };
	    this.on("changeFold", this.onChangeFold.bind(this));
	    this.$onChange = this.onChange.bind(this);

	    if (typeof text != "object" || !text.getLine)
	        text = new Document(text);

	    this.setDocument(text);
	    this.selection = new Selection(this);

	    config.resetOptions(this);
	    this.setMode(mode);
	    config._signal("session", this);
	};


	(function() {

	    oop.implement(this, EventEmitter);
	    this.setDocument = function(doc) {
	        if (this.doc)
	            this.doc.removeListener("change", this.$onChange);

	        this.doc = doc;
	        doc.on("change", this.$onChange);

	        if (this.bgTokenizer)
	            this.bgTokenizer.setDocument(this.getDocument());

	        this.resetCaches();
	    };
	    this.getDocument = function() {
	        return this.doc;
	    };
	    this.$resetRowCache = function(docRow) {
	        if (!docRow) {
	            this.$docRowCache = [];
	            this.$screenRowCache = [];
	            return;
	        }
	        var l = this.$docRowCache.length;
	        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
	        if (l > i) {
	            this.$docRowCache.splice(i, l);
	            this.$screenRowCache.splice(i, l);
	        }
	    };

	    this.$getRowCacheIndex = function(cacheArray, val) {
	        var low = 0;
	        var hi = cacheArray.length - 1;

	        while (low <= hi) {
	            var mid = (low + hi) >> 1;
	            var c = cacheArray[mid];

	            if (val > c)
	                low = mid + 1;
	            else if (val < c)
	                hi = mid - 1;
	            else
	                return mid;
	        }

	        return low -1;
	    };

	    this.resetCaches = function() {
	        this.$modified = true;
	        this.$wrapData = [];
	        this.$rowLengthCache = [];
	        this.$resetRowCache(0);
	        if (this.bgTokenizer)
	            this.bgTokenizer.start(0);
	    };

	    this.onChangeFold = function(e) {
	        var fold = e.data;
	        this.$resetRowCache(fold.start.row);
	    };

	    this.onChange = function(delta) {
	        this.$modified = true;

	        this.$resetRowCache(delta.start.row);

	        var removedFolds = this.$updateInternalDataOnChange(delta);
	        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
	            this.$deltasDoc.push(delta);
	            if (removedFolds && removedFolds.length != 0) {
	                this.$deltasFold.push({
	                    action: "removeFolds",
	                    folds:  removedFolds
	                });
	            }

	            this.$informUndoManager.schedule();
	        }

	        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
	        this._signal("change", delta);
	    };
	    this.setValue = function(text) {
	        this.doc.setValue(text);
	        this.selection.moveTo(0, 0);

	        this.$resetRowCache(0);
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];
	        this.setUndoManager(this.$undoManager);
	        this.getUndoManager().reset();
	    };
	    this.getValue =
	    this.toString = function() {
	        return this.doc.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.getState = function(row) {
	        return this.bgTokenizer.getState(row);
	    };
	    this.getTokens = function(row) {
	        return this.bgTokenizer.getTokens(row);
	    };
	    this.getTokenAt = function(row, column) {
	        var tokens = this.bgTokenizer.getTokens(row);
	        var token, c = 0;
	        if (column == null) {
	            i = tokens.length - 1;
	            c = this.getLine(row).length;
	        } else {
	            for (var i = 0; i < tokens.length; i++) {
	                c += tokens[i].value.length;
	                if (c >= column)
	                    break;
	            }
	        }
	        token = tokens[i];
	        if (!token)
	            return null;
	        token.index = i;
	        token.start = c - token.value.length;
	        return token;
	    };
	    this.setUndoManager = function(undoManager) {
	        this.$undoManager = undoManager;
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];

	        if (this.$informUndoManager)
	            this.$informUndoManager.cancel();

	        if (undoManager) {
	            var self = this;

	            this.$syncInformUndoManager = function() {
	                self.$informUndoManager.cancel();

	                if (self.$deltasFold.length) {
	                    self.$deltas.push({
	                        group: "fold",
	                        deltas: self.$deltasFold
	                    });
	                    self.$deltasFold = [];
	                }

	                if (self.$deltasDoc.length) {
	                    self.$deltas.push({
	                        group: "doc",
	                        deltas: self.$deltasDoc
	                    });
	                    self.$deltasDoc = [];
	                }

	                if (self.$deltas.length > 0) {
	                    undoManager.execute({
	                        action: "aceupdate",
	                        args: [self.$deltas, self],
	                        merge: self.mergeUndoDeltas
	                    });
	                }
	                self.mergeUndoDeltas = false;
	                self.$deltas = [];
	            };
	            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
	        }
	    };
	    this.markUndoGroup = function() {
	        if (this.$syncInformUndoManager)
	            this.$syncInformUndoManager();
	    };
	    
	    this.$defaultUndoManager = {
	        undo: function() {},
	        redo: function() {},
	        reset: function() {}
	    };
	    this.getUndoManager = function() {
	        return this.$undoManager || this.$defaultUndoManager;
	    };
	    this.getTabString = function() {
	        if (this.getUseSoftTabs()) {
	            return lang.stringRepeat(" ", this.getTabSize());
	        } else {
	            return "\t";
	        }
	    };
	    this.setUseSoftTabs = function(val) {
	        this.setOption("useSoftTabs", val);
	    };
	    this.getUseSoftTabs = function() {
	        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
	    };
	    this.setTabSize = function(tabSize) {
	        this.setOption("tabSize", tabSize);
	    };
	    this.getTabSize = function() {
	        return this.$tabSize;
	    };
	    this.isTabStop = function(position) {
	        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
	    };

	    this.$overwrite = false;
	    this.setOverwrite = function(overwrite) {
	        this.setOption("overwrite", overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.$overwrite;
	    };
	    this.toggleOverwrite = function() {
	        this.setOverwrite(!this.$overwrite);
	    };
	    this.addGutterDecoration = function(row, className) {
	        if (!this.$decorations[row])
	            this.$decorations[row] = "";
	        this.$decorations[row] += " " + className;
	        this._signal("changeBreakpoint", {});
	    };
	    this.removeGutterDecoration = function(row, className) {
	        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
	        this._signal("changeBreakpoint", {});
	    };
	    this.getBreakpoints = function() {
	        return this.$breakpoints;
	    };
	    this.setBreakpoints = function(rows) {
	        this.$breakpoints = [];
	        for (var i=0; i<rows.length; i++) {
	            this.$breakpoints[rows[i]] = "ace_breakpoint";
	        }
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoints = function() {
	        this.$breakpoints = [];
	        this._signal("changeBreakpoint", {});
	    };
	    this.setBreakpoint = function(row, className) {
	        if (className === undefined)
	            className = "ace_breakpoint";
	        if (className)
	            this.$breakpoints[row] = className;
	        else
	            delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoint = function(row) {
	        delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.addMarker = function(range, clazz, type, inFront) {
	        var id = this.$markerId++;

	        var marker = {
	            range : range,
	            type : type || "line",
	            renderer: typeof type == "function" ? type : null,
	            clazz : clazz,
	            inFront: !!inFront,
	            id: id
	        };

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return id;
	    };
	    this.addDynamicMarker = function(marker, inFront) {
	        if (!marker.update)
	            return;
	        var id = this.$markerId++;
	        marker.id = id;
	        marker.inFront = !!inFront;

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return marker;
	    };
	    this.removeMarker = function(markerId) {
	        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
	        if (!marker)
	            return;

	        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
	        if (marker) {
	            delete (markers[markerId]);
	            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
	        }
	    };
	    this.getMarkers = function(inFront) {
	        return inFront ? this.$frontMarkers : this.$backMarkers;
	    };

	    this.highlight = function(re) {
	        if (!this.$searchHighlight) {
	            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
	            this.$searchHighlight = this.addDynamicMarker(highlight);
	        }
	        this.$searchHighlight.setRegexp(re);
	    };
	    this.highlightLines = function(startRow, endRow, clazz, inFront) {
	        if (typeof endRow != "number") {
	            clazz = endRow;
	            endRow = startRow;
	        }
	        if (!clazz)
	            clazz = "ace_step";

	        var range = new Range(startRow, 0, endRow, Infinity);
	        range.id = this.addMarker(range, clazz, "fullLine", inFront);
	        return range;
	    };
	    this.setAnnotations = function(annotations) {
	        this.$annotations = annotations;
	        this._signal("changeAnnotation", {});
	    };
	    this.getAnnotations = function() {
	        return this.$annotations || [];
	    };
	    this.clearAnnotations = function() {
	        this.setAnnotations([]);
	    };
	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r?\n)/m);
	        if (match) {
	            this.$autoNewLine = match[1];
	        } else {
	            this.$autoNewLine = "\n";
	        }
	    };
	    this.getWordRange = function(row, column) {
	        var line = this.getLine(row);

	        var inToken = false;
	        if (column > 0)
	            inToken = !!line.charAt(column - 1).match(this.tokenRe);

	        if (!inToken)
	            inToken = !!line.charAt(column).match(this.tokenRe);

	        if (inToken)
	            var re = this.tokenRe;
	        else if (/^\s+$/.test(line.slice(column-1, column+1)))
	            var re = /\s/;
	        else
	            var re = this.nonTokenRe;

	        var start = column;
	        if (start > 0) {
	            do {
	                start--;
	            }
	            while (start >= 0 && line.charAt(start).match(re));
	            start++;
	        }

	        var end = column;
	        while (end < line.length && line.charAt(end).match(re)) {
	            end++;
	        }

	        return new Range(row, start, row, end);
	    };
	    this.getAWordRange = function(row, column) {
	        var wordRange = this.getWordRange(row, column);
	        var line = this.getLine(wordRange.end.row);

	        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
	            wordRange.end.column += 1;
	        }
	        return wordRange;
	    };
	    this.setNewLineMode = function(newLineMode) {
	        this.doc.setNewLineMode(newLineMode);
	    };
	    this.getNewLineMode = function() {
	        return this.doc.getNewLineMode();
	    };
	    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
	    this.getUseWorker = function() { return this.$useWorker; };
	    this.onReloadTokenizer = function(e) {
	        var rows = e.data;
	        this.bgTokenizer.start(rows.first);
	        this._signal("tokenizerUpdate", e);
	    };

	    this.$modes = {};
	    this.$mode = null;
	    this.$modeId = null;
	    this.setMode = function(mode, cb) {
	        if (mode && typeof mode === "object") {
	            if (mode.getTokenizer)
	                return this.$onChangeMode(mode);
	            var options = mode;
	            var path = options.path;
	        } else {
	            path = mode || "ace/mode/text";
	        }
	        if (!this.$modes["ace/mode/text"])
	            this.$modes["ace/mode/text"] = new TextMode();

	        if (this.$modes[path] && !options) {
	            this.$onChangeMode(this.$modes[path]);
	            cb && cb();
	            return;
	        }
	        this.$modeId = path;
	        config.loadModule(["mode", path], function(m) {
	            if (this.$modeId !== path)
	                return cb && cb();
	            if (this.$modes[path] && !options) {
	                this.$onChangeMode(this.$modes[path]);
	            } else if (m && m.Mode) {
	                m = new m.Mode(options);
	                if (!options) {
	                    this.$modes[path] = m;
	                    m.$id = path;
	                }
	                this.$onChangeMode(m);
	            }
	            cb && cb();
	        }.bind(this));
	        if (!this.$mode)
	            this.$onChangeMode(this.$modes["ace/mode/text"], true);
	    };

	    this.$onChangeMode = function(mode, $isPlaceholder) {
	        if (!$isPlaceholder)
	            this.$modeId = mode.$id;
	        if (this.$mode === mode) 
	            return;

	        this.$mode = mode;

	        this.$stopWorker();

	        if (this.$useWorker)
	            this.$startWorker();

	        var tokenizer = mode.getTokenizer();

	        if(tokenizer.addEventListener !== undefined) {
	            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
	            tokenizer.addEventListener("update", onReloadTokenizer);
	        }

	        if (!this.bgTokenizer) {
	            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
	            var _self = this;
	            this.bgTokenizer.addEventListener("update", function(e) {
	                _self._signal("tokenizerUpdate", e);
	            });
	        } else {
	            this.bgTokenizer.setTokenizer(tokenizer);
	        }

	        this.bgTokenizer.setDocument(this.getDocument());

	        this.tokenRe = mode.tokenRe;
	        this.nonTokenRe = mode.nonTokenRe;

	        
	        if (!$isPlaceholder) {
	            if (mode.attachToSession)
	                mode.attachToSession(this);
	            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
	            this.$setFolding(mode.foldingRules);
	            this.bgTokenizer.start(0);
	            this._emit("changeMode");
	        }
	    };

	    this.$stopWorker = function() {
	        if (this.$worker) {
	            this.$worker.terminate();
	            this.$worker = null;
	        }
	    };

	    this.$startWorker = function() {
	        try {
	            this.$worker = this.$mode.createWorker(this);
	        } catch (e) {
	            config.warn("Could not load worker", e);
	            this.$worker = null;
	        }
	    };
	    this.getMode = function() {
	        return this.$mode;
	    };

	    this.$scrollTop = 0;
	    this.setScrollTop = function(scrollTop) {
	        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
	            return;

	        this.$scrollTop = scrollTop;
	        this._signal("changeScrollTop", scrollTop);
	    };
	    this.getScrollTop = function() {
	        return this.$scrollTop;
	    };

	    this.$scrollLeft = 0;
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
	            return;

	        this.$scrollLeft = scrollLeft;
	        this._signal("changeScrollLeft", scrollLeft);
	    };
	    this.getScrollLeft = function() {
	        return this.$scrollLeft;
	    };
	    this.getScreenWidth = function() {
	        this.$computeWidth();
	        if (this.lineWidgets) 
	            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
	        return this.screenWidth;
	    };
	    
	    this.getLineWidgetMaxWidth = function() {
	        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
	        var width = 0;
	        this.lineWidgets.forEach(function(w) {
	            if (w && w.screenWidth > width)
	                width = w.screenWidth;
	        });
	        return this.lineWidgetWidth = width;
	    };

	    this.$computeWidth = function(force) {
	        if (this.$modified || force) {
	            this.$modified = false;

	            if (this.$useWrapMode)
	                return this.screenWidth = this.$wrapLimit;

	            var lines = this.doc.getAllLines();
	            var cache = this.$rowLengthCache;
	            var longestScreenLine = 0;
	            var foldIndex = 0;
	            var foldLine = this.$foldData[foldIndex];
	            var foldStart = foldLine ? foldLine.start.row : Infinity;
	            var len = lines.length;

	            for (var i = 0; i < len; i++) {
	                if (i > foldStart) {
	                    i = foldLine.end.row + 1;
	                    if (i >= len)
	                        break;
	                    foldLine = this.$foldData[foldIndex++];
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }

	                if (cache[i] == null)
	                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

	                if (cache[i] > longestScreenLine)
	                    longestScreenLine = cache[i];
	            }
	            this.screenWidth = longestScreenLine;
	        }
	    };
	    this.getLine = function(row) {
	        return this.doc.getLine(row);
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.doc.getLines(firstRow, lastRow);
	    };
	    this.getLength = function() {
	        return this.doc.getLength();
	    };
	    this.getTextRange = function(range) {
	        return this.doc.getTextRange(range || this.selection.getRange());
	    };
	    this.insert = function(position, text) {
	        return this.doc.insert(position, text);
	    };
	    this.remove = function(range) {
	        return this.doc.remove(range);
	    };
	    this.removeFullLines = function(firstRow, lastRow){
	        return this.doc.removeFullLines(firstRow, lastRow);
	    };
	    this.undoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = deltas.length - 1; i != -1; i--) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.revertDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
	            } else {
	                delta.deltas.forEach(function(foldDelta) {
	                    this.addFolds(foldDelta.folds);
	                }, this);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.redoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = 0; i < deltas.length; i++) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.applyDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.setUndoSelect = function(enable) {
	        this.$undoSelect = enable;
	    };

	    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
	        function isInsert(delta) {
	            return isUndo ? delta.action !== "insert" : delta.action === "insert";
	        }

	        var delta = deltas[0];
	        var range, point;
	        var lastDeltaIsInsert = false;
	        if (isInsert(delta)) {
	            range = Range.fromPoints(delta.start, delta.end);
	            lastDeltaIsInsert = true;
	        } else {
	            range = Range.fromPoints(delta.start, delta.start);
	            lastDeltaIsInsert = false;
	        }

	        for (var i = 1; i < deltas.length; i++) {
	            delta = deltas[i];
	            if (isInsert(delta)) {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range.setStart(point);
	                }
	                point = delta.end;
	                if (range.compare(point.row, point.column) == 1) {
	                    range.setEnd(point);
	                }
	                lastDeltaIsInsert = true;
	            } else {
	                point = delta.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range = Range.fromPoints(delta.start, delta.start);
	                }
	                lastDeltaIsInsert = false;
	            }
	        }
	        if (lastUndoRange != null) {
	            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
	                lastUndoRange.start.column += range.end.column - range.start.column;
	                lastUndoRange.end.column += range.end.column - range.start.column;
	            }

	            var cmp = lastUndoRange.compareRange(range);
	            if (cmp == 1) {
	                range.setStart(lastUndoRange.start);
	            } else if (cmp == -1) {
	                range.setEnd(lastUndoRange.end);
	            }
	        }

	        return range;
	    };
	    this.replace = function(range, text) {
	        return this.doc.replace(range, text);
	    };
	    this.moveText = function(fromRange, toPosition, copy) {
	        var text = this.getTextRange(fromRange);
	        var folds = this.getFoldsInRange(fromRange);

	        var toRange = Range.fromPoints(toPosition, toPosition);
	        if (!copy) {
	            this.remove(fromRange);
	            var rowDiff = fromRange.start.row - fromRange.end.row;
	            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
	            if (collDiff) {
	                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
	                    toRange.start.column += collDiff;
	                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
	                    toRange.end.column += collDiff;
	            }
	            if (rowDiff && toRange.start.row >= fromRange.end.row) {
	                toRange.start.row += rowDiff;
	                toRange.end.row += rowDiff;
	            }
	        }

	        toRange.end = this.insert(toRange.start, text);
	        if (folds.length) {
	            var oldStart = fromRange.start;
	            var newStart = toRange.start;
	            var rowDiff = newStart.row - oldStart.row;
	            var collDiff = newStart.column - oldStart.column;
	            this.addFolds(folds.map(function(x) {
	                x = x.clone();
	                if (x.start.row == oldStart.row)
	                    x.start.column += collDiff;
	                if (x.end.row == oldStart.row)
	                    x.end.column += collDiff;
	                x.start.row += rowDiff;
	                x.end.row += rowDiff;
	                return x;
	            }));
	        }

	        return toRange;
	    };
	    this.indentRows = function(startRow, endRow, indentString) {
	        indentString = indentString.replace(/\t/g, this.getTabString());
	        for (var row=startRow; row<=endRow; row++)
	            this.doc.insertInLine({row: row, column: 0}, indentString);
	    };
	    this.outdentRows = function (range) {
	        var rowRange = range.collapseRows();
	        var deleteRange = new Range(0, 0, 0, 0);
	        var size = this.getTabSize();

	        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
	            var line = this.getLine(i);

	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            for (var j = 0; j < size; ++j)
	                if (line.charAt(j) != ' ')
	                    break;
	            if (j < size && line.charAt(j) == '\t') {
	                deleteRange.start.column = j;
	                deleteRange.end.column = j + 1;
	            } else {
	                deleteRange.start.column = 0;
	                deleteRange.end.column = j;
	            }
	            this.remove(deleteRange);
	        }
	    };

	    this.$moveLines = function(firstRow, lastRow, dir) {
	        firstRow = this.getRowFoldStart(firstRow);
	        lastRow = this.getRowFoldEnd(lastRow);
	        if (dir < 0) {
	            var row = this.getRowFoldStart(firstRow + dir);
	            if (row < 0) return 0;
	            var diff = row-firstRow;
	        } else if (dir > 0) {
	            var row = this.getRowFoldEnd(lastRow + dir);
	            if (row > this.doc.getLength()-1) return 0;
	            var diff = row-lastRow;
	        } else {
	            firstRow = this.$clipRowToDocument(firstRow);
	            lastRow = this.$clipRowToDocument(lastRow);
	            var diff = lastRow - firstRow + 1;
	        }

	        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
	        var folds = this.getFoldsInRange(range).map(function(x){
	            x = x.clone();
	            x.start.row += diff;
	            x.end.row += diff;
	            return x;
	        });
	        
	        var lines = dir == 0
	            ? this.doc.getLines(firstRow, lastRow)
	            : this.doc.removeFullLines(firstRow, lastRow);
	        this.doc.insertFullLines(firstRow+diff, lines);
	        folds.length && this.addFolds(folds);
	        return diff;
	    };
	    this.moveLinesUp = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, -1);
	    };
	    this.moveLinesDown = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 1);
	    };
	    this.duplicateLines = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 0);
	    };


	    this.$clipRowToDocument = function(row) {
	        return Math.max(0, Math.min(row, this.doc.getLength()-1));
	    };

	    this.$clipColumnToRow = function(row, column) {
	        if (column < 0)
	            return 0;
	        return Math.min(this.doc.getLine(row).length, column);
	    };


	    this.$clipPositionToDocument = function(row, column) {
	        column = Math.max(0, column);

	        if (row < 0) {
	            row = 0;
	            column = 0;
	        } else {
	            var len = this.doc.getLength();
	            if (row >= len) {
	                row = len - 1;
	                column = this.doc.getLine(len-1).length;
	            } else {
	                column = Math.min(this.doc.getLine(row).length, column);
	            }
	        }

	        return {
	            row: row,
	            column: column
	        };
	    };

	    this.$clipRangeToDocument = function(range) {
	        if (range.start.row < 0) {
	            range.start.row = 0;
	            range.start.column = 0;
	        } else {
	            range.start.column = this.$clipColumnToRow(
	                range.start.row,
	                range.start.column
	            );
	        }

	        var len = this.doc.getLength() - 1;
	        if (range.end.row > len) {
	            range.end.row = len;
	            range.end.column = this.doc.getLine(len).length;
	        } else {
	            range.end.column = this.$clipColumnToRow(
	                range.end.row,
	                range.end.column
	            );
	        }
	        return range;
	    };
	    this.$wrapLimit = 80;
	    this.$useWrapMode = false;
	    this.$wrapLimitRange = {
	        min : null,
	        max : null
	    };
	    this.setUseWrapMode = function(useWrapMode) {
	        if (useWrapMode != this.$useWrapMode) {
	            this.$useWrapMode = useWrapMode;
	            this.$modified = true;
	            this.$resetRowCache(0);
	            if (useWrapMode) {
	                var len = this.getLength();
	                this.$wrapData = Array(len);
	                this.$updateWrapData(0, len - 1);
	            }

	            this._signal("changeWrapMode");
	        }
	    };
	    this.getUseWrapMode = function() {
	        return this.$useWrapMode;
	    };
	    this.setWrapLimitRange = function(min, max) {
	        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
	            this.$wrapLimitRange = { min: min, max: max };
	            this.$modified = true;
	            if (this.$useWrapMode)
	                this._signal("changeWrapMode");
	        }
	    };
	    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
	        var limits = this.$wrapLimitRange;
	        if (limits.max < 0)
	            limits = {min: $printMargin, max: $printMargin};
	        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
	        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
	            this.$wrapLimit = wrapLimit;
	            this.$modified = true;
	            if (this.$useWrapMode) {
	                this.$updateWrapData(0, this.getLength() - 1);
	                this.$resetRowCache(0);
	                this._signal("changeWrapLimit");
	            }
	            return true;
	        }
	        return false;
	    };

	    this.$constrainWrapLimit = function(wrapLimit, min, max) {
	        if (min)
	            wrapLimit = Math.max(min, wrapLimit);

	        if (max)
	            wrapLimit = Math.min(max, wrapLimit);

	        return wrapLimit;
	    };
	    this.getWrapLimit = function() {
	        return this.$wrapLimit;
	    };
	    this.setWrapLimit = function (limit) {
	        this.setWrapLimitRange(limit, limit);
	    };
	    this.getWrapLimitRange = function() {
	        return {
	            min : this.$wrapLimitRange.min,
	            max : this.$wrapLimitRange.max
	        };
	    };

	    this.$updateInternalDataOnChange = function(delta) {
	        var useWrapMode = this.$useWrapMode;
	        var action = delta.action;
	        var start = delta.start;
	        var end = delta.end;
	        var firstRow = start.row;
	        var lastRow = end.row;
	        var len = lastRow - firstRow;
	        var removedFolds = null;
	        
	        this.$updating = true;
	        if (len != 0) {
	            if (action === "remove") {
	                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

	                var foldLines = this.$foldData;
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);

	                var foldLine = this.getFoldLine(end.row);
	                var idx = 0;
	                if (foldLine) {
	                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
	                    foldLine.shiftRow(-len);

	                    var foldLineBefore = this.getFoldLine(firstRow);
	                    if (foldLineBefore && foldLineBefore !== foldLine) {
	                        foldLineBefore.merge(foldLine);
	                        foldLine = foldLineBefore;
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= end.row) {
	                        foldLine.shiftRow(-len);
	                    }
	                }

	                lastRow = firstRow;
	            } else {
	                var args = Array(len);
	                args.unshift(firstRow, 0);
	                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
	                arr.splice.apply(arr, args);
	                var foldLines = this.$foldData;
	                var foldLine = this.getFoldLine(firstRow);
	                var idx = 0;
	                if (foldLine) {
	                    var cmp = foldLine.range.compareInside(start.row, start.column);
	                    if (cmp == 0) {
	                        foldLine = foldLine.split(start.row, start.column);
	                        if (foldLine) {
	                            foldLine.shiftRow(len);
	                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
	                        }
	                    } else
	                    if (cmp == -1) {
	                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
	                        foldLine.shiftRow(len);
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= firstRow) {
	                        foldLine.shiftRow(len);
	                    }
	                }
	            }
	        } else {
	            len = Math.abs(delta.start.column - delta.end.column);
	            if (action === "remove") {
	                removedFolds = this.getFoldsInRange(delta);
	                this.removeFolds(removedFolds);

	                len = -len;
	            }
	            var foldLine = this.getFoldLine(firstRow);
	            if (foldLine) {
	                foldLine.addRemoveChars(firstRow, start.column, len);
	            }
	        }

	        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
	            console.error("doc.getLength() and $wrapData.length have to be the same!");
	        }
	        this.$updating = false;

	        if (useWrapMode)
	            this.$updateWrapData(firstRow, lastRow);
	        else
	            this.$updateRowLengthCache(firstRow, lastRow);

	        return removedFolds;
	    };

	    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
	        this.$rowLengthCache[firstRow] = null;
	        this.$rowLengthCache[lastRow] = null;
	    };

	    this.$updateWrapData = function(firstRow, lastRow) {
	        var lines = this.doc.getAllLines();
	        var tabSize = this.getTabSize();
	        var wrapData = this.$wrapData;
	        var wrapLimit = this.$wrapLimit;
	        var tokens;
	        var foldLine;

	        var row = firstRow;
	        lastRow = Math.min(lastRow, lines.length - 1);
	        while (row <= lastRow) {
	            foldLine = this.getFoldLine(row, foldLine);
	            if (!foldLine) {
	                tokens = this.$getDisplayTokens(lines[row]);
	                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row ++;
	            } else {
	                tokens = [];
	                foldLine.walk(function(placeholder, row, column, lastColumn) {
	                        var walkTokens;
	                        if (placeholder != null) {
	                            walkTokens = this.$getDisplayTokens(
	                                            placeholder, tokens.length);
	                            walkTokens[0] = PLACEHOLDER_START;
	                            for (var i = 1; i < walkTokens.length; i++) {
	                                walkTokens[i] = PLACEHOLDER_BODY;
	                            }
	                        } else {
	                            walkTokens = this.$getDisplayTokens(
	                                lines[row].substring(lastColumn, column),
	                                tokens.length);
	                        }
	                        tokens = tokens.concat(walkTokens);
	                    }.bind(this),
	                    foldLine.end.row,
	                    lines[foldLine.end.row].length + 1
	                );

	                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row = foldLine.end.row + 1;
	            }
	        }
	    };
	    var CHAR = 1,
	        CHAR_EXT = 2,
	        PLACEHOLDER_START = 3,
	        PLACEHOLDER_BODY =  4,
	        PUNCTUATION = 9,
	        SPACE = 10,
	        TAB = 11,
	        TAB_SPACE = 12;


	    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
	        if (tokens.length == 0) {
	            return [];
	        }

	        var splits = [];
	        var displayLength = tokens.length;
	        var lastSplit = 0, lastDocSplit = 0;

	        var isCode = this.$wrapAsCode;

	        var indentedSoftWrap = this.$indentedSoftWrap;
	        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
	            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

	        function getWrapIndent() {
	            var indentation = 0;
	            if (maxIndent === 0)
	                return indentation;
	            if (indentedSoftWrap) {
	                for (var i = 0; i < tokens.length; i++) {
	                    var token = tokens[i];
	                    if (token == SPACE)
	                        indentation += 1;
	                    else if (token == TAB)
	                        indentation += tabSize;
	                    else if (token == TAB_SPACE)
	                        continue;
	                    else
	                        break;
	                }
	            }
	            if (isCode && indentedSoftWrap !== false)
	                indentation += tabSize;
	            return Math.min(indentation, maxIndent);
	        }
	        function addSplit(screenPos) {
	            var displayed = tokens.slice(lastSplit, screenPos);
	            var len = displayed.length;
	            displayed.join("")
	                .replace(/12/g, function() {
	                    len -= 1;
	                })
	                .replace(/2/g, function() {
	                    len -= 1;
	                });

	            if (!splits.length) {
	                indent = getWrapIndent();
	                splits.indent = indent;
	            }
	            lastDocSplit += len;
	            splits.push(lastDocSplit);
	            lastSplit = screenPos;
	        }
	        var indent = 0;
	        while (displayLength - lastSplit > wrapLimit - indent) {
	            var split = lastSplit + wrapLimit - indent;
	            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
	                addSplit(split);
	                continue;
	            }
	            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
	                for (split; split != lastSplit - 1; split--) {
	                    if (tokens[split] == PLACEHOLDER_START) {
	                        break;
	                    }
	                }
	                if (split > lastSplit) {
	                    addSplit(split);
	                    continue;
	                }
	                split = lastSplit + wrapLimit;
	                for (split; split < tokens.length; split++) {
	                    if (tokens[split] != PLACEHOLDER_BODY) {
	                        break;
	                    }
	                }
	                if (split == tokens.length) {
	                    break;  // Breaks the while-loop.
	                }
	                addSplit(split);
	                continue;
	            }
	            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
	            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                split --;
	            }
	            if (isCode) {
	                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                    split --;
	                }
	                while (split > minSplit && tokens[split] == PUNCTUATION) {
	                    split --;
	                }
	            } else {
	                while (split > minSplit && tokens[split] < SPACE) {
	                    split --;
	                }
	            }
	            if (split > minSplit) {
	                addSplit(++split);
	                continue;
	            }
	            split = lastSplit + wrapLimit;
	            if (tokens[split] == CHAR_EXT)
	                split--;
	            addSplit(split - indent);
	        }
	        return splits;
	    };
	    this.$getDisplayTokens = function(str, offset) {
	        var arr = [];
	        var tabSize;
	        offset = offset || 0;

	        for (var i = 0; i < str.length; i++) {
	            var c = str.charCodeAt(i);
	            if (c == 9) {
	                tabSize = this.getScreenTabSize(arr.length + offset);
	                arr.push(TAB);
	                for (var n = 1; n < tabSize; n++) {
	                    arr.push(TAB_SPACE);
	                }
	            }
	            else if (c == 32) {
	                arr.push(SPACE);
	            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
	                arr.push(PUNCTUATION);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                arr.push(CHAR, CHAR_EXT);
	            } else {
	                arr.push(CHAR);
	            }
	        }
	        return arr;
	    };
	    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
	        if (maxScreenColumn == 0)
	            return [0, 0];
	        if (maxScreenColumn == null)
	            maxScreenColumn = Infinity;
	        screenColumn = screenColumn || 0;

	        var c, column;
	        for (column = 0; column < str.length; column++) {
	            c = str.charCodeAt(column);
	            if (c == 9) {
	                screenColumn += this.getScreenTabSize(screenColumn);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                screenColumn += 2;
	            } else {
	                screenColumn += 1;
	            }
	            if (screenColumn > maxScreenColumn) {
	                break;
	            }
	        }

	        return [screenColumn, column];
	    };

	    this.lineWidgets = null;
	    this.getRowLength = function(row) {
	        if (this.lineWidgets)
	            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };
	    this.getRowLineCount = function(row) {
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1;
	        } else {
	            return this.$wrapData[row].length + 1;
	        }
	    };

	    this.getRowWrapIndent = function(screenRow) {
	        if (this.$useWrapMode) {
	            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	            var splits = this.$wrapData[pos.row];
	            return splits.length && splits[0] < pos.column ? splits.indent : 0;
	        } else {
	            return 0;
	        }
	    }
	    this.getScreenLastRowColumn = function(screenRow) {
	        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	        return this.documentToScreenColumn(pos.row, pos.column);
	    };
	    this.getDocumentLastRowColumn = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.getScreenLastRowColumn(screenRow);
	    };
	    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
	    };
	    this.getRowSplitData = function(row) {
	        if (!this.$useWrapMode) {
	            return undefined;
	        } else {
	            return this.$wrapData[row];
	        }
	    };
	    this.getScreenTabSize = function(screenColumn) {
	        return this.$tabSize - screenColumn % this.$tabSize;
	    };


	    this.screenToDocumentRow = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).row;
	    };


	    this.screenToDocumentColumn = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).column;
	    };
	    this.screenToDocumentPosition = function(screenRow, screenColumn) {
	        if (screenRow < 0)
	            return {row: 0, column: 0};

	        var line;
	        var docRow = 0;
	        var docColumn = 0;
	        var column;
	        var row = 0;
	        var rowLength = 0;

	        var rowCache = this.$screenRowCache;
	        var i = this.$getRowCacheIndex(rowCache, screenRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var docRow = this.$docRowCache[i];
	            var doCache = screenRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var maxRow = this.getLength() - 1;
	        var foldLine = this.getNextFoldLine(docRow);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (row <= screenRow) {
	            rowLength = this.getRowLength(docRow);
	            if (row + rowLength > screenRow || docRow >= maxRow) {
	                break;
	            } else {
	                row += rowLength;
	                docRow++;
	                if (docRow > foldStart) {
	                    docRow = foldLine.end.row+1;
	                    foldLine = this.getNextFoldLine(docRow, foldLine);
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }
	            }

	            if (doCache) {
	                this.$docRowCache.push(docRow);
	                this.$screenRowCache.push(row);
	            }
	        }

	        if (foldLine && foldLine.start.row <= docRow) {
	            line = this.getFoldDisplayLine(foldLine);
	            docRow = foldLine.start.row;
	        } else if (row + rowLength <= screenRow || docRow > maxRow) {
	            return {
	                row: maxRow,
	                column: this.getLine(maxRow).length
	            };
	        } else {
	            line = this.getLine(docRow);
	            foldLine = null;
	        }
	        var wrapIndent = 0;
	        if (this.$useWrapMode) {
	            var splits = this.$wrapData[docRow];
	            if (splits) {
	                var splitIndex = Math.floor(screenRow - row);
	                column = splits[splitIndex];
	                if(splitIndex > 0 && splits.length) {
	                    wrapIndent = splits.indent;
	                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
	                    line = line.substring(docColumn);
	                }
	            }
	        }

	        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
	        if (this.$useWrapMode && docColumn >= column)
	            docColumn = column - 1;

	        if (foldLine)
	            return foldLine.idxToPosition(docColumn);

	        return {row: docRow, column: docColumn};
	    };
	    this.documentToScreenPosition = function(docRow, docColumn) {
	        if (typeof docColumn === "undefined")
	            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
	        else
	            pos = this.$clipPositionToDocument(docRow, docColumn);

	        docRow = pos.row;
	        docColumn = pos.column;

	        var screenRow = 0;
	        var foldStartRow = null;
	        var fold = null;
	        fold = this.getFoldAt(docRow, docColumn, 1);
	        if (fold) {
	            docRow = fold.start.row;
	            docColumn = fold.start.column;
	        }

	        var rowEnd, row = 0;


	        var rowCache = this.$docRowCache;
	        var i = this.$getRowCacheIndex(rowCache, docRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var screenRow = this.$screenRowCache[i];
	            var doCache = docRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var foldLine = this.getNextFoldLine(row);
	        var foldStart = foldLine ?foldLine.start.row :Infinity;

	        while (row < docRow) {
	            if (row >= foldStart) {
	                rowEnd = foldLine.end.row + 1;
	                if (rowEnd > docRow)
	                    break;
	                foldLine = this.getNextFoldLine(rowEnd, foldLine);
	                foldStart = foldLine ?foldLine.start.row :Infinity;
	            }
	            else {
	                rowEnd = row + 1;
	            }

	            screenRow += this.getRowLength(row);
	            row = rowEnd;

	            if (doCache) {
	                this.$docRowCache.push(row);
	                this.$screenRowCache.push(screenRow);
	            }
	        }
	        var textLine = "";
	        if (foldLine && row >= foldStart) {
	            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
	            foldStartRow = foldLine.start.row;
	        } else {
	            textLine = this.getLine(docRow).substring(0, docColumn);
	            foldStartRow = docRow;
	        }
	        var wrapIndent = 0;
	        if (this.$useWrapMode) {
	            var wrapRow = this.$wrapData[foldStartRow];
	            if (wrapRow) {
	                var screenRowOffset = 0;
	                while (textLine.length >= wrapRow[screenRowOffset]) {
	                    screenRow ++;
	                    screenRowOffset++;
	                }
	                textLine = textLine.substring(
	                    wrapRow[screenRowOffset - 1] || 0, textLine.length
	                );
	                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
	            }
	        }

	        return {
	            row: screenRow,
	            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
	        };
	    };
	    this.documentToScreenColumn = function(row, docColumn) {
	        return this.documentToScreenPosition(row, docColumn).column;
	    };
	    this.documentToScreenRow = function(docRow, docColumn) {
	        return this.documentToScreenPosition(docRow, docColumn).row;
	    };
	    this.getScreenLength = function() {
	        var screenRows = 0;
	        var fold = null;
	        if (!this.$useWrapMode) {
	            screenRows = this.getLength();
	            var foldData = this.$foldData;
	            for (var i = 0; i < foldData.length; i++) {
	                fold = foldData[i];
	                screenRows -= fold.end.row - fold.start.row;
	            }
	        } else {
	            var lastRow = this.$wrapData.length;
	            var row = 0, i = 0;
	            var fold = this.$foldData[i++];
	            var foldStart = fold ? fold.start.row :Infinity;

	            while (row < lastRow) {
	                var splits = this.$wrapData[row];
	                screenRows += splits ? splits.length + 1 : 1;
	                row ++;
	                if (row > foldStart) {
	                    row = fold.end.row+1;
	                    fold = this.$foldData[i++];
	                    foldStart = fold ?fold.start.row :Infinity;
	                }
	            }
	        }
	        if (this.lineWidgets)
	            screenRows += this.$getWidgetScreenLength();

	        return screenRows;
	    };
	    this.$setFontMetrics = function(fm) {
	        if (!this.$enableVarChar) return;
	        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
	            if (maxScreenColumn === 0)
	                return [0, 0];
	            if (!maxScreenColumn)
	                maxScreenColumn = Infinity;
	            screenColumn = screenColumn || 0;
	            
	            var c, column;
	            for (column = 0; column < str.length; column++) {
	                c = str.charAt(column);
	                if (c === "\t") {
	                    screenColumn += this.getScreenTabSize(screenColumn);
	                } else {
	                    screenColumn += fm.getCharacterWidth(c);
	                }
	                if (screenColumn > maxScreenColumn) {
	                    break;
	                }
	            }
	            
	            return [screenColumn, column];
	        };
	    };
	    
	    this.destroy = function() {
	        if (this.bgTokenizer) {
	            this.bgTokenizer.setDocument(null);
	            this.bgTokenizer = null;
	        }
	        this.$stopWorker();
	    };
	    function isFullWidth(c) {
	        if (c < 0x1100)
	            return false;
	        return c >= 0x1100 && c <= 0x115F ||
	               c >= 0x11A3 && c <= 0x11A7 ||
	               c >= 0x11FA && c <= 0x11FF ||
	               c >= 0x2329 && c <= 0x232A ||
	               c >= 0x2E80 && c <= 0x2E99 ||
	               c >= 0x2E9B && c <= 0x2EF3 ||
	               c >= 0x2F00 && c <= 0x2FD5 ||
	               c >= 0x2FF0 && c <= 0x2FFB ||
	               c >= 0x3000 && c <= 0x303E ||
	               c >= 0x3041 && c <= 0x3096 ||
	               c >= 0x3099 && c <= 0x30FF ||
	               c >= 0x3105 && c <= 0x312D ||
	               c >= 0x3131 && c <= 0x318E ||
	               c >= 0x3190 && c <= 0x31BA ||
	               c >= 0x31C0 && c <= 0x31E3 ||
	               c >= 0x31F0 && c <= 0x321E ||
	               c >= 0x3220 && c <= 0x3247 ||
	               c >= 0x3250 && c <= 0x32FE ||
	               c >= 0x3300 && c <= 0x4DBF ||
	               c >= 0x4E00 && c <= 0xA48C ||
	               c >= 0xA490 && c <= 0xA4C6 ||
	               c >= 0xA960 && c <= 0xA97C ||
	               c >= 0xAC00 && c <= 0xD7A3 ||
	               c >= 0xD7B0 && c <= 0xD7C6 ||
	               c >= 0xD7CB && c <= 0xD7FB ||
	               c >= 0xF900 && c <= 0xFAFF ||
	               c >= 0xFE10 && c <= 0xFE19 ||
	               c >= 0xFE30 && c <= 0xFE52 ||
	               c >= 0xFE54 && c <= 0xFE66 ||
	               c >= 0xFE68 && c <= 0xFE6B ||
	               c >= 0xFF01 && c <= 0xFF60 ||
	               c >= 0xFFE0 && c <= 0xFFE6;
	    }

	}).call(EditSession.prototype);

	acequire("./edit_session/folding").Folding.call(EditSession.prototype);
	acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


	config.defineOptions(EditSession.prototype, "session", {
	    wrap: {
	        set: function(value) {
	            if (!value || value == "off")
	                value = false;
	            else if (value == "free")
	                value = true;
	            else if (value == "printMargin")
	                value = -1;
	            else if (typeof value == "string")
	                value = parseInt(value, 10) || false;

	            if (this.$wrap == value)
	                return;
	            this.$wrap = value;
	            if (!value) {
	                this.setUseWrapMode(false);
	            } else {
	                var col = typeof value == "number" ? value : null;
	                this.setWrapLimitRange(col, col);
	                this.setUseWrapMode(true);
	            }
	        },
	        get: function() {
	            if (this.getUseWrapMode()) {
	                if (this.$wrap == -1)
	                    return "printMargin";
	                if (!this.getWrapLimitRange().min)
	                    return "free";
	                return this.$wrap;
	            }
	            return "off";
	        },
	        handlesSet: true
	    },    
	    wrapMethod: {
	        set: function(val) {
	            val = val == "auto"
	                ? this.$mode.type != "text"
	                : val != "text";
	            if (val != this.$wrapAsCode) {
	                this.$wrapAsCode = val;
	                if (this.$useWrapMode) {
	                    this.$modified = true;
	                    this.$resetRowCache(0);
	                    this.$updateWrapData(0, this.getLength() - 1);
	                }
	            }
	        },
	        initialValue: "auto"
	    },
	    indentedSoftWrap: { initialValue: true },
	    firstLineNumber: {
	        set: function() {this._signal("changeBreakpoint");},
	        initialValue: 1
	    },
	    useWorker: {
	        set: function(useWorker) {
	            this.$useWorker = useWorker;

	            this.$stopWorker();
	            if (useWorker)
	                this.$startWorker();
	        },
	        initialValue: true
	    },
	    useSoftTabs: {initialValue: true},
	    tabSize: {
	        set: function(tabSize) {
	            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

	            this.$modified = true;
	            this.$rowLengthCache = [];
	            this.$tabSize = tabSize;
	            this._signal("changeTabSize");
	        },
	        initialValue: 4,
	        handlesSet: true
	    },
	    overwrite: {
	        set: function(val) {this._signal("changeOverwrite");},
	        initialValue: false
	    },
	    newLineMode: {
	        set: function(val) {this.doc.setNewLineMode(val)},
	        get: function() {return this.doc.getNewLineMode()},
	        handlesSet: true
	    },
	    mode: {
	        set: function(val) { this.setMode(val) },
	        get: function() { return this.$modeId }
	    }
	});

	exports.EditSession = EditSession;
	});

	ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var Search = function() {
	    this.$options = {};
	};

	(function() {
	    this.set = function(options) {
	        oop.mixin(this.$options, options);
	        return this;
	    };
	    this.getOptions = function() {
	        return lang.copyObject(this.$options);
	    };
	    this.setOptions = function(options) {
	        this.$options = options;
	    };
	    this.find = function(session) {
	        var options = this.$options;
	        var iterator = this.$matchIterator(session, options);
	        if (!iterator)
	            return false;

	        var firstRange = null;
	        iterator.forEach(function(range, row, offset) {
	            if (!range.start) {
	                var column = range.offset + (offset || 0);
	                firstRange = new Range(row, column, row, column + range.length);
	                if (!range.length && options.start && options.start.start
	                    && options.skipCurrent != false && firstRange.isEqual(options.start)
	                ) {
	                    firstRange = null;
	                    return false;
	                }
	            } else
	                firstRange = range;
	            return true;
	        });

	        return firstRange;
	    };
	    this.findAll = function(session) {
	        var options = this.$options;
	        if (!options.needle)
	            return [];
	        this.$assembleRegExp(options);

	        var range = options.range;
	        var lines = range
	            ? session.getLines(range.start.row, range.end.row)
	            : session.doc.getAllLines();

	        var ranges = [];
	        var re = options.re;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var maxRow = lines.length - len;
	            var prevRange;
	            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
	                for (var j = 0; j < len; j++)
	                    if (lines[row + j].search(re[j]) == -1)
	                        continue outer;
	                
	                var startLine = lines[row];
	                var line = lines[row + len - 1];
	                var startIndex = startLine.length - startLine.match(re[0])[0].length;
	                var endIndex = line.match(re[len - 1])[0].length;
	                
	                if (prevRange && prevRange.end.row === row &&
	                    prevRange.end.column > startIndex
	                ) {
	                    continue;
	                }
	                ranges.push(prevRange = new Range(
	                    row, startIndex, row + len - 1, endIndex
	                ));
	                if (len > 2)
	                    row = row + len - 2;
	            }
	        } else {
	            for (var i = 0; i < lines.length; i++) {
	                var matches = lang.getMatchOffsets(lines[i], re);
	                for (var j = 0; j < matches.length; j++) {
	                    var match = matches[j];
	                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
	                }
	            }
	        }

	        if (range) {
	            var startColumn = range.start.column;
	            var endColumn = range.start.column;
	            var i = 0, j = ranges.length - 1;
	            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
	                i++;

	            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
	                j--;
	            
	            ranges = ranges.slice(i, j + 1);
	            for (i = 0, j = ranges.length; i < j; i++) {
	                ranges[i].start.row += range.start.row;
	                ranges[i].end.row += range.start.row;
	            }
	        }

	        return ranges;
	    };
	    this.replace = function(input, replacement) {
	        var options = this.$options;

	        var re = this.$assembleRegExp(options);
	        if (options.$isMultiLine)
	            return replacement;

	        if (!re)
	            return;

	        var match = re.exec(input);
	        if (!match || match[0].length != input.length)
	            return null;
	        
	        replacement = input.replace(re, replacement);
	        if (options.preserveCase) {
	            replacement = replacement.split("");
	            for (var i = Math.min(input.length, input.length); i--; ) {
	                var ch = input[i];
	                if (ch && ch.toLowerCase() != ch)
	                    replacement[i] = replacement[i].toUpperCase();
	                else
	                    replacement[i] = replacement[i].toLowerCase();
	            }
	            replacement = replacement.join("");
	        }
	        
	        return replacement;
	    };

	    this.$matchIterator = function(session, options) {
	        var re = this.$assembleRegExp(options);
	        if (!re)
	            return false;

	        var callback;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var matchIterator = function(line, row, offset) {
	                var startIndex = line.search(re[0]);
	                if (startIndex == -1)
	                    return;
	                for (var i = 1; i < len; i++) {
	                    line = session.getLine(row + i);
	                    if (line.search(re[i]) == -1)
	                        return;
	                }

	                var endIndex = line.match(re[len - 1])[0].length;

	                var range = new Range(row, startIndex, row + len - 1, endIndex);
	                if (re.offset == 1) {
	                    range.start.row--;
	                    range.start.column = Number.MAX_VALUE;
	                } else if (offset)
	                    range.start.column += offset;

	                if (callback(range))
	                    return true;
	            };
	        } else if (options.backwards) {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = matches.length-1; i >= 0; i--)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        } else {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = 0; i < matches.length; i++)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        }
	        
	        var lineIterator = this.$lineIterator(session, options);

	        return {
	            forEach: function(_callback) {
	                callback = _callback;
	                lineIterator.forEach(matchIterator);
	            }
	        };
	    };

	    this.$assembleRegExp = function(options, $disableFakeMultiline) {
	        if (options.needle instanceof RegExp)
	            return options.re = options.needle;

	        var needle = options.needle;

	        if (!options.needle)
	            return options.re = false;

	        if (!options.regExp)
	            needle = lang.escapeRegExp(needle);

	        if (options.wholeWord)
	            needle = "\\b" + needle + "\\b";

	        var modifier = options.caseSensitive ? "gm" : "gmi";

	        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
	        if (options.$isMultiLine)
	            return options.re = this.$assembleMultilineRegExp(needle, modifier);

	        try {
	            var re = new RegExp(needle, modifier);
	        } catch(e) {
	            re = false;
	        }
	        return options.re = re;
	    };

	    this.$assembleMultilineRegExp = function(needle, modifier) {
	        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
	        var re = [];
	        for (var i = 0; i < parts.length; i++) try {
	            re.push(new RegExp(parts[i], modifier));
	        } catch(e) {
	            return false;
	        }
	        if (parts[0] == "") {
	            re.shift();
	            re.offset = 1;
	        } else {
	            re.offset = 0;
	        }
	        return re;
	    };

	    this.$lineIterator = function(session, options) {
	        var backwards = options.backwards == true;
	        var skipCurrent = options.skipCurrent != false;

	        var range = options.range;
	        var start = options.start;
	        if (!start)
	            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
	         
	        if (start.start)
	            start = start[skipCurrent != backwards ? "end" : "start"];

	        var firstRow = range ? range.start.row : 0;
	        var lastRow = range ? range.end.row : session.getLength() - 1;

	        var forEach = backwards ? function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substring(0, start.column);
	                if (callback(line, row))
	                    return;

	                for (row--; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;
	            } : function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substr(start.column);
	                if (callback(line, row, start.column))
	                    return;

	                for (row = row+1; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;
	            };
	        
	        return {forEach: forEach};
	    };

	}).call(Search.prototype);

	exports.Search = Search;
	});

	ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keyUtil = acequire("../lib/keys");
	var useragent = acequire("../lib/useragent");
	var KEY_MODS = keyUtil.KEY_MODS;

	function HashHandler(config, platform) {
	    this.platform = platform || (useragent.isMac ? "mac" : "win");
	    this.commands = {};
	    this.commandKeyBinding = {};
	    this.addCommands(config);
	    this.$singleCommand = true;
	}

	function MultiHashHandler(config, platform) {
	    HashHandler.call(this, config, platform);
	    this.$singleCommand = false;
	}

	MultiHashHandler.prototype = HashHandler.prototype;

	(function() {
	    

	    this.addCommand = function(command) {
	        if (this.commands[command.name])
	            this.removeCommand(command);

	        this.commands[command.name] = command;

	        if (command.bindKey)
	            this._buildKeyHash(command);
	    };

	    this.removeCommand = function(command, keepCommand) {
	        var name = command && (typeof command === 'string' ? command : command.name);
	        command = this.commands[name];
	        if (!keepCommand)
	            delete this.commands[name];
	        var ckb = this.commandKeyBinding;
	        for (var keyId in ckb) {
	            var cmdGroup = ckb[keyId];
	            if (cmdGroup == command) {
	                delete ckb[keyId];
	            } else if (Array.isArray(cmdGroup)) {
	                var i = cmdGroup.indexOf(command);
	                if (i != -1) {
	                    cmdGroup.splice(i, 1);
	                    if (cmdGroup.length == 1)
	                        ckb[keyId] = cmdGroup[0];
	                }
	            }
	        }
	    };

	    this.bindKey = function(key, command, position) {
	        if (typeof key == "object" && key) {
	            if (position == undefined)
	                position = key.position;
	            key = key[this.platform];
	        }
	        if (!key)
	            return;
	        if (typeof command == "function")
	            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
	        
	        key.split("|").forEach(function(keyPart) {
	            var chain = "";
	            if (keyPart.indexOf(" ") != -1) {
	                var parts = keyPart.split(/\s+/);
	                keyPart = parts.pop();
	                parts.forEach(function(keyPart) {
	                    var binding = this.parseKeys(keyPart);
	                    var id = KEY_MODS[binding.hashId] + binding.key;
	                    chain += (chain ? " " : "") + id;
	                    this._addCommandToBinding(chain, "chainKeys");
	                }, this);
	                chain += " ";
	            }
	            var binding = this.parseKeys(keyPart);
	            var id = KEY_MODS[binding.hashId] + binding.key;
	            this._addCommandToBinding(chain + id, command, position);
	        }, this);
	    };
	    
	    function getPosition(command) {
	        return typeof command == "object" && command.bindKey
	            && command.bindKey.position || 0;
	    }
	    this._addCommandToBinding = function(keyId, command, position) {
	        var ckb = this.commandKeyBinding, i;
	        if (!command) {
	            delete ckb[keyId];
	        } else if (!ckb[keyId] || this.$singleCommand) {
	            ckb[keyId] = command;
	        } else {
	            if (!Array.isArray(ckb[keyId])) {
	                ckb[keyId] = [ckb[keyId]];
	            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
	                ckb[keyId].splice(i, 1);
	            }

	            if (typeof position != "number") {
	                if (position || command.isDefault)
	                    position = -100;
	                else
	                   position = getPosition(command);
	            }
	            var commands = ckb[keyId];
	            for (i = 0; i < commands.length; i++) {
	                var other = commands[i];
	                var otherPos = getPosition(other);
	                if (otherPos > position)
	                    break;
	            }
	            commands.splice(i, 0, command);
	        }
	    };

	    this.addCommands = function(commands) {
	        commands && Object.keys(commands).forEach(function(name) {
	            var command = commands[name];
	            if (!command)
	                return;
	            
	            if (typeof command === "string")
	                return this.bindKey(command, name);

	            if (typeof command === "function")
	                command = { exec: command };

	            if (typeof command !== "object")
	                return;

	            if (!command.name)
	                command.name = name;

	            this.addCommand(command);
	        }, this);
	    };

	    this.removeCommands = function(commands) {
	        Object.keys(commands).forEach(function(name) {
	            this.removeCommand(commands[name]);
	        }, this);
	    };

	    this.bindKeys = function(keyList) {
	        Object.keys(keyList).forEach(function(key) {
	            this.bindKey(key, keyList[key]);
	        }, this);
	    };

	    this._buildKeyHash = function(command) {
	        this.bindKey(command.bindKey, command);
	    };
	    this.parseKeys = function(keys) {
	        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
	        var key = parts.pop();

	        var keyCode = keyUtil[key];
	        if (keyUtil.FUNCTION_KEYS[keyCode])
	            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
	        else if (!parts.length)
	            return {key: key, hashId: -1};
	        else if (parts.length == 1 && parts[0] == "shift")
	            return {key: key.toUpperCase(), hashId: -1};

	        var hashId = 0;
	        for (var i = parts.length; i--;) {
	            var modifier = keyUtil.KEY_MODS[parts[i]];
	            if (modifier == null) {
	                if (typeof console != "undefined")
	                    console.error("invalid modifier " + parts[i] + " in " + keys);
	                return false;
	            }
	            hashId |= modifier;
	        }
	        return {key: key, hashId: hashId};
	    };

	    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
	        var key = KEY_MODS[hashId] + keyString;
	        return this.commandKeyBinding[key];
	    };

	    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
	        if (keyCode < 0) return;
	        var key = KEY_MODS[hashId] + keyString;
	        var command = this.commandKeyBinding[key];
	        if (data.$keyChain) {
	            data.$keyChain += " " + key;
	            command = this.commandKeyBinding[data.$keyChain] || command;
	        }
	        
	        if (command) {
	            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
	                data.$keyChain = data.$keyChain || key;
	                return {command: "null"};
	            }
	        }
	        
	        if (data.$keyChain) {
	            if ((!hashId || hashId == 4) && keyString.length == 1)
	                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
	            else if (hashId == -1 || keyCode > 0)
	                data.$keyChain = ""; // reset keyChain
	        }
	        return {command: command};
	    };
	    
	    this.getStatusText = function(editor, data) {
	        return data.$keyChain || "";
	    };

	}).call(HashHandler.prototype);

	exports.HashHandler = HashHandler;
	exports.MultiHashHandler = MultiHashHandler;
	});

	ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CommandManager = function(platform, commands) {
	    MultiHashHandler.call(this, commands, platform);
	    this.byName = this.commands;
	    this.setDefaultHandler("exec", function(e) {
	        return e.command.exec(e.editor, e.args || {});
	    });
	};

	oop.inherits(CommandManager, MultiHashHandler);

	(function() {

	    oop.implement(this, EventEmitter);

	    this.exec = function(command, editor, args) {
	        if (Array.isArray(command)) {
	            for (var i = command.length; i--; ) {
	                if (this.exec(command[i], editor, args)) return true;
	            }
	            return false;
	        }
	        
	        if (typeof command === "string")
	            command = this.commands[command];

	        if (!command)
	            return false;

	        if (editor && editor.$readOnly && !command.readOnly)
	            return false;

	        var e = {editor: editor, command: command, args: args};
	        e.returnValue = this._emit("exec", e);
	        this._signal("afterExec", e);

	        return e.returnValue === false ? false : true;
	    };

	    this.toggleRecording = function(editor) {
	        if (this.$inReplay)
	            return;

	        editor && editor._emit("changeStatus");
	        if (this.recording) {
	            this.macro.pop();
	            this.removeEventListener("exec", this.$addCommandToMacro);

	            if (!this.macro.length)
	                this.macro = this.oldMacro;

	            return this.recording = false;
	        }
	        if (!this.$addCommandToMacro) {
	            this.$addCommandToMacro = function(e) {
	                this.macro.push([e.command, e.args]);
	            }.bind(this);
	        }

	        this.oldMacro = this.macro;
	        this.macro = [];
	        this.on("exec", this.$addCommandToMacro);
	        return this.recording = true;
	    };

	    this.replay = function(editor) {
	        if (this.$inReplay || !this.macro)
	            return;

	        if (this.recording)
	            return this.toggleRecording(editor);

	        try {
	            this.$inReplay = true;
	            this.macro.forEach(function(x) {
	                if (typeof x == "string")
	                    this.exec(x, editor);
	                else
	                    this.exec(x[0], editor, x[1]);
	            }, this);
	        } finally {
	            this.$inReplay = false;
	        }
	    };

	    this.trimMacro = function(m) {
	        return m.map(function(x){
	            if (typeof x[0] != "string")
	                x[0] = x[0].name;
	            if (!x[1])
	                x = x[0];
	            return x;
	        });
	    };

	}).call(CommandManager.prototype);

	exports.CommandManager = CommandManager;

	});

	ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");
	var config = acequire("../config");
	var Range = acequire("../range").Range;

	function bindKey(win, mac) {
	    return {win: win, mac: mac};
	}
	exports.commands = [{
	    name: "showSettingsMenu",
	    bindKey: bindKey("Ctrl-,", "Command-,"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/settings_menu", function(module) {
	            module.init(editor);
	            editor.showSettingsMenu();
	        });
	    },
	    readOnly: true
	}, {
	    name: "goToNextError",
	    bindKey: bindKey("Alt-E", "Ctrl-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, 1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "goToPreviousError",
	    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, -1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selectall",
	    bindKey: bindKey("Ctrl-A", "Command-A"),
	    exec: function(editor) { editor.selectAll(); },
	    readOnly: true
	}, {
	    name: "centerselection",
	    bindKey: bindKey(null, "Ctrl-L"),
	    exec: function(editor) { editor.centerSelection(); },
	    readOnly: true
	}, {
	    name: "gotoline",
	    bindKey: bindKey("Ctrl-L", "Command-L"),
	    exec: function(editor) {
	        var line = parseInt(prompt("Enter line number:"), 10);
	        if (!isNaN(line)) {
	            editor.gotoLine(line);
	        }
	    },
	    readOnly: true
	}, {
	    name: "fold",
	    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
	    exec: function(editor) { editor.session.toggleFold(false); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfold",
	    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
	    exec: function(editor) { editor.session.toggleFold(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleFoldWidget",
	    bindKey: bindKey("F2", "F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleParentFoldWidget",
	    bindKey: bindKey("Alt-F2", "Alt-F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldall",
	    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
	    exec: function(editor) { editor.session.foldAll(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldOther",
	    bindKey: bindKey("Alt-0", "Command-Option-0"),
	    exec: function(editor) { 
	        editor.session.foldAll();
	        editor.session.unfold(editor.selection.getAllRanges());
	    },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfoldall",
	    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
	    exec: function(editor) { editor.session.unfold(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findnext",
	    bindKey: bindKey("Ctrl-K", "Command-G"),
	    exec: function(editor) { editor.findNext(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findprevious",
	    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
	    exec: function(editor) { editor.findPrevious(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "selectOrFindNext",
	    bindKey: bindKey("Alt-K", "Ctrl-G"),
	    exec: function(editor) {
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findNext(); 
	    },
	    readOnly: true
	}, {
	    name: "selectOrFindPrevious",
	    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findPrevious();
	    },
	    readOnly: true
	}, {
	    name: "find",
	    bindKey: bindKey("Ctrl-F", "Command-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
	    },
	    readOnly: true
	}, {
	    name: "overwrite",
	    bindKey: "Insert",
	    exec: function(editor) { editor.toggleOverwrite(); },
	    readOnly: true
	}, {
	    name: "selecttostart",
	    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotostart",
	    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
	    exec: function(editor) { editor.navigateFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectup",
	    bindKey: bindKey("Shift-Up", "Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectUp(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golineup",
	    bindKey: bindKey("Up", "Up|Ctrl-P"),
	    exec: function(editor, args) { editor.navigateUp(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttoend",
	    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotoend",
	    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
	    exec: function(editor) { editor.navigateFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectdown",
	    bindKey: bindKey("Shift-Down", "Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectDown(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golinedown",
	    bindKey: bindKey("Down", "Down|Ctrl-N"),
	    exec: function(editor, args) { editor.navigateDown(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordleft",
	    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordleft",
	    bindKey: bindKey("Ctrl-Left", "Option-Left"),
	    exec: function(editor) { editor.navigateWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolinestart",
	    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolinestart",
	    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
	    exec: function(editor) { editor.navigateLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectleft",
	    bindKey: bindKey("Shift-Left", "Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoleft",
	    bindKey: bindKey("Left", "Left|Ctrl-B"),
	    exec: function(editor, args) { editor.navigateLeft(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordright",
	    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordright",
	    bindKey: bindKey("Ctrl-Right", "Option-Right"),
	    exec: function(editor) { editor.navigateWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolineend",
	    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolineend",
	    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
	    exec: function(editor) { editor.navigateLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectright",
	    bindKey: bindKey("Shift-Right", "Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoright",
	    bindKey: bindKey("Right", "Right|Ctrl-F"),
	    exec: function(editor, args) { editor.navigateRight(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectpagedown",
	    bindKey: "Shift-PageDown",
	    exec: function(editor) { editor.selectPageDown(); },
	    readOnly: true
	}, {
	    name: "pagedown",
	    bindKey: bindKey(null, "Option-PageDown"),
	    exec: function(editor) { editor.scrollPageDown(); },
	    readOnly: true
	}, {
	    name: "gotopagedown",
	    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
	    exec: function(editor) { editor.gotoPageDown(); },
	    readOnly: true
	}, {
	    name: "selectpageup",
	    bindKey: "Shift-PageUp",
	    exec: function(editor) { editor.selectPageUp(); },
	    readOnly: true
	}, {
	    name: "pageup",
	    bindKey: bindKey(null, "Option-PageUp"),
	    exec: function(editor) { editor.scrollPageUp(); },
	    readOnly: true
	}, {
	    name: "gotopageup",
	    bindKey: "PageUp",
	    exec: function(editor) { editor.gotoPageUp(); },
	    readOnly: true
	}, {
	    name: "scrollup",
	    bindKey: bindKey("Ctrl-Up", null),
	    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "scrolldown",
	    bindKey: bindKey("Ctrl-Down", null),
	    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "selectlinestart",
	    bindKey: "Shift-Home",
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectlineend",
	    bindKey: "Shift-End",
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "togglerecording",
	    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
	    exec: function(editor) { editor.commands.toggleRecording(editor); },
	    readOnly: true
	}, {
	    name: "replaymacro",
	    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
	    exec: function(editor) { editor.commands.replay(editor); },
	    readOnly: true
	}, {
	    name: "jumptomatching",
	    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
	    exec: function(editor) { editor.jumpToMatching(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selecttomatching",
	    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
	    exec: function(editor) { editor.jumpToMatching(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "expandToMatching",
	    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
	    exec: function(editor) { editor.jumpToMatching(true, true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "passKeysToBrowser",
	    bindKey: bindKey(null, null),
	    exec: function() {},
	    passEvent: true,
	    readOnly: true
	}, {
	    name: "copy",
	    exec: function(editor) {
	    },
	    readOnly: true
	},
	{
	    name: "cut",
	    exec: function(editor) {
	        var range = editor.getSelectionRange();
	        editor._emit("cut", range);

	        if (!editor.selection.isEmpty()) {
	            editor.session.remove(range);
	            editor.clearSelection();
	        }
	    },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "paste",
	    exec: function(editor, args) {
	        editor.$handlePaste(args);
	    },
	    scrollIntoView: "cursor"
	}, {
	    name: "removeline",
	    bindKey: bindKey("Ctrl-D", "Command-D"),
	    exec: function(editor) { editor.removeLines(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "duplicateSelection",
	    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
	    exec: function(editor) { editor.duplicateSelection(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "sortlines",
	    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
	    exec: function(editor) { editor.sortLines(); },
	    scrollIntoView: "selection",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "togglecomment",
	    bindKey: bindKey("Ctrl-/", "Command-/"),
	    exec: function(editor) { editor.toggleCommentLines(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "toggleBlockComment",
	    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
	    exec: function(editor) { editor.toggleBlockComment(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "modifyNumberUp",
	    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
	    exec: function(editor) { editor.modifyNumber(1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "modifyNumberDown",
	    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
	    exec: function(editor) { editor.modifyNumber(-1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "replace",
	    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
	    }
	}, {
	    name: "undo",
	    bindKey: bindKey("Ctrl-Z", "Command-Z"),
	    exec: function(editor) { editor.undo(); }
	}, {
	    name: "redo",
	    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
	    exec: function(editor) { editor.redo(); }
	}, {
	    name: "copylinesup",
	    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
	    exec: function(editor) { editor.copyLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesup",
	    bindKey: bindKey("Alt-Up", "Option-Up"),
	    exec: function(editor) { editor.moveLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "copylinesdown",
	    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
	    exec: function(editor) { editor.copyLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesdown",
	    bindKey: bindKey("Alt-Down", "Option-Down"),
	    exec: function(editor) { editor.moveLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "del",
	    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
	    exec: function(editor) { editor.remove("right"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "backspace",
	    bindKey: bindKey(
	        "Shift-Backspace|Backspace",
	        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
	    ),
	    exec: function(editor) { editor.remove("left"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "cut_or_delete",
	    bindKey: bindKey("Shift-Delete", null),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty()) {
	            editor.remove("left");
	        } else {
	            return false;
	        }
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolinestart",
	    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
	    exec: function(editor) { editor.removeToLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolineend",
	    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
	    exec: function(editor) { editor.removeToLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordleft",
	    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
	    exec: function(editor) { editor.removeWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordright",
	    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
	    exec: function(editor) { editor.removeWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "outdent",
	    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "indent",
	    bindKey: bindKey("Tab", "Tab"),
	    exec: function(editor) { editor.indent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockoutdent",
	    bindKey: bindKey("Ctrl-[", "Ctrl-["),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockindent",
	    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
	    exec: function(editor) { editor.blockIndent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "insertstring",
	    exec: function(editor, str) { editor.insert(str); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "inserttext",
	    exec: function(editor, args) {
	        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "splitline",
	    bindKey: bindKey(null, "Ctrl-O"),
	    exec: function(editor) { editor.splitLine(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "transposeletters",
	    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
	    exec: function(editor) { editor.transposeLetters(); },
	    multiSelectAction: function(editor) {editor.transposeSelections(1); },
	    scrollIntoView: "cursor"
	}, {
	    name: "touppercase",
	    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
	    exec: function(editor) { editor.toUpperCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "tolowercase",
	    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
	    exec: function(editor) { editor.toLowerCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "expandtoline",
	    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
	    exec: function(editor) {
	        var range = editor.selection.getRange();

	        range.start.column = range.end.column = 0;
	        range.end.row++;
	        editor.selection.setRange(range, false);
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "joinlines",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var isBackwards = editor.selection.isBackwards();
	        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
	        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
	        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
	        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
	        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
	        var insertLine = editor.session.doc.getLine(selectionStart.row);

	        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
	            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
	            if (curLine.length !== 0) {
	                curLine = " " + curLine;
	            }
	            insertLine += curLine;
	        }

	        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
	            insertLine += editor.session.doc.getNewLineCharacter();
	        }

	        editor.clearSelection();
	        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

	        if (selectedCount > 0) {
	            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
	            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
	        } else {
	            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
	            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
	        }
	    },
	    multiSelectAction: "forEach",
	    readOnly: true
	}, {
	    name: "invertSelection",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var endRow = editor.session.doc.getLength() - 1;
	        var endCol = editor.session.doc.getLine(endRow).length;
	        var ranges = editor.selection.rangeList.ranges;
	        var newRanges = [];
	        if (ranges.length < 1) {
	            ranges = [editor.selection.getRange()];
	        }

	        for (var i = 0; i < ranges.length; i++) {
	            if (i == (ranges.length - 1)) {
	                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
	                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
	                }
	            }

	            if (i === 0) {
	                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
	                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
	                }
	            } else {
	                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
	            }
	        }

	        editor.exitMultiSelectMode();
	        editor.clearSelection();

	        for(var i = 0; i < newRanges.length; i++) {
	            editor.selection.addRange(newRanges[i], false);
	        }
	    },
	    readOnly: true,
	    scrollIntoView: "none"
	}];

	});

	ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var lang = acequire("./lib/lang");
	var useragent = acequire("./lib/useragent");
	var TextInput = acequire("./keyboard/textinput").TextInput;
	var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
	var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
	var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
	var EditSession = acequire("./edit_session").EditSession;
	var Search = acequire("./search").Search;
	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var CommandManager = acequire("./commands/command_manager").CommandManager;
	var defaultCommands = acequire("./commands/default_commands").commands;
	var config = acequire("./config");
	var TokenIterator = acequire("./token_iterator").TokenIterator;
	var Editor = function(renderer, session) {
	    var container = renderer.getContainerElement();
	    this.container = container;
	    this.renderer = renderer;

	    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
	    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
	    this.renderer.textarea = this.textInput.getElement();
	    this.keyBinding = new KeyBinding(this);
	    this.$mouseHandler = new MouseHandler(this);
	    new FoldHandler(this);

	    this.$blockScrolling = 0;
	    this.$search = new Search().set({
	        wrap: true
	    });

	    this.$historyTracker = this.$historyTracker.bind(this);
	    this.commands.on("exec", this.$historyTracker);

	    this.$initOperationListeners();
	    
	    this._$emitInputEvent = lang.delayedCall(function() {
	        this._signal("input", {});
	        if (this.session && this.session.bgTokenizer)
	            this.session.bgTokenizer.scheduleStart();
	    }.bind(this));
	    
	    this.on("change", function(_, _self) {
	        _self._$emitInputEvent.schedule(31);
	    });

	    this.setSession(session || new EditSession(""));
	    config.resetOptions(this);
	    config._signal("editor", this);
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.$initOperationListeners = function() {
	        function last(a) {return a[a.length - 1]}

	        this.selections = [];
	        this.commands.on("exec", this.startOperation.bind(this), true);
	        this.commands.on("afterExec", this.endOperation.bind(this), true);

	        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

	        this.on("change", function() {
	            this.curOp || this.startOperation();
	            this.curOp.docChanged = true;
	        }.bind(this), true);

	        this.on("changeSelection", function() {
	            this.curOp || this.startOperation();
	            this.curOp.selectionChanged = true;
	        }.bind(this), true);
	    };

	    this.curOp = null;
	    this.prevOp = {};
	    this.startOperation = function(commadEvent) {
	        if (this.curOp) {
	            if (!commadEvent || this.curOp.command)
	                return;
	            this.prevOp = this.curOp;
	        }
	        if (!commadEvent) {
	            this.previousCommand = null;
	            commadEvent = {};
	        }

	        this.$opResetTimer.schedule();
	        this.curOp = {
	            command: commadEvent.command || {},
	            args: commadEvent.args,
	            scrollTop: this.renderer.scrollTop
	        };
	        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
	            this.$blockScrolling++;
	    };

	    this.endOperation = function(e) {
	        if (this.curOp) {
	            if (e && e.returnValue === false)
	                return this.curOp = null;
	            this._signal("beforeEndOperation");
	            var command = this.curOp.command;
	            if (command.name && this.$blockScrolling > 0)
	                this.$blockScrolling--;
	            var scrollIntoView = command && command.scrollIntoView;
	            if (scrollIntoView) {
	                switch (scrollIntoView) {
	                    case "center-animate":
	                        scrollIntoView = "animate";
	                    case "center":
	                        this.renderer.scrollCursorIntoView(null, 0.5);
	                        break;
	                    case "animate":
	                    case "cursor":
	                        this.renderer.scrollCursorIntoView();
	                        break;
	                    case "selectionPart":
	                        var range = this.selection.getRange();
	                        var config = this.renderer.layerConfig;
	                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
	                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
	                        }
	                        break;
	                    default:
	                        break;
	                }
	                if (scrollIntoView == "animate")
	                    this.renderer.animateScrolling(this.curOp.scrollTop);
	            }
	            
	            this.prevOp = this.curOp;
	            this.curOp = null;
	        }
	    };
	    this.$mergeableCommands = ["backspace", "del", "insertstring"];
	    this.$historyTracker = function(e) {
	        if (!this.$mergeUndoDeltas)
	            return;

	        var prev = this.prevOp;
	        var mergeableCommands = this.$mergeableCommands;
	        var shouldMerge = prev.command && (e.command.name == prev.command.name);
	        if (e.command.name == "insertstring") {
	            var text = e.args;
	            if (this.mergeNextCommand === undefined)
	                this.mergeNextCommand = true;

	            shouldMerge = shouldMerge
	                && this.mergeNextCommand // previous command allows to coalesce with
	                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

	            this.mergeNextCommand = true;
	        } else {
	            shouldMerge = shouldMerge
	                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
	        }

	        if (
	            this.$mergeUndoDeltas != "always"
	            && Date.now() - this.sequenceStartTime > 2000
	        ) {
	            shouldMerge = false; // the sequence is too long
	        }

	        if (shouldMerge)
	            this.session.mergeUndoDeltas = true;
	        else if (mergeableCommands.indexOf(e.command.name) !== -1)
	            this.sequenceStartTime = Date.now();
	    };
	    this.setKeyboardHandler = function(keyboardHandler, cb) {
	        if (keyboardHandler && typeof keyboardHandler === "string") {
	            this.$keybindingId = keyboardHandler;
	            var _self = this;
	            config.loadModule(["keybinding", keyboardHandler], function(module) {
	                if (_self.$keybindingId == keyboardHandler)
	                    _self.keyBinding.setKeyboardHandler(module && module.handler);
	                cb && cb();
	            });
	        } else {
	            this.$keybindingId = null;
	            this.keyBinding.setKeyboardHandler(keyboardHandler);
	            cb && cb();
	        }
	    };
	    this.getKeyboardHandler = function() {
	        return this.keyBinding.getKeyboardHandler();
	    };
	    this.setSession = function(session) {
	        if (this.session == session)
	            return;
	        if (this.curOp) this.endOperation();
	        this.curOp = {};

	        var oldSession = this.session;
	        if (oldSession) {
	            this.session.off("change", this.$onDocumentChange);
	            this.session.off("changeMode", this.$onChangeMode);
	            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
	            this.session.off("changeTabSize", this.$onChangeTabSize);
	            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
	            this.session.off("changeWrapMode", this.$onChangeWrapMode);
	            this.session.off("changeFold", this.$onChangeFold);
	            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
	            this.session.off("changeBackMarker", this.$onChangeBackMarker);
	            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
	            this.session.off("changeAnnotation", this.$onChangeAnnotation);
	            this.session.off("changeOverwrite", this.$onCursorChange);
	            this.session.off("changeScrollTop", this.$onScrollTopChange);
	            this.session.off("changeScrollLeft", this.$onScrollLeftChange);

	            var selection = this.session.getSelection();
	            selection.off("changeCursor", this.$onCursorChange);
	            selection.off("changeSelection", this.$onSelectionChange);
	        }

	        this.session = session;
	        if (session) {
	            this.$onDocumentChange = this.onDocumentChange.bind(this);
	            session.on("change", this.$onDocumentChange);
	            this.renderer.setSession(session);
	    
	            this.$onChangeMode = this.onChangeMode.bind(this);
	            session.on("changeMode", this.$onChangeMode);
	    
	            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
	            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
	    
	            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
	            session.on("changeTabSize", this.$onChangeTabSize);
	    
	            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
	            session.on("changeWrapLimit", this.$onChangeWrapLimit);
	    
	            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
	            session.on("changeWrapMode", this.$onChangeWrapMode);
	    
	            this.$onChangeFold = this.onChangeFold.bind(this);
	            session.on("changeFold", this.$onChangeFold);
	    
	            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
	            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
	    
	            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
	            this.session.on("changeBackMarker", this.$onChangeBackMarker);
	    
	            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
	            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
	    
	            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
	            this.session.on("changeAnnotation", this.$onChangeAnnotation);
	    
	            this.$onCursorChange = this.onCursorChange.bind(this);
	            this.session.on("changeOverwrite", this.$onCursorChange);
	    
	            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
	            this.session.on("changeScrollTop", this.$onScrollTopChange);
	    
	            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
	            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
	    
	            this.selection = session.getSelection();
	            this.selection.on("changeCursor", this.$onCursorChange);
	    
	            this.$onSelectionChange = this.onSelectionChange.bind(this);
	            this.selection.on("changeSelection", this.$onSelectionChange);
	    
	            this.onChangeMode();
	    
	            this.$blockScrolling += 1;
	            this.onCursorChange();
	            this.$blockScrolling -= 1;
	    
	            this.onScrollTopChange();
	            this.onScrollLeftChange();
	            this.onSelectionChange();
	            this.onChangeFrontMarker();
	            this.onChangeBackMarker();
	            this.onChangeBreakpoint();
	            this.onChangeAnnotation();
	            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
	            this.renderer.updateFull();
	        } else {
	            this.selection = null;
	            this.renderer.setSession(session);
	        }

	        this._signal("changeSession", {
	            session: session,
	            oldSession: oldSession
	        });
	        
	        this.curOp = null;
	        
	        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
	        session && session._signal("changeEditor", {editor: this});
	    };
	    this.getSession = function() {
	        return this.session;
	    };
	    this.setValue = function(val, cursorPos) {
	        this.session.doc.setValue(val);

	        if (!cursorPos)
	            this.selectAll();
	        else if (cursorPos == 1)
	            this.navigateFileEnd();
	        else if (cursorPos == -1)
	            this.navigateFileStart();

	        return val;
	    };
	    this.getValue = function() {
	        return this.session.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.resize = function(force) {
	        this.renderer.onResize(force);
	    };
	    this.setTheme = function(theme, cb) {
	        this.renderer.setTheme(theme, cb);
	    };
	    this.getTheme = function() {
	        return this.renderer.getTheme();
	    };
	    this.setStyle = function(style) {
	        this.renderer.setStyle(style);
	    };
	    this.unsetStyle = function(style) {
	        this.renderer.unsetStyle(style);
	    };
	    this.getFontSize = function () {
	        return this.getOption("fontSize") ||
	           dom.computedStyle(this.container, "fontSize");
	    };
	    this.setFontSize = function(size) {
	        this.setOption("fontSize", size);
	    };

	    this.$highlightBrackets = function() {
	        if (this.session.$bracketHighlight) {
	            this.session.removeMarker(this.session.$bracketHighlight);
	            this.session.$bracketHighlight = null;
	        }

	        if (this.$highlightPending) {
	            return;
	        }
	        var self = this;
	        this.$highlightPending = true;
	        setTimeout(function() {
	            self.$highlightPending = false;
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            var pos = session.findMatchingBracket(self.getCursorPosition());
	            if (pos) {
	                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
	            } else if (session.$mode.getMatching) {
	                var range = session.$mode.getMatching(self.session);
	            }
	            if (range)
	                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.$highlightTags = function() {
	        if (this.$highlightTagPending)
	            return;
	        var self = this;
	        this.$highlightTagPending = true;
	        setTimeout(function() {
	            self.$highlightTagPending = false;
	            
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            
	            var pos = self.getCursorPosition();
	            var iterator = new TokenIterator(self.session, pos.row, pos.column);
	            var token = iterator.getCurrentToken();
	            
	            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }
	            
	            if (token.type.indexOf("tag-open") != -1) {
	                token = iterator.stepForward();
	                if (!token)
	                    return;
	            }
	            
	            var tag = token.value;
	            var depth = 0;
	            var prevToken = iterator.stepBackward();
	            
	            if (prevToken.value == '<'){
	                do {
	                    prevToken = token;
	                    token = iterator.stepForward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<'){
	                            depth++;
	                        } else if (prevToken.value === '</'){
	                            depth--;
	                        }
	                    }
	                    
	                } while (token && depth >= 0);
	            } else {
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<') {
	                            depth++;
	                        } else if (prevToken.value === '</') {
	                            depth--;
	                        }
	                    }
	                } while (prevToken && depth <= 0);
	                iterator.stepForward();
	            }
	            
	            if (!token) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }
	            
	            var row = iterator.getCurrentTokenRow();
	            var column = iterator.getCurrentTokenColumn();
	            var range = new Range(row, column, row, column+token.value.length);
	            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	            }
	            
	            if (range && !session.$tagHighlight)
	                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.focus = function() {
	        var _self = this;
	        setTimeout(function() {
	            _self.textInput.focus();
	        });
	        this.textInput.focus();
	    };
	    this.isFocused = function() {
	        return this.textInput.isFocused();
	    };
	    this.blur = function() {
	        this.textInput.blur();
	    };
	    this.onFocus = function(e) {
	        if (this.$isFocused)
	            return;
	        this.$isFocused = true;
	        this.renderer.showCursor();
	        this.renderer.visualizeFocus();
	        this._emit("focus", e);
	    };
	    this.onBlur = function(e) {
	        if (!this.$isFocused)
	            return;
	        this.$isFocused = false;
	        this.renderer.hideCursor();
	        this.renderer.visualizeBlur();
	        this._emit("blur", e);
	    };

	    this.$cursorChange = function() {
	        this.renderer.updateCursor();
	    };
	    this.onDocumentChange = function(delta) {
	        var wrap = this.session.$useWrapMode;
	        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
	        this.renderer.updateLines(delta.start.row, lastRow, wrap);

	        this._signal("change", delta);
	        this.$cursorChange();
	        this.$updateHighlightActiveLine();
	    };

	    this.onTokenizerUpdate = function(e) {
	        var rows = e.data;
	        this.renderer.updateLines(rows.first, rows.last);
	    };


	    this.onScrollTopChange = function() {
	        this.renderer.scrollToY(this.session.getScrollTop());
	    };

	    this.onScrollLeftChange = function() {
	        this.renderer.scrollToX(this.session.getScrollLeft());
	    };
	    this.onCursorChange = function() {
	        this.$cursorChange();

	        if (!this.$blockScrolling) {
	            config.warn("Automatically scrolling cursor into view after selection change",
	                "this will be disabled in the next version",
	                "set editor.$blockScrolling = Infinity to disable this message"
	            );
	            this.renderer.scrollCursorIntoView();
	        }

	        this.$highlightBrackets();
	        this.$highlightTags();
	        this.$updateHighlightActiveLine();
	        this._signal("changeSelection");
	    };

	    this.$updateHighlightActiveLine = function() {
	        var session = this.getSession();

	        var highlight;
	        if (this.$highlightActiveLine) {
	            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
	                highlight = this.getCursorPosition();
	            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
	                highlight = false;
	        }

	        if (session.$highlightLineMarker && !highlight) {
	            session.removeMarker(session.$highlightLineMarker.id);
	            session.$highlightLineMarker = null;
	        } else if (!session.$highlightLineMarker && highlight) {
	            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
	            range.id = session.addMarker(range, "ace_active-line", "screenLine");
	            session.$highlightLineMarker = range;
	        } else if (highlight) {
	            session.$highlightLineMarker.start.row = highlight.row;
	            session.$highlightLineMarker.end.row = highlight.row;
	            session.$highlightLineMarker.start.column = highlight.column;
	            session._signal("changeBackMarker");
	        }
	    };

	    this.onSelectionChange = function(e) {
	        var session = this.session;

	        if (session.$selectionMarker) {
	            session.removeMarker(session.$selectionMarker);
	        }
	        session.$selectionMarker = null;

	        if (!this.selection.isEmpty()) {
	            var range = this.selection.getRange();
	            var style = this.getSelectionStyle();
	            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
	        } else {
	            this.$updateHighlightActiveLine();
	        }

	        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
	        this.session.highlight(re);

	        this._signal("changeSelection");
	    };

	    this.$getSelectionHighLightRegexp = function() {
	        var session = this.session;

	        var selection = this.getSelectionRange();
	        if (selection.isEmpty() || selection.isMultiLine())
	            return;

	        var startOuter = selection.start.column - 1;
	        var endOuter = selection.end.column + 1;
	        var line = session.getLine(selection.start.row);
	        var lineCols = line.length;
	        var needle = line.substring(Math.max(startOuter, 0),
	                                    Math.min(endOuter, lineCols));
	        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
	            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
	            return;

	        needle = line.substring(selection.start.column, selection.end.column);
	        if (!/^[\w\d]+$/.test(needle))
	            return;

	        var re = this.$search.$assembleRegExp({
	            wholeWord: true,
	            caseSensitive: true,
	            needle: needle
	        });

	        return re;
	    };


	    this.onChangeFrontMarker = function() {
	        this.renderer.updateFrontMarkers();
	    };

	    this.onChangeBackMarker = function() {
	        this.renderer.updateBackMarkers();
	    };


	    this.onChangeBreakpoint = function() {
	        this.renderer.updateBreakpoints();
	    };

	    this.onChangeAnnotation = function() {
	        this.renderer.setAnnotations(this.session.getAnnotations());
	    };


	    this.onChangeMode = function(e) {
	        this.renderer.updateText();
	        this._emit("changeMode", e);
	    };


	    this.onChangeWrapLimit = function() {
	        this.renderer.updateFull();
	    };

	    this.onChangeWrapMode = function() {
	        this.renderer.onResize(true);
	    };


	    this.onChangeFold = function() {
	        this.$updateHighlightActiveLine();
	        this.renderer.updateFull();
	    };
	    this.getSelectedText = function() {
	        return this.session.getTextRange(this.getSelectionRange());
	    };
	    this.getCopyText = function() {
	        var text = this.getSelectedText();
	        this._signal("copy", text);
	        return text;
	    };
	    this.onCopy = function() {
	        this.commands.exec("copy", this);
	    };
	    this.onCut = function() {
	        this.commands.exec("cut", this);
	    };
	    this.onPaste = function(text, event) {
	        var e = {text: text, event: event};
	        this.commands.exec("paste", this, e);
	    };
	    
	    this.$handlePaste = function(e) {
	        if (typeof e == "string") 
	            e = {text: e};
	        this._signal("paste", e);
	        var text = e.text;
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
	            this.insert(text);
	        } else {
	            var lines = text.split(/\r\n|\r|\n/);
	            var ranges = this.selection.rangeList.ranges;
	    
	            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
	                return this.commands.exec("insertstring", this, text);
	    
	            for (var i = ranges.length; i--;) {
	                var range = ranges[i];
	                if (!range.isEmpty())
	                    this.session.remove(range);
	    
	                this.session.insert(range.start, lines[i]);
	            }
	        }
	    };

	    this.execCommand = function(command, args) {
	        return this.commands.exec(command, this, args);
	    };
	    this.insert = function(text, pasted) {
	        var session = this.session;
	        var mode = session.getMode();
	        var cursor = this.getCursorPosition();

	        if (this.getBehavioursEnabled() && !pasted) {
	            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
	            if (transform) {
	                if (text !== transform.text) {
	                    this.session.mergeUndoDeltas = false;
	                    this.$mergeNextCommand = false;
	                }
	                text = transform.text;

	            }
	        }
	        
	        if (text == "\t")
	            text = this.session.getTabString();
	        if (!this.selection.isEmpty()) {
	            var range = this.getSelectionRange();
	            cursor = this.session.remove(range);
	            this.clearSelection();
	        }
	        else if (this.session.getOverwrite()) {
	            var range = new Range.fromPoints(cursor, cursor);
	            range.end.column += text.length;
	            this.session.remove(range);
	        }

	        if (text == "\n" || text == "\r\n") {
	            var line = session.getLine(cursor.row);
	            if (cursor.column > line.search(/\S|$/)) {
	                var d = line.substr(cursor.column).search(/\S|$/);
	                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
	            }
	        }
	        this.clearSelection();

	        var start = cursor.column;
	        var lineState = session.getState(cursor.row);
	        var line = session.getLine(cursor.row);
	        var shouldOutdent = mode.checkOutdent(lineState, line, text);
	        var end = session.insert(cursor, text);

	        if (transform && transform.selection) {
	            if (transform.selection.length == 2) { // Transform relative to the current column
	                this.selection.setSelectionRange(
	                    new Range(cursor.row, start + transform.selection[0],
	                              cursor.row, start + transform.selection[1]));
	            } else { // Transform relative to the current row.
	                this.selection.setSelectionRange(
	                    new Range(cursor.row + transform.selection[0],
	                              transform.selection[1],
	                              cursor.row + transform.selection[2],
	                              transform.selection[3]));
	            }
	        }

	        if (session.getDocument().isNewLine(text)) {
	            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

	            session.insert({row: cursor.row+1, column: 0}, lineIndent);
	        }
	        if (shouldOutdent)
	            mode.autoOutdent(lineState, session, cursor.row);
	    };

	    this.onTextInput = function(text) {
	        this.keyBinding.onTextInput(text);
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        this.keyBinding.onCommandKey(e, hashId, keyCode);
	    };
	    this.setOverwrite = function(overwrite) {
	        this.session.setOverwrite(overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.session.getOverwrite();
	    };
	    this.toggleOverwrite = function() {
	        this.session.toggleOverwrite();
	    };
	    this.setScrollSpeed = function(speed) {
	        this.setOption("scrollSpeed", speed);
	    };
	    this.getScrollSpeed = function() {
	        return this.getOption("scrollSpeed");
	    };
	    this.setDragDelay = function(dragDelay) {
	        this.setOption("dragDelay", dragDelay);
	    };
	    this.getDragDelay = function() {
	        return this.getOption("dragDelay");
	    };
	    this.setSelectionStyle = function(val) {
	        this.setOption("selectionStyle", val);
	    };
	    this.getSelectionStyle = function() {
	        return this.getOption("selectionStyle");
	    };
	    this.setHighlightActiveLine = function(shouldHighlight) {
	        this.setOption("highlightActiveLine", shouldHighlight);
	    };
	    this.getHighlightActiveLine = function() {
	        return this.getOption("highlightActiveLine");
	    };
	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };
	    this.setHighlightSelectedWord = function(shouldHighlight) {
	        this.setOption("highlightSelectedWord", shouldHighlight);
	    };
	    this.getHighlightSelectedWord = function() {
	        return this.$highlightSelectedWord;
	    };

	    this.setAnimatedScroll = function(shouldAnimate){
	        this.renderer.setAnimatedScroll(shouldAnimate);
	    };

	    this.getAnimatedScroll = function(){
	        return this.renderer.getAnimatedScroll();
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.renderer.setShowInvisibles(showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.renderer.getShowInvisibles();
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.renderer.setDisplayIndentGuides(display);
	    };

	    this.getDisplayIndentGuides = function() {
	        return this.renderer.getDisplayIndentGuides();
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.renderer.setShowPrintMargin(showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.renderer.getShowPrintMargin();
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.renderer.setPrintMarginColumn(showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.renderer.getPrintMarginColumn();
	    };
	    this.setReadOnly = function(readOnly) {
	        this.setOption("readOnly", readOnly);
	    };
	    this.getReadOnly = function() {
	        return this.getOption("readOnly");
	    };
	    this.setBehavioursEnabled = function (enabled) {
	        this.setOption("behavioursEnabled", enabled);
	    };
	    this.getBehavioursEnabled = function () {
	        return this.getOption("behavioursEnabled");
	    };
	    this.setWrapBehavioursEnabled = function (enabled) {
	        this.setOption("wrapBehavioursEnabled", enabled);
	    };
	    this.getWrapBehavioursEnabled = function () {
	        return this.getOption("wrapBehavioursEnabled");
	    };
	    this.setShowFoldWidgets = function(show) {
	        this.setOption("showFoldWidgets", show);

	    };
	    this.getShowFoldWidgets = function() {
	        return this.getOption("showFoldWidgets");
	    };

	    this.setFadeFoldWidgets = function(fade) {
	        this.setOption("fadeFoldWidgets", fade);
	    };

	    this.getFadeFoldWidgets = function() {
	        return this.getOption("fadeFoldWidgets");
	    };
	    this.remove = function(dir) {
	        if (this.selection.isEmpty()){
	            if (dir == "left")
	                this.selection.selectLeft();
	            else
	                this.selection.selectRight();
	        }

	        var range = this.getSelectionRange();
	        if (this.getBehavioursEnabled()) {
	            var session = this.session;
	            var state = session.getState(range.start.row);
	            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

	            if (range.end.column === 0) {
	                var text = session.getTextRange(range);
	                if (text[text.length - 1] == "\n") {
	                    var line = session.getLine(range.end.row);
	                    if (/^\s+$/.test(line)) {
	                        range.end.column = line.length;
	                    }
	                }
	            }
	            if (new_range)
	                range = new_range;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.removeWordRight = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordRight();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeWordLeft = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordLeft();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineStart = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineStart();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineEnd = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineEnd();

	        var range = this.getSelectionRange();
	        if (range.start.column == range.end.column && range.start.row == range.end.row) {
	            range.end.column = 0;
	            range.end.row++;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.splitLine = function() {
	        if (!this.selection.isEmpty()) {
	            this.session.remove(this.getSelectionRange());
	            this.clearSelection();
	        }

	        var cursor = this.getCursorPosition();
	        this.insert("\n");
	        this.moveCursorToPosition(cursor);
	    };
	    this.transposeLetters = function() {
	        if (!this.selection.isEmpty()) {
	            return;
	        }

	        var cursor = this.getCursorPosition();
	        var column = cursor.column;
	        if (column === 0)
	            return;

	        var line = this.session.getLine(cursor.row);
	        var swap, range;
	        if (column < line.length) {
	            swap = line.charAt(column) + line.charAt(column-1);
	            range = new Range(cursor.row, column-1, cursor.row, column+1);
	        }
	        else {
	            swap = line.charAt(column-1) + line.charAt(column-2);
	            range = new Range(cursor.row, column-2, cursor.row, column);
	        }
	        this.session.replace(range, swap);
	    };
	    this.toLowerCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toLowerCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.toUpperCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toUpperCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.indent = function() {
	        var session = this.session;
	        var range = this.getSelectionRange();

	        if (range.start.row < range.end.row) {
	            var rows = this.$getSelectedRows();
	            session.indentRows(rows.first, rows.last, "\t");
	            return;
	        } else if (range.start.column < range.end.column) {
	            var text = session.getTextRange(range);
	            if (!/^\s+$/.test(text)) {
	                var rows = this.$getSelectedRows();
	                session.indentRows(rows.first, rows.last, "\t");
	                return;
	            }
	        }
	        
	        var line = session.getLine(range.start.row);
	        var position = range.start;
	        var size = session.getTabSize();
	        var column = session.documentToScreenColumn(position.row, position.column);

	        if (this.session.getUseSoftTabs()) {
	            var count = (size - column % size);
	            var indentString = lang.stringRepeat(" ", count);
	        } else {
	            var count = column % size;
	            while (line[range.start.column] == " " && count) {
	                range.start.column--;
	                count--;
	            }
	            this.selection.setSelectionRange(range);
	            indentString = "\t";
	        }
	        return this.insert(indentString);
	    };
	    this.blockIndent = function() {
	        var rows = this.$getSelectedRows();
	        this.session.indentRows(rows.first, rows.last, "\t");
	    };
	    this.blockOutdent = function() {
	        var selection = this.session.getSelection();
	        this.session.outdentRows(selection.getRange());
	    };
	    this.sortLines = function() {
	        var rows = this.$getSelectedRows();
	        var session = this.session;

	        var lines = [];
	        for (i = rows.first; i <= rows.last; i++)
	            lines.push(session.getLine(i));

	        lines.sort(function(a, b) {
	            if (a.toLowerCase() < b.toLowerCase()) return -1;
	            if (a.toLowerCase() > b.toLowerCase()) return 1;
	            return 0;
	        });

	        var deleteRange = new Range(0, 0, 0, 0);
	        for (var i = rows.first; i <= rows.last; i++) {
	            var line = session.getLine(i);
	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            deleteRange.end.column = line.length;
	            session.replace(deleteRange, lines[i-rows.first]);
	        }
	    };
	    this.toggleCommentLines = function() {
	        var state = this.session.getState(this.getCursorPosition().row);
	        var rows = this.$getSelectedRows();
	        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
	    };

	    this.toggleBlockComment = function() {
	        var cursor = this.getCursorPosition();
	        var state = this.session.getState(cursor.row);
	        var range = this.getSelectionRange();
	        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
	    };
	    this.getNumberAt = function(row, column) {
	        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
	        _numberRx.lastIndex = 0;

	        var s = this.session.getLine(row);
	        while (_numberRx.lastIndex < column) {
	            var m = _numberRx.exec(s);
	            if(m.index <= column && m.index+m[0].length >= column){
	                var number = {
	                    value: m[0],
	                    start: m.index,
	                    end: m.index+m[0].length
	                };
	                return number;
	            }
	        }
	        return null;
	    };
	    this.modifyNumber = function(amount) {
	        var row = this.selection.getCursor().row;
	        var column = this.selection.getCursor().column;
	        var charRange = new Range(row, column-1, row, column);

	        var c = this.session.getTextRange(charRange);
	        if (!isNaN(parseFloat(c)) && isFinite(c)) {
	            var nr = this.getNumberAt(row, column);
	            if (nr) {
	                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
	                var decimals = nr.start + nr.value.length - fp;

	                var t = parseFloat(nr.value);
	                t *= Math.pow(10, decimals);


	                if(fp !== nr.end && column < fp){
	                    amount *= Math.pow(10, nr.end - column - 1);
	                } else {
	                    amount *= Math.pow(10, nr.end - column);
	                }

	                t += amount;
	                t /= Math.pow(10, decimals);
	                var nnr = t.toFixed(decimals);
	                var replaceRange = new Range(row, nr.start, row, nr.end);
	                this.session.replace(replaceRange, nnr);
	                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

	            }
	        }
	    };
	    this.removeLines = function() {
	        var rows = this.$getSelectedRows();
	        this.session.removeFullLines(rows.first, rows.last);
	        this.clearSelection();
	    };

	    this.duplicateSelection = function() {
	        var sel = this.selection;
	        var doc = this.session;
	        var range = sel.getRange();
	        var reverse = sel.isBackwards();
	        if (range.isEmpty()) {
	            var row = range.start.row;
	            doc.duplicateLines(row, row);
	        } else {
	            var point = reverse ? range.start : range.end;
	            var endPoint = doc.insert(point, doc.getTextRange(range), false);
	            range.start = point;
	            range.end = endPoint;

	            sel.setSelectionRange(range, reverse);
	        }
	    };
	    this.moveLinesDown = function() {
	        this.$moveLines(1, false);
	    };
	    this.moveLinesUp = function() {
	        this.$moveLines(-1, false);
	    };
	    this.moveText = function(range, toPosition, copy) {
	        return this.session.moveText(range, toPosition, copy);
	    };
	    this.copyLinesUp = function() {
	        this.$moveLines(-1, true);
	    };
	    this.copyLinesDown = function() {
	        this.$moveLines(1, true);
	    };
	    this.$moveLines = function(dir, copy) {
	        var rows, moved;
	        var selection = this.selection;
	        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
	            var range = selection.toOrientedRange();
	            rows = this.$getSelectedRows(range);
	            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
	            if (copy && dir == -1) moved = 0;
	            range.moveBy(moved, 0);
	            selection.fromOrientedRange(range);
	        } else {
	            var ranges = selection.rangeList.ranges;
	            selection.rangeList.detach(this.session);
	            this.inVirtualSelectionMode = true;
	            
	            var diff = 0;
	            var totalDiff = 0;
	            var l = ranges.length;
	            for (var i = 0; i < l; i++) {
	                var rangeIndex = i;
	                ranges[i].moveBy(diff, 0);
	                rows = this.$getSelectedRows(ranges[i]);
	                var first = rows.first;
	                var last = rows.last;
	                while (++i < l) {
	                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
	                    var subRows = this.$getSelectedRows(ranges[i]);
	                    if (copy && subRows.first != last)
	                        break;
	                    else if (!copy && subRows.first > last + 1)
	                        break;
	                    last = subRows.last;
	                }
	                i--;
	                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
	                if (copy && dir == -1) rangeIndex = i + 1;
	                while (rangeIndex <= i) {
	                    ranges[rangeIndex].moveBy(diff, 0);
	                    rangeIndex++;
	                }
	                if (!copy) diff = 0;
	                totalDiff += diff;
	            }
	            
	            selection.fromOrientedRange(selection.ranges[0]);
	            selection.rangeList.attach(this.session);
	            this.inVirtualSelectionMode = false;
	        }
	    };
	    this.$getSelectedRows = function(range) {
	        range = (range || this.getSelectionRange()).collapseRows();

	        return {
	            first: this.session.getRowFoldStart(range.start.row),
	            last: this.session.getRowFoldEnd(range.end.row)
	        };
	    };

	    this.onCompositionStart = function(text) {
	        this.renderer.showComposition(this.getCursorPosition());
	    };

	    this.onCompositionUpdate = function(text) {
	        this.renderer.setCompositionText(text);
	    };

	    this.onCompositionEnd = function() {
	        this.renderer.hideComposition();
	    };
	    this.getFirstVisibleRow = function() {
	        return this.renderer.getFirstVisibleRow();
	    };
	    this.getLastVisibleRow = function() {
	        return this.renderer.getLastVisibleRow();
	    };
	    this.isRowVisible = function(row) {
	        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
	    };
	    this.isRowFullyVisible = function(row) {
	        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
	    };
	    this.$getVisibleRowCount = function() {
	        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
	    };

	    this.$moveByPage = function(dir, select) {
	        var renderer = this.renderer;
	        var config = this.renderer.layerConfig;
	        var rows = dir * Math.floor(config.height / config.lineHeight);

	        this.$blockScrolling++;
	        if (select === true) {
	            this.selection.$moveSelection(function(){
	                this.moveCursorBy(rows, 0);
	            });
	        } else if (select === false) {
	            this.selection.moveCursorBy(rows, 0);
	            this.selection.clearSelection();
	        }
	        this.$blockScrolling--;

	        var scrollTop = renderer.scrollTop;

	        renderer.scrollBy(0, rows * config.lineHeight);
	        if (select != null)
	            renderer.scrollCursorIntoView(null, 0.5);

	        renderer.animateScrolling(scrollTop);
	    };
	    this.selectPageDown = function() {
	        this.$moveByPage(1, true);
	    };
	    this.selectPageUp = function() {
	        this.$moveByPage(-1, true);
	    };
	    this.gotoPageDown = function() {
	       this.$moveByPage(1, false);
	    };
	    this.gotoPageUp = function() {
	        this.$moveByPage(-1, false);
	    };
	    this.scrollPageDown = function() {
	        this.$moveByPage(1);
	    };
	    this.scrollPageUp = function() {
	        this.$moveByPage(-1);
	    };
	    this.scrollToRow = function(row) {
	        this.renderer.scrollToRow(row);
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        this.renderer.scrollToLine(line, center, animate, callback);
	    };
	    this.centerSelection = function() {
	        var range = this.getSelectionRange();
	        var pos = {
	            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
	            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
	        };
	        this.renderer.alignCursor(pos, 0.5);
	    };
	    this.getCursorPosition = function() {
	        return this.selection.getCursor();
	    };
	    this.getCursorPositionScreen = function() {
	        return this.session.documentToScreenPosition(this.getCursorPosition());
	    };
	    this.getSelectionRange = function() {
	        return this.selection.getRange();
	    };
	    this.selectAll = function() {
	        this.$blockScrolling += 1;
	        this.selection.selectAll();
	        this.$blockScrolling -= 1;
	    };
	    this.clearSelection = function() {
	        this.selection.clearSelection();
	    };
	    this.moveCursorTo = function(row, column) {
	        this.selection.moveCursorTo(row, column);
	    };
	    this.moveCursorToPosition = function(pos) {
	        this.selection.moveCursorToPosition(pos);
	    };
	    this.jumpToMatching = function(select, expand) {
	        var cursor = this.getCursorPosition();
	        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
	        var prevToken = iterator.getCurrentToken();
	        var token = prevToken || iterator.stepForward();

	        if (!token) return;
	        var matchType;
	        var found = false;
	        var depth = {};
	        var i = cursor.column - token.start;
	        var bracketType;
	        var brackets = {
	            ")": "(",
	            "(": "(",
	            "]": "[",
	            "[": "[",
	            "{": "{",
	            "}": "{"
	        };
	        
	        do {
	            if (token.value.match(/[{}()\[\]]/g)) {
	                for (; i < token.value.length && !found; i++) {
	                    if (!brackets[token.value[i]]) {
	                        continue;
	                    }

	                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

	                    if (isNaN(depth[bracketType])) {
	                        depth[bracketType] = 0;
	                    }

	                    switch (token.value[i]) {
	                        case '(':
	                        case '[':
	                        case '{':
	                            depth[bracketType]++;
	                            break;
	                        case ')':
	                        case ']':
	                        case '}':
	                            depth[bracketType]--;

	                            if (depth[bracketType] === -1) {
	                                matchType = 'bracket';
	                                found = true;
	                            }
	                        break;
	                    }
	                }
	            }
	            else if (token && token.type.indexOf('tag-name') !== -1) {
	                if (isNaN(depth[token.value])) {
	                    depth[token.value] = 0;
	                }
	                
	                if (prevToken.value === '<') {
	                    depth[token.value]++;
	                }
	                else if (prevToken.value === '</') {
	                    depth[token.value]--;
	                }
	                
	                if (depth[token.value] === -1) {
	                    matchType = 'tag';
	                    found = true;
	                }
	            }

	            if (!found) {
	                prevToken = token;
	                token = iterator.stepForward();
	                i = 0;
	            }
	        } while (token && !found);
	        if (!matchType)
	            return;

	        var range, pos;
	        if (matchType === 'bracket') {
	            range = this.session.getBracketRange(cursor);
	            if (!range) {
	                range = new Range(
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1,
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1
	                );
	                pos = range.start;
	                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    range = this.session.getBracketRange(pos);
	            }
	        }
	        else if (matchType === 'tag') {
	            if (token && token.type.indexOf('tag-name') !== -1) 
	                var tag = token.value;
	            else
	                return;

	            range = new Range(
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2,
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2
	            );
	            if (range.compare(cursor.row, cursor.column) === 0) {
	                found = false;
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (prevToken) {
	                        if (prevToken.type.indexOf('tag-close') !== -1) {
	                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
	                        }

	                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                            if (prevToken.value === '<') {
	                                depth[tag]++;
	                            }
	                            else if (prevToken.value === '</') {
	                                depth[tag]--;
	                            }
	                            
	                            if (depth[tag] === 0)
	                                found = true;
	                        }
	                    }
	                } while (prevToken && !found);
	            }
	            if (token && token.type.indexOf('tag-name')) {
	                pos = range.start;
	                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    pos = range.end;
	            }
	        }

	        pos = range && range.cursor || pos;
	        if (pos) {
	            if (select) {
	                if (range && expand) {
	                    this.selection.setRange(range);
	                } else if (range && range.isEqual(this.getSelectionRange())) {
	                    this.clearSelection();
	                } else {
	                    this.selection.selectTo(pos.row, pos.column);
	                }
	            } else {
	                this.selection.moveTo(pos.row, pos.column);
	            }
	        }
	    };
	    this.gotoLine = function(lineNumber, column, animate) {
	        this.selection.clearSelection();
	        this.session.unfold({row: lineNumber - 1, column: column || 0});

	        this.$blockScrolling += 1;
	        this.exitMultiSelectMode && this.exitMultiSelectMode();
	        this.moveCursorTo(lineNumber - 1, column || 0);
	        this.$blockScrolling -= 1;

	        if (!this.isRowFullyVisible(lineNumber - 1))
	            this.scrollToLine(lineNumber - 1, true, animate);
	    };
	    this.navigateTo = function(row, column) {
	        this.selection.moveTo(row, column);
	    };
	    this.navigateUp = function(times) {
	        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
	            var selectionStart = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionStart);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(-times || -1, 0);
	    };
	    this.navigateDown = function(times) {
	        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
	            var selectionEnd = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionEnd);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(times || 1, 0);
	    };
	    this.navigateLeft = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionStart = this.getSelectionRange().start;
	            this.moveCursorToPosition(selectionStart);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorLeft();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateRight = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionEnd = this.getSelectionRange().end;
	            this.moveCursorToPosition(selectionEnd);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorRight();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateLineStart = function() {
	        this.selection.moveCursorLineStart();
	        this.clearSelection();
	    };
	    this.navigateLineEnd = function() {
	        this.selection.moveCursorLineEnd();
	        this.clearSelection();
	    };
	    this.navigateFileEnd = function() {
	        this.selection.moveCursorFileEnd();
	        this.clearSelection();
	    };
	    this.navigateFileStart = function() {
	        this.selection.moveCursorFileStart();
	        this.clearSelection();
	    };
	    this.navigateWordRight = function() {
	        this.selection.moveCursorWordRight();
	        this.clearSelection();
	    };
	    this.navigateWordLeft = function() {
	        this.selection.moveCursorWordLeft();
	        this.clearSelection();
	    };
	    this.replace = function(replacement, options) {
	        if (options)
	            this.$search.set(options);

	        var range = this.$search.find(this.session);
	        var replaced = 0;
	        if (!range)
	            return replaced;

	        if (this.$tryReplace(range, replacement)) {
	            replaced = 1;
	        }
	        if (range !== null) {
	            this.selection.setSelectionRange(range);
	            this.renderer.scrollSelectionIntoView(range.start, range.end);
	        }

	        return replaced;
	    };
	    this.replaceAll = function(replacement, options) {
	        if (options) {
	            this.$search.set(options);
	        }

	        var ranges = this.$search.findAll(this.session);
	        var replaced = 0;
	        if (!ranges.length)
	            return replaced;

	        this.$blockScrolling += 1;

	        var selection = this.getSelectionRange();
	        this.selection.moveTo(0, 0);

	        for (var i = ranges.length - 1; i >= 0; --i) {
	            if(this.$tryReplace(ranges[i], replacement)) {
	                replaced++;
	            }
	        }

	        this.selection.setSelectionRange(selection);
	        this.$blockScrolling -= 1;

	        return replaced;
	    };

	    this.$tryReplace = function(range, replacement) {
	        var input = this.session.getTextRange(range);
	        replacement = this.$search.replace(input, replacement);
	        if (replacement !== null) {
	            range.end = this.session.replace(range, replacement);
	            return range;
	        } else {
	            return null;
	        }
	    };
	    this.getLastSearchOptions = function() {
	        return this.$search.getOptions();
	    };
	    this.find = function(needle, options, animate) {
	        if (!options)
	            options = {};

	        if (typeof needle == "string" || needle instanceof RegExp)
	            options.needle = needle;
	        else if (typeof needle == "object")
	            oop.mixin(options, needle);

	        var range = this.selection.getRange();
	        if (options.needle == null) {
	            needle = this.session.getTextRange(range)
	                || this.$search.$options.needle;
	            if (!needle) {
	                range = this.session.getWordRange(range.start.row, range.start.column);
	                needle = this.session.getTextRange(range);
	            }
	            this.$search.set({needle: needle});
	        }

	        this.$search.set(options);
	        if (!options.start)
	            this.$search.set({start: range});

	        var newRange = this.$search.find(this.session);
	        if (options.preventScroll)
	            return newRange;
	        if (newRange) {
	            this.revealRange(newRange, animate);
	            return newRange;
	        }
	        if (options.backwards)
	            range.start = range.end;
	        else
	            range.end = range.start;
	        this.selection.setRange(range);
	    };
	    this.findNext = function(options, animate) {
	        this.find({skipCurrent: true, backwards: false}, options, animate);
	    };
	    this.findPrevious = function(options, animate) {
	        this.find(options, {skipCurrent: true, backwards: true}, animate);
	    };

	    this.revealRange = function(range, animate) {
	        this.$blockScrolling += 1;
	        this.session.unfold(range);
	        this.selection.setSelectionRange(range);
	        this.$blockScrolling -= 1;

	        var scrollTop = this.renderer.scrollTop;
	        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
	        if (animate !== false)
	            this.renderer.animateScrolling(scrollTop);
	    };
	    this.undo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().undo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.redo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().redo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.destroy = function() {
	        this.renderer.destroy();
	        this._signal("destroy", this);
	        if (this.session) {
	            this.session.destroy();
	        }
	    };
	    this.setAutoScrollEditorIntoView = function(enable) {
	        if (!enable)
	            return;
	        var rect;
	        var self = this;
	        var shouldScroll = false;
	        if (!this.$scrollAnchor)
	            this.$scrollAnchor = document.createElement("div");
	        var scrollAnchor = this.$scrollAnchor;
	        scrollAnchor.style.cssText = "position:absolute";
	        this.container.insertBefore(scrollAnchor, this.container.firstChild);
	        var onChangeSelection = this.on("changeSelection", function() {
	            shouldScroll = true;
	        });
	        var onBeforeRender = this.renderer.on("beforeRender", function() {
	            if (shouldScroll)
	                rect = self.renderer.container.getBoundingClientRect();
	        });
	        var onAfterRender = this.renderer.on("afterRender", function() {
	            if (shouldScroll && rect && (self.isFocused()
	                || self.searchBox && self.searchBox.isFocused())
	            ) {
	                var renderer = self.renderer;
	                var pos = renderer.$cursorLayer.$pixelPos;
	                var config = renderer.layerConfig;
	                var top = pos.top - config.offset;
	                if (pos.top >= 0 && top + rect.top < 0) {
	                    shouldScroll = true;
	                } else if (pos.top < config.height &&
	                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
	                    shouldScroll = false;
	                } else {
	                    shouldScroll = null;
	                }
	                if (shouldScroll != null) {
	                    scrollAnchor.style.top = top + "px";
	                    scrollAnchor.style.left = pos.left + "px";
	                    scrollAnchor.style.height = config.lineHeight + "px";
	                    scrollAnchor.scrollIntoView(shouldScroll);
	                }
	                shouldScroll = rect = null;
	            }
	        });
	        this.setAutoScrollEditorIntoView = function(enable) {
	            if (enable)
	                return;
	            delete this.setAutoScrollEditorIntoView;
	            this.off("changeSelection", onChangeSelection);
	            this.renderer.off("afterRender", onAfterRender);
	            this.renderer.off("beforeRender", onBeforeRender);
	        };
	    };


	    this.$resetCursorStyle = function() {
	        var style = this.$cursorStyle || "ace";
	        var cursorLayer = this.renderer.$cursorLayer;
	        if (!cursorLayer)
	            return;
	        cursorLayer.setSmoothBlinking(/smooth/.test(style));
	        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
	        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
	    };

	}).call(Editor.prototype);



	config.defineOptions(Editor.prototype, "editor", {
	    selectionStyle: {
	        set: function(style) {
	            this.onSelectionChange();
	            this._signal("changeSelectionStyle", {data: style});
	        },
	        initialValue: "line"
	    },
	    highlightActiveLine: {
	        set: function() {this.$updateHighlightActiveLine();},
	        initialValue: true
	    },
	    highlightSelectedWord: {
	        set: function(shouldHighlight) {this.$onSelectionChange();},
	        initialValue: true
	    },
	    readOnly: {
	        set: function(readOnly) {
	            this.$resetCursorStyle(); 
	        },
	        initialValue: false
	    },
	    cursorStyle: {
	        set: function(val) { this.$resetCursorStyle(); },
	        values: ["ace", "slim", "smooth", "wide"],
	        initialValue: "ace"
	    },
	    mergeUndoDeltas: {
	        values: [false, true, "always"],
	        initialValue: true
	    },
	    behavioursEnabled: {initialValue: true},
	    wrapBehavioursEnabled: {initialValue: true},
	    autoScrollEditorIntoView: {
	        set: function(val) {this.setAutoScrollEditorIntoView(val)}
	    },
	    keyboardHandler: {
	        set: function(val) { this.setKeyboardHandler(val); },
	        get: function() { return this.keybindingId; },
	        handlesSet: true
	    },

	    hScrollBarAlwaysVisible: "renderer",
	    vScrollBarAlwaysVisible: "renderer",
	    highlightGutterLine: "renderer",
	    animatedScroll: "renderer",
	    showInvisibles: "renderer",
	    showPrintMargin: "renderer",
	    printMarginColumn: "renderer",
	    printMargin: "renderer",
	    fadeFoldWidgets: "renderer",
	    showFoldWidgets: "renderer",
	    showLineNumbers: "renderer",
	    showGutter: "renderer",
	    displayIndentGuides: "renderer",
	    fontSize: "renderer",
	    fontFamily: "renderer",
	    maxLines: "renderer",
	    minLines: "renderer",
	    scrollPastEnd: "renderer",
	    fixedWidthGutter: "renderer",
	    theme: "renderer",

	    scrollSpeed: "$mouseHandler",
	    dragDelay: "$mouseHandler",
	    dragEnabled: "$mouseHandler",
	    focusTimout: "$mouseHandler",
	    tooltipFollowsMouse: "$mouseHandler",

	    firstLineNumber: "session",
	    overwrite: "session",
	    newLineMode: "session",
	    useWorker: "session",
	    useSoftTabs: "session",
	    tabSize: "session",
	    wrap: "session",
	    indentedSoftWrap: "session",
	    foldStyle: "session",
	    mode: "session"
	});

	exports.Editor = Editor;
	});

	ace.define("ace/undomanager",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var UndoManager = function() {
	    this.reset();
	};

	(function() {
	    this.execute = function(options) {
	        var deltaSets = options.args[0];
	        this.$doc  = options.args[1];
	        if (options.merge && this.hasUndo()){
	            this.dirtyCounter--;
	            deltaSets = this.$undoStack.pop().concat(deltaSets);
	        }
	        this.$undoStack.push(deltaSets);
	        this.$redoStack = [];
	        if (this.dirtyCounter < 0) {
	            this.dirtyCounter = NaN;
	        }
	        this.dirtyCounter++;
	    };
	    this.undo = function(dontSelect) {
	        var deltaSets = this.$undoStack.pop();
	        var undoSelectionRange = null;
	        if (deltaSets) {
	            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
	            this.$redoStack.push(deltaSets);
	            this.dirtyCounter--;
	        }

	        return undoSelectionRange;
	    };
	    this.redo = function(dontSelect) {
	        var deltaSets = this.$redoStack.pop();
	        var redoSelectionRange = null;
	        if (deltaSets) {
	            redoSelectionRange =
	                this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
	            this.$undoStack.push(deltaSets);
	            this.dirtyCounter++;
	        }
	        return redoSelectionRange;
	    };
	    this.reset = function() {
	        this.$undoStack = [];
	        this.$redoStack = [];
	        this.dirtyCounter = 0;
	    };
	    this.hasUndo = function() {
	        return this.$undoStack.length > 0;
	    };
	    this.hasRedo = function() {
	        return this.$redoStack.length > 0;
	    };
	    this.markClean = function() {
	        this.dirtyCounter = 0;
	    };
	    this.isClean = function() {
	        return this.dirtyCounter === 0;
	    };
	    this.$serializeDeltas = function(deltaSets) {
	        return cloneDeltaSetsObj(deltaSets, $serializeDelta);
	    };
	    this.$deserializeDeltas = function(deltaSets) {
	        return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
	    };
	    
	    function $serializeDelta(delta){
	        return {
	            action: delta.action,
	            start: delta.start,
	            end: delta.end,
	            lines: delta.lines.length == 1 ? null : delta.lines,
	            text: delta.lines.length == 1 ? delta.lines[0] : null
	        };
	    }
	        
	    function $deserializeDelta(delta) {
	        return {
	            action: delta.action,
	            start: delta.start,
	            end: delta.end,
	            lines: delta.lines || [delta.text]
	        };
	    }
	    
	    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
	        var deltaSets_new = new Array(deltaSets_old.length);
	        for (var i = 0; i < deltaSets_old.length; i++) {
	            var deltaSet_old = deltaSets_old[i];
	            var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};
	            
	            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
	                var delta_old = deltaSet_old.deltas[j];
	                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
	            }
	            
	            deltaSets_new[i] = deltaSet_new;
	        }
	        return deltaSets_new;
	    }
	    
	}).call(UndoManager.prototype);

	exports.UndoManager = UndoManager;
	});

	ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Gutter = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_gutter-layer";
	    parentEl.appendChild(this.element);
	    this.setShowFoldWidgets(this.$showFoldWidgets);
	    
	    this.gutterWidth = 0;

	    this.$annotations = [];
	    this.$updateAnnotations = this.$updateAnnotations.bind(this);

	    this.$cells = [];
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.setSession = function(session) {
	        if (this.session)
	            this.session.removeEventListener("change", this.$updateAnnotations);
	        this.session = session;
	        if (session)
	            session.on("change", this.$updateAnnotations);
	    };

	    this.addGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.addGutterDecoration");
	        this.session.addGutterDecoration(row, className);
	    };

	    this.removeGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.removeGutterDecoration");
	        this.session.removeGutterDecoration(row, className);
	    };

	    this.setAnnotations = function(annotations) {
	        this.$annotations = [];
	        for (var i = 0; i < annotations.length; i++) {
	            var annotation = annotations[i];
	            var row = annotation.row;
	            var rowInfo = this.$annotations[row];
	            if (!rowInfo)
	                rowInfo = this.$annotations[row] = {text: []};
	           
	            var annoText = annotation.text;
	            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

	            if (rowInfo.text.indexOf(annoText) === -1)
	                rowInfo.text.push(annoText);

	            var type = annotation.type;
	            if (type == "error")
	                rowInfo.className = " ace_error";
	            else if (type == "warning" && rowInfo.className != " ace_error")
	                rowInfo.className = " ace_warning";
	            else if (type == "info" && (!rowInfo.className))
	                rowInfo.className = " ace_info";
	        }
	    };

	    this.$updateAnnotations = function (delta) {
	        if (!this.$annotations.length)
	            return;
	        var firstRow = delta.start.row;
	        var len = delta.end.row - firstRow;
	        if (len === 0) {
	        } else if (delta.action == 'remove') {
	            this.$annotations.splice(firstRow, len + 1, null);
	        } else {
	            var args = new Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.$annotations.splice.apply(this.$annotations, args);
	        }
	    };

	    this.update = function(config) {
	        var session = this.session;
	        var firstRow = config.firstRow;
	        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
	            session.getLength() - 1);
	        var fold = session.getNextFoldLine(firstRow);
	        var foldStart = fold ? fold.start.row : Infinity;
	        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
	        var breakpoints = session.$breakpoints;
	        var decorations = session.$decorations;
	        var firstLineNumber = session.$firstLineNumber;
	        var lastLineNumber = 0;
	        
	        var gutterRenderer = session.gutterRenderer || this.$renderer;

	        var cell = null;
	        var index = -1;
	        var row = firstRow;
	        while (true) {
	            if (row > foldStart) {
	                row = fold.end.row + 1;
	                fold = session.getNextFoldLine(row, fold);
	                foldStart = fold ? fold.start.row : Infinity;
	            }
	            if (row > lastRow) {
	                while (this.$cells.length > index + 1) {
	                    cell = this.$cells.pop();
	                    this.element.removeChild(cell.element);
	                }
	                break;
	            }

	            cell = this.$cells[++index];
	            if (!cell) {
	                cell = {element: null, textNode: null, foldWidget: null};
	                cell.element = dom.createElement("div");
	                cell.textNode = document.createTextNode('');
	                cell.element.appendChild(cell.textNode);
	                this.element.appendChild(cell.element);
	                this.$cells[index] = cell;
	            }

	            var className = "ace_gutter-cell ";
	            if (breakpoints[row])
	                className += breakpoints[row];
	            if (decorations[row])
	                className += decorations[row];
	            if (this.$annotations[row])
	                className += this.$annotations[row].className;
	            if (cell.element.className != className)
	                cell.element.className = className;

	            var height = session.getRowLength(row) * config.lineHeight + "px";
	            if (height != cell.element.style.height)
	                cell.element.style.height = height;

	            if (foldWidgets) {
	                var c = foldWidgets[row];
	                if (c == null)
	                    c = foldWidgets[row] = session.getFoldWidget(row);
	            }

	            if (c) {
	                if (!cell.foldWidget) {
	                    cell.foldWidget = dom.createElement("span");
	                    cell.element.appendChild(cell.foldWidget);
	                }
	                var className = "ace_fold-widget ace_" + c;
	                if (c == "start" && row == foldStart && row < fold.end.row)
	                    className += " ace_closed";
	                else
	                    className += " ace_open";
	                if (cell.foldWidget.className != className)
	                    cell.foldWidget.className = className;

	                var height = config.lineHeight + "px";
	                if (cell.foldWidget.style.height != height)
	                    cell.foldWidget.style.height = height;
	            } else {
	                if (cell.foldWidget) {
	                    cell.element.removeChild(cell.foldWidget);
	                    cell.foldWidget = null;
	                }
	            }
	            
	            var text = lastLineNumber = gutterRenderer
	                ? gutterRenderer.getText(session, row)
	                : row + firstLineNumber;
	            if (text != cell.textNode.data)
	                cell.textNode.data = text;

	            row++;
	        }

	        this.element.style.height = config.minHeight + "px";

	        if (this.$fixedWidth || session.$useWrapMode)
	            lastLineNumber = session.getLength() + firstLineNumber;

	        var gutterWidth = gutterRenderer 
	            ? gutterRenderer.getWidth(session, lastLineNumber, config)
	            : lastLineNumber.toString().length * config.characterWidth;
	        
	        var padding = this.$padding || this.$computePadding();
	        gutterWidth += padding.left + padding.right;
	        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
	            this.gutterWidth = gutterWidth;
	            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
	            this._emit("changeGutterWidth", gutterWidth);
	        }
	    };

	    this.$fixedWidth = false;
	    
	    this.$showLineNumbers = true;
	    this.$renderer = "";
	    this.setShowLineNumbers = function(show) {
	        this.$renderer = !show && {
	            getWidth: function() {return ""},
	            getText: function() {return ""}
	        };
	    };
	    
	    this.getShowLineNumbers = function() {
	        return this.$showLineNumbers;
	    };
	    
	    this.$showFoldWidgets = true;
	    this.setShowFoldWidgets = function(show) {
	        if (show)
	            dom.addCssClass(this.element, "ace_folding-enabled");
	        else
	            dom.removeCssClass(this.element, "ace_folding-enabled");

	        this.$showFoldWidgets = show;
	        this.$padding = null;
	    };
	    
	    this.getShowFoldWidgets = function() {
	        return this.$showFoldWidgets;
	    };

	    this.$computePadding = function() {
	        if (!this.element.firstChild)
	            return {left: 0, right: 0};
	        var style = dom.computedStyle(this.element.firstChild);
	        this.$padding = {};
	        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
	        this.$padding.right = parseInt(style.paddingRight) || 0;
	        return this.$padding;
	    };

	    this.getRegion = function(point) {
	        var padding = this.$padding || this.$computePadding();
	        var rect = this.element.getBoundingClientRect();
	        if (point.x < padding.left + rect.left)
	            return "markers";
	        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
	            return "foldWidgets";
	    };

	}).call(Gutter.prototype);

	exports.Gutter = Gutter;

	});

	ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var dom = acequire("../lib/dom");

	var Marker = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_marker-layer";
	    parentEl.appendChild(this.element);
	};

	(function() {

	    this.$padding = 0;

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };
	    this.setSession = function(session) {
	        this.session = session;
	    };
	    
	    this.setMarkers = function(markers) {
	        this.markers = markers;
	    };

	    this.update = function(config) {
	        var config = config || this.config;
	        if (!config)
	            return;

	        this.config = config;


	        var html = [];
	        for (var key in this.markers) {
	            var marker = this.markers[key];

	            if (!marker.range) {
	                marker.update(html, this, this.session, config);
	                continue;
	            }

	            var range = marker.range.clipRows(config.firstRow, config.lastRow);
	            if (range.isEmpty()) continue;

	            range = range.toScreenRange(this.session);
	            if (marker.renderer) {
	                var top = this.$getTop(range.start.row, config);
	                var left = this.$padding + range.start.column * config.characterWidth;
	                marker.renderer(html, range, left, top, config);
	            } else if (marker.type == "fullLine") {
	                this.drawFullLineMarker(html, range, marker.clazz, config);
	            } else if (marker.type == "screenLine") {
	                this.drawScreenLineMarker(html, range, marker.clazz, config);
	            } else if (range.isMultiLine()) {
	                if (marker.type == "text")
	                    this.drawTextMarker(html, range, marker.clazz, config);
	                else
	                    this.drawMultiLineMarker(html, range, marker.clazz, config);
	            } else {
	                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
	            }
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$getTop = function(row, layerConfig) {
	        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
	    };

	    function getBorderClass(tl, tr, br, bl) {
	        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
	    }
	    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
	        var session = this.session;
	        var start = range.start.row;
	        var end = range.end.row;
	        var row = start;
	        var prev = 0; 
	        var curr = 0;
	        var next = session.getScreenLastRowColumn(row);
	        var lineRange = new Range(row, range.start.column, row, curr);
	        for (; row <= end; row++) {
	            lineRange.start.row = lineRange.end.row = row;
	            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
	            lineRange.end.column = next;
	            prev = curr;
	            curr = next;
	            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
	            this.drawSingleLineMarker(stringBuilder, lineRange, 
	                clazz + (row == start  ? " ace_start" : "") + " ace_br"
	                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
	                layerConfig, row == end ? 0 : 1, extraStyle);
	        }
	    };
	    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var padding = this.$padding;
	        var height = config.lineHeight;
	        var top = this.$getTop(range.start.row, config);
	        var left = padding + range.start.column * config.characterWidth;
	        extraStyle = extraStyle || "";

	        stringBuilder.push(
	            "<div class='", clazz, " ace_br1 ace_start' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle, "'></div>"
	        );
	        top = this.$getTop(range.end.row, config);
	        var width = range.end.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, " ace_br12' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	        height = (range.end.row - range.start.row - 1) * config.lineHeight;
	        if (height <= 0)
	            return;
	        top = this.$getTop(range.start.row + 1, config);
	        
	        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

	        stringBuilder.push(
	            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	    };
	    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
	        var height = config.lineHeight;
	        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

	        var top = this.$getTop(range.start.row, config);
	        var left = this.$padding + range.start.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle || "", "'></div>"
	        );
	    };

	    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;
	        if (range.start.row != range.end.row)
	            height += this.$getTop(range.end.row, config) - top;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };
	    
	    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };

	}).call(Marker.prototype);

	exports.Marker = Marker;

	});

	ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Text = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_text-layer";
	    parentEl.appendChild(this.element);
	    this.$updateEolChar = this.$updateEolChar.bind(this);
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.EOF_CHAR = "\xB6";
	    this.EOL_CHAR_LF = "\xAC";
	    this.EOL_CHAR_CRLF = "\xa4";
	    this.EOL_CHAR = this.EOL_CHAR_LF;
	    this.TAB_CHAR = "\u2014"; //"\u21E5";
	    this.SPACE_CHAR = "\xB7";
	    this.$padding = 0;

	    this.$updateEolChar = function() {
	        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
	           ? this.EOL_CHAR_LF
	           : this.EOL_CHAR_CRLF;
	        if (this.EOL_CHAR != EOL_CHAR) {
	            this.EOL_CHAR = EOL_CHAR;
	            return true;
	        }
	    }

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.element.style.padding = "0 " + padding + "px";
	    };

	    this.getLineHeight = function() {
	        return this.$fontMetrics.$characterSize.height || 0;
	    };

	    this.getCharacterWidth = function() {
	        return this.$fontMetrics.$characterSize.width || 0;
	    };
	    
	    this.$setFontMetrics = function(measure) {
	        this.$fontMetrics = measure;
	        this.$fontMetrics.on("changeCharacterSize", function(e) {
	            this._signal("changeCharacterSize", e);
	        }.bind(this));
	        this.$pollSizeChanges();
	    }

	    this.checkForSizeChanges = function() {
	        this.$fontMetrics.checkForSizeChanges();
	    };
	    this.$pollSizeChanges = function() {
	        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
	    };
	    this.setSession = function(session) {
	        this.session = session;
	        if (session)
	            this.$computeTabString();
	    };

	    this.showInvisibles = false;
	    this.setShowInvisibles = function(showInvisibles) {
	        if (this.showInvisibles == showInvisibles)
	            return false;

	        this.showInvisibles = showInvisibles;
	        this.$computeTabString();
	        return true;
	    };

	    this.displayIndentGuides = true;
	    this.setDisplayIndentGuides = function(display) {
	        if (this.displayIndentGuides == display)
	            return false;

	        this.displayIndentGuides = display;
	        this.$computeTabString();
	        return true;
	    };

	    this.$tabStrings = [];
	    this.onChangeTabSize =
	    this.$computeTabString = function() {
	        var tabSize = this.session.getTabSize();
	        this.tabSize = tabSize;
	        var tabStr = this.$tabStrings = [0];
	        for (var i = 1; i < tabSize + 1; i++) {
	            if (this.showInvisibles) {
	                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
	                    + lang.stringRepeat(this.TAB_CHAR, i)
	                    + "</span>");
	            } else {
	                tabStr.push(lang.stringRepeat(" ", i));
	            }
	        }
	        if (this.displayIndentGuides) {
	            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
	            var className = "ace_indent-guide";
	            var spaceClass = "";
	            var tabClass = "";
	            if (this.showInvisibles) {
	                className += " ace_invisible";
	                spaceClass = " ace_invisible_space";
	                tabClass = " ace_invisible_tab";
	                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
	                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
	            } else{
	                var spaceContent = lang.stringRepeat(" ", this.tabSize);
	                var tabContent = spaceContent;
	            }

	            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
	            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
	        }
	    };

	    this.updateLines = function(config, firstRow, lastRow) {
	        if (this.config.lastRow != config.lastRow ||
	            this.config.firstRow != config.firstRow) {
	            this.scrollLines(config);
	        }
	        this.config = config;

	        var first = Math.max(firstRow, config.firstRow);
	        var last = Math.min(lastRow, config.lastRow);

	        var lineElements = this.element.childNodes;
	        var lineElementsIdx = 0;

	        for (var row = config.firstRow; row < first; row++) {
	            var foldLine = this.session.getFoldLine(row);
	            if (foldLine) {
	                if (foldLine.containsRow(first)) {
	                    first = foldLine.start.row;
	                    break;
	                } else {
	                    row = foldLine.end.row;
	                }
	            }
	            lineElementsIdx ++;
	        }

	        var row = first;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > last)
	                break;

	            var lineElement = lineElements[lineElementsIdx++];
	            if (lineElement) {
	                var html = [];
	                this.$renderLine(
	                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
	                );
	                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
	                lineElement.innerHTML = html.join("");
	            }
	            row++;
	        }
	    };

	    this.scrollLines = function(config) {
	        var oldConfig = this.config;
	        this.config = config;

	        if (!oldConfig || oldConfig.lastRow < config.firstRow)
	            return this.update(config);

	        if (config.lastRow < oldConfig.firstRow)
	            return this.update(config);

	        var el = this.element;
	        if (oldConfig.firstRow < config.firstRow)
	            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
	                el.removeChild(el.firstChild);

	        if (oldConfig.lastRow > config.lastRow)
	            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
	                el.removeChild(el.lastChild);

	        if (config.firstRow < oldConfig.firstRow) {
	            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
	            if (el.firstChild)
	                el.insertBefore(fragment, el.firstChild);
	            else
	                el.appendChild(fragment);
	        }

	        if (config.lastRow > oldConfig.lastRow) {
	            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
	            el.appendChild(fragment);
	        }
	    };

	    this.$renderLinesFragment = function(config, firstRow, lastRow) {
	        var fragment = this.element.ownerDocument.createDocumentFragment();
	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > lastRow)
	                break;

	            var container = dom.createElement("div");

	            var html = [];
	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
	            container.innerHTML = html.join("");
	            if (this.$useLineGroups()) {
	                container.className = 'ace_line_group';
	                fragment.appendChild(container);
	                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

	            } else {
	                while(container.firstChild)
	                    fragment.appendChild(container.firstChild);
	            }

	            row++;
	        }
	        return fragment;
	    };

	    this.update = function(config) {
	        this.config = config;

	        var html = [];
	        var firstRow = config.firstRow, lastRow = config.lastRow;

	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > lastRow)
	                break;

	            if (this.$useLineGroups())
	                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

	            if (this.$useLineGroups())
	                html.push("</div>"); // end the line group

	            row++;
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$textToken = {
	        "text": true,
	        "rparen": true,
	        "lparen": true
	    };

	    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
	        var self = this;
	        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
	        var replaceFunc = function(c, a, b, tabIdx, idx4) {
	            if (a) {
	                return self.showInvisibles
	                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
	                    : c;
	            } else if (c == "&") {
	                return "&#38;";
	            } else if (c == "<") {
	                return "&#60;";
	            } else if (c == ">") {
	                return "&#62;";
	            } else if (c == "\t") {
	                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
	                screenColumn += tabSize - 1;
	                return self.$tabStrings[tabSize];
	            } else if (c == "\u3000") {
	                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
	                var space = self.showInvisibles ? self.SPACE_CHAR : "";
	                screenColumn += 1;
	                return "<span class='" + classToUse + "' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + space + "</span>";
	            } else if (b) {
	                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
	            } else {
	                screenColumn += 1;
	                return "<span class='ace_cjk' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + c + "</span>";
	            }
	        };

	        var output = value.replace(replaceReg, replaceFunc);

	        if (!this.$textToken[token.type]) {
	            var classes = "ace_" + token.type.replace(/\./g, " ace_");
	            var style = "";
	            if (token.type == "fold")
	                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
	            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
	        }
	        else {
	            stringBuilder.push(output);
	        }
	        return screenColumn + value.length;
	    };

	    this.renderIndentGuide = function(stringBuilder, value, max) {
	        var cols = value.search(this.$indentGuideRe);
	        if (cols <= 0 || cols >= max)
	            return value;
	        if (value[0] == " ") {
	            cols -= cols % this.tabSize;
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
	            return value.substr(cols);
	        } else if (value[0] == "\t") {
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
	            return value.substr(cols);
	        }
	        return value;
	    };

	    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
	        var chars = 0;
	        var split = 0;
	        var splitChars = splits[0];
	        var screenColumn = 0;

	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var value = token.value;
	            if (i == 0 && this.displayIndentGuides) {
	                chars = value.length;
	                value = this.renderIndentGuide(stringBuilder, value, splitChars);
	                if (!value)
	                    continue;
	                chars -= value.length;
	            }

	            if (chars + value.length < splitChars) {
	                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	                chars += value.length;
	            } else {
	                while (chars + value.length >= splitChars) {
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn,
	                        token, value.substring(0, splitChars - chars)
	                    );
	                    value = value.substring(splitChars - chars);
	                    chars = splitChars;

	                    if (!onlyContents) {
	                        stringBuilder.push("</div>",
	                            "<div class='ace_line' style='height:",
	                            this.config.lineHeight, "px'>"
	                        );
	                    }

	                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

	                    split ++;
	                    screenColumn = 0;
	                    splitChars = splits[split] || Number.MAX_VALUE;
	                }
	                if (value.length != 0) {
	                    chars += value.length;
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn, token, value
	                    );
	                }
	            }
	        }
	    };

	    this.$renderSimpleLine = function(stringBuilder, tokens) {
	        var screenColumn = 0;
	        var token = tokens[0];
	        var value = token.value;
	        if (this.displayIndentGuides)
	            value = this.renderIndentGuide(stringBuilder, value);
	        if (value)
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        for (var i = 1; i < tokens.length; i++) {
	            token = tokens[i];
	            value = token.value;
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        }
	    };
	    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
	        if (!foldLine && foldLine != false)
	            foldLine = this.session.getFoldLine(row);

	        if (foldLine)
	            var tokens = this.$getFoldLineTokens(row, foldLine);
	        else
	            var tokens = this.session.getTokens(row);


	        if (!onlyContents) {
	            stringBuilder.push(
	                "<div class='ace_line' style='height:", 
	                    this.config.lineHeight * (
	                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
	                    ), "px'>"
	            );
	        }

	        if (tokens.length) {
	            var splits = this.session.getRowSplitData(row);
	            if (splits && splits.length)
	                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
	            else
	                this.$renderSimpleLine(stringBuilder, tokens);
	        }

	        if (this.showInvisibles) {
	            if (foldLine)
	                row = foldLine.end.row

	            stringBuilder.push(
	                "<span class='ace_invisible ace_invisible_eol'>",
	                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
	                "</span>"
	            );
	        }
	        if (!onlyContents)
	            stringBuilder.push("</div>");
	    };

	    this.$getFoldLineTokens = function(row, foldLine) {
	        var session = this.session;
	        var renderTokens = [];

	        function addTokens(tokens, from, to) {
	            var idx = 0, col = 0;
	            while ((col + tokens[idx].value.length) < from) {
	                col += tokens[idx].value.length;
	                idx++;

	                if (idx == tokens.length)
	                    return;
	            }
	            if (col != from) {
	                var value = tokens[idx].value.substring(from - col);
	                if (value.length > (to - from))
	                    value = value.substring(0, to - from);

	                renderTokens.push({
	                    type: tokens[idx].type,
	                    value: value
	                });

	                col = from + value.length;
	                idx += 1;
	            }

	            while (col < to && idx < tokens.length) {
	                var value = tokens[idx].value;
	                if (value.length + col > to) {
	                    renderTokens.push({
	                        type: tokens[idx].type,
	                        value: value.substring(0, to - col)
	                    });
	                } else
	                    renderTokens.push(tokens[idx]);
	                col += value.length;
	                idx += 1;
	            }
	        }

	        var tokens = session.getTokens(row);
	        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
	            if (placeholder != null) {
	                renderTokens.push({
	                    type: "fold",
	                    value: placeholder
	                });
	            } else {
	                if (isNewRow)
	                    tokens = session.getTokens(row);

	                if (tokens.length)
	                    addTokens(tokens, lastColumn, column);
	            }
	        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

	        return renderTokens;
	    };

	    this.$useLineGroups = function() {
	        return this.session.getUseWrapMode();
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.$measureNode)
	            this.$measureNode.parentNode.removeChild(this.$measureNode);
	        delete this.$measureNode;
	    };

	}).call(Text.prototype);

	exports.Text = Text;

	});

	ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var isIE8;

	var Cursor = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_cursor-layer";
	    parentEl.appendChild(this.element);
	    
	    if (isIE8 === undefined)
	        isIE8 = !("opacity" in this.element.style);

	    this.isVisible = false;
	    this.isBlinking = true;
	    this.blinkInterval = 1000;
	    this.smoothBlinking = false;

	    this.cursors = [];
	    this.cursor = this.addCursor();
	    dom.addCssClass(this.element, "ace_hidden-cursors");
	    this.$updateCursors = (isIE8
	        ? this.$updateVisibility
	        : this.$updateOpacity).bind(this);
	};

	(function() {
	    
	    this.$updateVisibility = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.visibility = val ? "" : "hidden";
	    };
	    this.$updateOpacity = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.opacity = val ? "" : "0";
	    };
	    

	    this.$padding = 0;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };

	    this.setSession = function(session) {
	        this.session = session;
	    };

	    this.setBlinking = function(blinking) {
	        if (blinking != this.isBlinking){
	            this.isBlinking = blinking;
	            this.restartTimer();
	        }
	    };

	    this.setBlinkInterval = function(blinkInterval) {
	        if (blinkInterval != this.blinkInterval){
	            this.blinkInterval = blinkInterval;
	            this.restartTimer();
	        }
	    };

	    this.setSmoothBlinking = function(smoothBlinking) {
	        if (smoothBlinking != this.smoothBlinking && !isIE8) {
	            this.smoothBlinking = smoothBlinking;
	            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
	            this.$updateCursors(true);
	            this.$updateCursors = (this.$updateOpacity).bind(this);
	            this.restartTimer();
	        }
	    };

	    this.addCursor = function() {
	        var el = dom.createElement("div");
	        el.className = "ace_cursor";
	        this.element.appendChild(el);
	        this.cursors.push(el);
	        return el;
	    };

	    this.removeCursor = function() {
	        if (this.cursors.length > 1) {
	            var el = this.cursors.pop();
	            el.parentNode.removeChild(el);
	            return el;
	        }
	    };

	    this.hideCursor = function() {
	        this.isVisible = false;
	        dom.addCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.showCursor = function() {
	        this.isVisible = true;
	        dom.removeCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.restartTimer = function() {
	        var update = this.$updateCursors;
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	        if (this.smoothBlinking) {
	            dom.removeCssClass(this.element, "ace_smooth-blinking");
	        }
	        
	        update(true);

	        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
	            return;

	        if (this.smoothBlinking) {
	            setTimeout(function(){
	                dom.addCssClass(this.element, "ace_smooth-blinking");
	            }.bind(this));
	        }
	        
	        var blink = function(){
	            this.timeoutId = setTimeout(function() {
	                update(false);
	            }, 0.6 * this.blinkInterval);
	        }.bind(this);

	        this.intervalId = setInterval(function() {
	            update(true);
	            blink();
	        }, this.blinkInterval);

	        blink();
	    };

	    this.getPixelPosition = function(position, onScreen) {
	        if (!this.config || !this.session)
	            return {left : 0, top : 0};

	        if (!position)
	            position = this.session.selection.getCursor();
	        var pos = this.session.documentToScreenPosition(position);
	        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
	        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
	            this.config.lineHeight;

	        return {left : cursorLeft, top : cursorTop};
	    };

	    this.update = function(config) {
	        this.config = config;

	        var selections = this.session.$selectionMarkers;
	        var i = 0, cursorIndex = 0;

	        if (selections === undefined || selections.length === 0){
	            selections = [{cursor: null}];
	        }

	        for (var i = 0, n = selections.length; i < n; i++) {
	            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
	            if ((pixelPos.top > config.height + config.offset ||
	                 pixelPos.top < 0) && i > 1) {
	                continue;
	            }

	            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
	            
	            if (!this.drawCursor) {
	                style.left = pixelPos.left + "px";
	                style.top = pixelPos.top + "px";
	                style.width = config.characterWidth + "px";
	                style.height = config.lineHeight + "px";
	            } else {
	                this.drawCursor(style, pixelPos, config, selections[i], this.session);
	            }
	        }
	        while (this.cursors.length > cursorIndex)
	            this.removeCursor();

	        var overwrite = this.session.getOverwrite();
	        this.$setOverwrite(overwrite);
	        this.$pixelPos = pixelPos;
	        this.restartTimer();
	    };
	    
	    this.drawCursor = null;

	    this.$setOverwrite = function(overwrite) {
	        if (overwrite != this.overwrite) {
	            this.overwrite = overwrite;
	            if (overwrite)
	                dom.addCssClass(this.element, "ace_overwrite-cursors");
	            else
	                dom.removeCssClass(this.element, "ace_overwrite-cursors");
	        }
	    };

	    this.destroy = function() {
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	    };

	}).call(Cursor.prototype);

	exports.Cursor = Cursor;

	});

	ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var ScrollBar = function(parent) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

	    this.inner = dom.createElement("div");
	    this.inner.className = "ace_scrollbar-inner";
	    this.element.appendChild(this.inner);

	    parent.appendChild(this.element);

	    this.setVisible(false);
	    this.skipEvent = false;

	    event.addListener(this.element, "scroll", this.onScroll.bind(this));
	    event.addListener(this.element, "mousedown", event.preventDefault);
	};

	(function() {
	    oop.implement(this, EventEmitter);

	    this.setVisible = function(isVisible) {
	        this.element.style.display = isVisible ? "" : "none";
	        this.isVisible = isVisible;
	    };
	}).call(ScrollBar.prototype);
	var VScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollTop = 0;
	    renderer.$scrollbarWidth = 
	    this.width = dom.scrollbarWidth(parent.ownerDocument);
	    this.inner.style.width =
	    this.element.style.width = (this.width || 15) + 5 + "px";
	};

	oop.inherits(VScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-v';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollTop = this.element.scrollTop;
	            this._emit("scroll", {data: this.scrollTop});
	        }
	        this.skipEvent = false;
	    };
	    this.getWidth = function() {
	        return this.isVisible ? this.width : 0;
	    };
	    this.setHeight = function(height) {
	        this.element.style.height = height + "px";
	    };
	    this.setInnerHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollTop = function(scrollTop) {
	        if (this.scrollTop != scrollTop) {
	            this.skipEvent = true;
	            this.scrollTop = this.element.scrollTop = scrollTop;
	        }
	    };

	}).call(VScrollBar.prototype);
	var HScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollLeft = 0;
	    this.height = renderer.$scrollbarWidth;
	    this.inner.style.height =
	    this.element.style.height = (this.height || 15) + 5 + "px";
	};

	oop.inherits(HScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-h';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollLeft = this.element.scrollLeft;
	            this._emit("scroll", {data: this.scrollLeft});
	        }
	        this.skipEvent = false;
	    };
	    this.getHeight = function() {
	        return this.isVisible ? this.height : 0;
	    };
	    this.setWidth = function(width) {
	        this.element.style.width = width + "px";
	    };
	    this.setInnerWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.scrollLeft != scrollLeft) {
	            this.skipEvent = true;
	            this.scrollLeft = this.element.scrollLeft = scrollLeft;
	        }
	    };

	}).call(HScrollBar.prototype);


	exports.ScrollBar = VScrollBar; // backward compatibility
	exports.ScrollBarV = VScrollBar; // backward compatibility
	exports.ScrollBarH = HScrollBar; // backward compatibility

	exports.VScrollBar = VScrollBar;
	exports.HScrollBar = HScrollBar;
	});

	ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("./lib/event");


	var RenderLoop = function(onRender, win) {
	    this.onRender = onRender;
	    this.pending = false;
	    this.changes = 0;
	    this.window = win || window;
	};

	(function() {


	    this.schedule = function(change) {
	        this.changes = this.changes | change;
	        if (!this.pending && this.changes) {
	            this.pending = true;
	            var _self = this;
	            event.nextFrame(function() {
	                _self.pending = false;
	                var changes;
	                while (changes = _self.changes) {
	                    _self.changes = 0;
	                    _self.onRender(changes);
	                }
	            }, this.window);
	        }
	    };

	}).call(RenderLoop.prototype);

	exports.RenderLoop = RenderLoop;
	});

	ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CHAR_COUNT = 0;

	var FontMetrics = exports.FontMetrics = function(parentEl) {
	    this.el = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.el.style, true);
	    
	    this.$main = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$main.style);
	    
	    this.$measureNode = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$measureNode.style);
	    
	    
	    this.el.appendChild(this.$main);
	    this.el.appendChild(this.$measureNode);
	    parentEl.appendChild(this.el);
	    
	    if (!CHAR_COUNT)
	        this.$testFractionalRect();
	    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
	    
	    this.$characterSize = {width: 0, height: 0};
	    this.checkForSizeChanges();
	};

	(function() {

	    oop.implement(this, EventEmitter);
	        
	    this.$characterSize = {width: 0, height: 0};
	    
	    this.$testFractionalRect = function() {
	        var el = dom.createElement("div");
	        this.$setMeasureNodeStyles(el.style);
	        el.style.width = "0.2px";
	        document.documentElement.appendChild(el);
	        var w = el.getBoundingClientRect().width;
	        if (w > 0 && w < 1)
	            CHAR_COUNT = 50;
	        else
	            CHAR_COUNT = 100;
	        el.parentNode.removeChild(el);
	    };
	    
	    this.$setMeasureNodeStyles = function(style, isRoot) {
	        style.width = style.height = "auto";
	        style.left = style.top = "0px";
	        style.visibility = "hidden";
	        style.position = "absolute";
	        style.whiteSpace = "pre";

	        if (useragent.isIE < 8) {
	            style["font-family"] = "inherit";
	        } else {
	            style.font = "inherit";
	        }
	        style.overflow = isRoot ? "hidden" : "visible";
	    };

	    this.checkForSizeChanges = function() {
	        var size = this.$measureSizes();
	        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
	            this.$measureNode.style.fontWeight = "bold";
	            var boldSize = this.$measureSizes();
	            this.$measureNode.style.fontWeight = "";
	            this.$characterSize = size;
	            this.charSizes = Object.create(null);
	            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
	            this._emit("changeCharacterSize", {data: size});
	        }
	    };

	    this.$pollSizeChanges = function() {
	        if (this.$pollSizeChangesTimer)
	            return this.$pollSizeChangesTimer;
	        var self = this;
	        return this.$pollSizeChangesTimer = setInterval(function() {
	            self.checkForSizeChanges();
	        }, 500);
	    };
	    
	    this.setPolling = function(val) {
	        if (val) {
	            this.$pollSizeChanges();
	        } else if (this.$pollSizeChangesTimer) {
	            clearInterval(this.$pollSizeChangesTimer);
	            this.$pollSizeChangesTimer = 0;
	        }
	    };

	    this.$measureSizes = function() {
	        if (CHAR_COUNT === 50) {
	            var rect = null;
	            try { 
	               rect = this.$measureNode.getBoundingClientRect();
	            } catch(e) {
	               rect = {width: 0, height:0 };
	            }
	            var size = {
	                height: rect.height,
	                width: rect.width / CHAR_COUNT
	            };
	        } else {
	            var size = {
	                height: this.$measureNode.clientHeight,
	                width: this.$measureNode.clientWidth / CHAR_COUNT
	            };
	        }
	        if (size.width === 0 || size.height === 0)
	            return null;
	        return size;
	    };

	    this.$measureCharWidth = function(ch) {
	        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
	        var rect = this.$main.getBoundingClientRect();
	        return rect.width / CHAR_COUNT;
	    };
	    
	    this.getCharacterWidth = function(ch) {
	        var w = this.charSizes[ch];
	        if (w === undefined) {
	            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
	        }
	        return w;
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.el && this.el.parentNode)
	            this.el.parentNode.removeChild(this.el);
	    };

	}).call(FontMetrics.prototype);

	});

	ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var config = acequire("./config");
	var useragent = acequire("./lib/useragent");
	var GutterLayer = acequire("./layer/gutter").Gutter;
	var MarkerLayer = acequire("./layer/marker").Marker;
	var TextLayer = acequire("./layer/text").Text;
	var CursorLayer = acequire("./layer/cursor").Cursor;
	var HScrollBar = acequire("./scrollbar").HScrollBar;
	var VScrollBar = acequire("./scrollbar").VScrollBar;
	var RenderLoop = acequire("./renderloop").RenderLoop;
	var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var editorCss = ".ace_editor {\
	position: relative;\
	overflow: hidden;\
	font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
	direction: ltr;\
	}\
	.ace_scroller {\
	position: absolute;\
	overflow: hidden;\
	top: 0;\
	bottom: 0;\
	background-color: inherit;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	cursor: text;\
	}\
	.ace_content {\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	min-width: 100%;\
	}\
	.ace_dragging .ace_scroller:before{\
	position: absolute;\
	top: 0;\
	left: 0;\
	right: 0;\
	bottom: 0;\
	content: '';\
	background: rgba(250, 250, 250, 0.01);\
	z-index: 1000;\
	}\
	.ace_dragging.ace_dark .ace_scroller:before{\
	background: rgba(0, 0, 0, 0.01);\
	}\
	.ace_selecting, .ace_selecting * {\
	cursor: text !important;\
	}\
	.ace_gutter {\
	position: absolute;\
	overflow : hidden;\
	width: auto;\
	top: 0;\
	bottom: 0;\
	left: 0;\
	cursor: default;\
	z-index: 4;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	}\
	.ace_gutter-active-line {\
	position: absolute;\
	left: 0;\
	right: 0;\
	}\
	.ace_scroller.ace_scroll-left {\
	box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
	}\
	.ace_gutter-cell {\
	padding-left: 19px;\
	padding-right: 6px;\
	background-repeat: no-repeat;\
	}\
	.ace_gutter-cell.ace_error {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_warning {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
	background-position: 2px center;\
	}\
	.ace_dark .ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
	}\
	.ace_scrollbar {\
	position: absolute;\
	right: 0;\
	bottom: 0;\
	z-index: 6;\
	}\
	.ace_scrollbar-inner {\
	position: absolute;\
	cursor: text;\
	left: 0;\
	top: 0;\
	}\
	.ace_scrollbar-v{\
	overflow-x: hidden;\
	overflow-y: scroll;\
	top: 0;\
	}\
	.ace_scrollbar-h {\
	overflow-x: scroll;\
	overflow-y: hidden;\
	left: 0;\
	}\
	.ace_print-margin {\
	position: absolute;\
	height: 100%;\
	}\
	.ace_text-input {\
	position: absolute;\
	z-index: 0;\
	width: 0.5em;\
	height: 1em;\
	opacity: 0;\
	background: transparent;\
	-moz-appearance: none;\
	appearance: none;\
	border: none;\
	resize: none;\
	outline: none;\
	overflow: hidden;\
	font: inherit;\
	padding: 0 1px;\
	margin: 0 -1px;\
	text-indent: -1em;\
	-ms-user-select: text;\
	-moz-user-select: text;\
	-webkit-user-select: text;\
	user-select: text;\
	white-space: pre!important;\
	}\
	.ace_text-input.ace_composition {\
	background: inherit;\
	color: inherit;\
	z-index: 1000;\
	opacity: 1;\
	text-indent: 0;\
	}\
	.ace_layer {\
	z-index: 1;\
	position: absolute;\
	overflow: hidden;\
	word-wrap: normal;\
	white-space: pre;\
	height: 100%;\
	width: 100%;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	pointer-events: none;\
	}\
	.ace_gutter-layer {\
	position: relative;\
	width: auto;\
	text-align: right;\
	pointer-events: auto;\
	}\
	.ace_text-layer {\
	font: inherit !important;\
	}\
	.ace_cjk {\
	display: inline-block;\
	text-align: center;\
	}\
	.ace_cursor-layer {\
	z-index: 4;\
	}\
	.ace_cursor {\
	z-index: 4;\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	border-left: 2px solid;\
	transform: translatez(0);\
	}\
	.ace_slim-cursors .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_overwrite-cursors .ace_cursor {\
	border-left-width: 0;\
	border-bottom: 1px solid;\
	}\
	.ace_hidden-cursors .ace_cursor {\
	opacity: 0.2;\
	}\
	.ace_smooth-blinking .ace_cursor {\
	-webkit-transition: opacity 0.18s;\
	transition: opacity 0.18s;\
	}\
	.ace_editor.ace_multiselect .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
	position: absolute;\
	z-index: 3;\
	}\
	.ace_marker-layer .ace_selection {\
	position: absolute;\
	z-index: 5;\
	}\
	.ace_marker-layer .ace_bracket {\
	position: absolute;\
	z-index: 6;\
	}\
	.ace_marker-layer .ace_active-line {\
	position: absolute;\
	z-index: 2;\
	}\
	.ace_marker-layer .ace_selected-word {\
	position: absolute;\
	z-index: 4;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	}\
	.ace_line .ace_fold {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	display: inline-block;\
	height: 11px;\
	margin-top: -2px;\
	vertical-align: middle;\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
	background-repeat: no-repeat, repeat-x;\
	background-position: center center, top left;\
	color: transparent;\
	border: 1px solid black;\
	border-radius: 2px;\
	cursor: pointer;\
	pointer-events: auto;\
	}\
	.ace_dark .ace_fold {\
	}\
	.ace_fold:hover{\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
	}\
	.ace_tooltip {\
	background-color: #FFF;\
	background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
	background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
	border: 1px solid gray;\
	border-radius: 1px;\
	box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
	color: black;\
	max-width: 100%;\
	padding: 3px 4px;\
	position: fixed;\
	z-index: 999999;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	cursor: default;\
	white-space: pre;\
	word-wrap: break-word;\
	line-height: normal;\
	font-style: normal;\
	font-weight: normal;\
	letter-spacing: normal;\
	pointer-events: none;\
	}\
	.ace_folding-enabled > .ace_gutter-cell {\
	padding-right: 13px;\
	}\
	.ace_fold-widget {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	margin: 0 -12px 0 1px;\
	display: none;\
	width: 11px;\
	vertical-align: top;\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: center;\
	border-radius: 3px;\
	border: 1px solid transparent;\
	cursor: pointer;\
	}\
	.ace_folding-enabled .ace_fold-widget {\
	display: inline-block;   \
	}\
	.ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
	}\
	.ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
	}\
	.ace_fold-widget:hover {\
	border: 1px solid rgba(0, 0, 0, 0.3);\
	background-color: rgba(255, 255, 255, 0.2);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
	}\
	.ace_fold-widget:active {\
	border: 1px solid rgba(0, 0, 0, 0.4);\
	background-color: rgba(0, 0, 0, 0.05);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
	}\
	.ace_dark .ace_fold-widget {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
	}\
	.ace_dark .ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget:hover {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	background-color: rgba(255, 255, 255, 0.1);\
	}\
	.ace_dark .ace_fold-widget:active {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	}\
	.ace_fold-widget.ace_invalid {\
	background-color: #FFB4B4;\
	border-color: #DE5555;\
	}\
	.ace_fade-fold-widgets .ace_fold-widget {\
	-webkit-transition: opacity 0.4s ease 0.05s;\
	transition: opacity 0.4s ease 0.05s;\
	opacity: 0;\
	}\
	.ace_fade-fold-widgets:hover .ace_fold-widget {\
	-webkit-transition: opacity 0.05s ease 0.05s;\
	transition: opacity 0.05s ease 0.05s;\
	opacity:1;\
	}\
	.ace_underline {\
	text-decoration: underline;\
	}\
	.ace_bold {\
	font-weight: bold;\
	}\
	.ace_nobold .ace_bold {\
	font-weight: normal;\
	}\
	.ace_italic {\
	font-style: italic;\
	}\
	.ace_error-marker {\
	background-color: rgba(255, 0, 0,0.2);\
	position: absolute;\
	z-index: 9;\
	}\
	.ace_highlight-marker {\
	background-color: rgba(255, 255, 0,0.2);\
	position: absolute;\
	z-index: 8;\
	}\
	.ace_br1 {border-top-left-radius    : 3px;}\
	.ace_br2 {border-top-right-radius   : 3px;}\
	.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
	.ace_br4 {border-bottom-right-radius: 3px;}\
	.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
	.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
	.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
	.ace_br8 {border-bottom-left-radius : 3px;}\
	.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
	.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
	.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
	.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
	.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
	";

	dom.importCssString(editorCss, "ace_editor.css");

	var VirtualRenderer = function(container, theme) {
	    var _self = this;

	    this.container = container || dom.createElement("div");
	    this.$keepTextAreaAtCursor = !useragent.isOldIE;

	    dom.addCssClass(this.container, "ace_editor");

	    this.setTheme(theme);

	    this.$gutter = dom.createElement("div");
	    this.$gutter.className = "ace_gutter";
	    this.container.appendChild(this.$gutter);

	    this.scroller = dom.createElement("div");
	    this.scroller.className = "ace_scroller";
	    this.container.appendChild(this.scroller);

	    this.content = dom.createElement("div");
	    this.content.className = "ace_content";
	    this.scroller.appendChild(this.content);

	    this.$gutterLayer = new GutterLayer(this.$gutter);
	    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

	    this.$markerBack = new MarkerLayer(this.content);

	    var textLayer = this.$textLayer = new TextLayer(this.content);
	    this.canvas = textLayer.element;

	    this.$markerFront = new MarkerLayer(this.content);

	    this.$cursorLayer = new CursorLayer(this.content);
	    this.$horizScroll = false;
	    this.$vScroll = false;

	    this.scrollBar = 
	    this.scrollBarV = new VScrollBar(this.container, this);
	    this.scrollBarH = new HScrollBar(this.container, this);
	    this.scrollBarV.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	    });
	    this.scrollBarH.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	    });

	    this.scrollTop = 0;
	    this.scrollLeft = 0;

	    this.cursorPos = {
	        row : 0,
	        column : 0
	    };

	    this.$fontMetrics = new FontMetrics(this.container);
	    this.$textLayer.$setFontMetrics(this.$fontMetrics);
	    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
	        _self.updateCharacterSize();
	        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
	        _self._signal("changeCharacterSize", e);
	    });

	    this.$size = {
	        width: 0,
	        height: 0,
	        scrollerHeight: 0,
	        scrollerWidth: 0,
	        $dirty: true
	    };

	    this.layerConfig = {
	        width : 1,
	        padding : 0,
	        firstRow : 0,
	        firstRowScreen: 0,
	        lastRow : 0,
	        lineHeight : 0,
	        characterWidth : 0,
	        minHeight : 1,
	        maxHeight : 1,
	        offset : 0,
	        height : 1,
	        gutterOffset: 1
	    };
	    
	    this.scrollMargin = {
	        left: 0,
	        right: 0,
	        top: 0,
	        bottom: 0,
	        v: 0,
	        h: 0
	    };

	    this.$loop = new RenderLoop(
	        this.$renderChanges.bind(this),
	        this.container.ownerDocument.defaultView
	    );
	    this.$loop.schedule(this.CHANGE_FULL);

	    this.updateCharacterSize();
	    this.setPadding(4);
	    config.resetOptions(this);
	    config._emit("renderer", this);
	};

	(function() {

	    this.CHANGE_CURSOR = 1;
	    this.CHANGE_MARKER = 2;
	    this.CHANGE_GUTTER = 4;
	    this.CHANGE_SCROLL = 8;
	    this.CHANGE_LINES = 16;
	    this.CHANGE_TEXT = 32;
	    this.CHANGE_SIZE = 64;
	    this.CHANGE_MARKER_BACK = 128;
	    this.CHANGE_MARKER_FRONT = 256;
	    this.CHANGE_FULL = 512;
	    this.CHANGE_H_SCROLL = 1024;

	    oop.implement(this, EventEmitter);

	    this.updateCharacterSize = function() {
	        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
	            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
	            this.setStyle("ace_nobold", !this.$allowBoldFonts);
	        }

	        this.layerConfig.characterWidth =
	        this.characterWidth = this.$textLayer.getCharacterWidth();
	        this.layerConfig.lineHeight =
	        this.lineHeight = this.$textLayer.getLineHeight();
	        this.$updatePrintMargin();
	    };
	    this.setSession = function(session) {
	        if (this.session)
	            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
	            
	        this.session = session;
	        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
	            session.setScrollTop(-this.scrollMargin.top);

	        this.$cursorLayer.setSession(session);
	        this.$markerBack.setSession(session);
	        this.$markerFront.setSession(session);
	        this.$gutterLayer.setSession(session);
	        this.$textLayer.setSession(session);
	        if (!session)
	            return;
	        
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.session.$setFontMetrics(this.$fontMetrics);
	        
	        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
	        this.onChangeNewLineMode()
	        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
	    };
	    this.updateLines = function(firstRow, lastRow, force) {
	        if (lastRow === undefined)
	            lastRow = Infinity;

	        if (!this.$changedLines) {
	            this.$changedLines = {
	                firstRow: firstRow,
	                lastRow: lastRow
	            };
	        }
	        else {
	            if (this.$changedLines.firstRow > firstRow)
	                this.$changedLines.firstRow = firstRow;

	            if (this.$changedLines.lastRow < lastRow)
	                this.$changedLines.lastRow = lastRow;
	        }
	        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
	            if (force)
	                this.$changedLines.lastRow = this.layerConfig.lastRow;
	            else
	                return;
	        }
	        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
	            return;
	        this.$loop.schedule(this.CHANGE_LINES);
	    };

	    this.onChangeNewLineMode = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	        this.$textLayer.$updateEolChar();
	    };
	    
	    this.onChangeTabSize = function() {
	        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
	        this.$textLayer.onChangeTabSize();
	    };
	    this.updateText = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	    };
	    this.updateFull = function(force) {
	        if (force)
	            this.$renderChanges(this.CHANGE_FULL, true);
	        else
	            this.$loop.schedule(this.CHANGE_FULL);
	    };
	    this.updateFontSize = function() {
	        this.$textLayer.checkForSizeChanges();
	    };

	    this.$changes = 0;
	    this.$updateSizeAsync = function() {
	        if (this.$loop.pending)
	            this.$size.$dirty = true;
	        else
	            this.onResize();
	    };
	    this.onResize = function(force, gutterWidth, width, height) {
	        if (this.resizing > 2)
	            return;
	        else if (this.resizing > 0)
	            this.resizing++;
	        else
	            this.resizing = force ? 1 : 0;
	        var el = this.container;
	        if (!height)
	            height = el.clientHeight || el.scrollHeight;
	        if (!width)
	            width = el.clientWidth || el.scrollWidth;
	        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

	        
	        if (!this.$size.scrollerHeight || (!width && !height))
	            return this.resizing = 0;

	        if (force)
	            this.$gutterLayer.$padding = null;

	        if (force)
	            this.$renderChanges(changes | this.$changes, true);
	        else
	            this.$loop.schedule(changes | this.$changes);

	        if (this.resizing)
	            this.resizing = 0;
	        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
	    };
	    
	    this.$updateCachedSize = function(force, gutterWidth, width, height) {
	        height -= (this.$extraHeight || 0);
	        var changes = 0;
	        var size = this.$size;
	        var oldSize = {
	            width: size.width,
	            height: size.height,
	            scrollerHeight: size.scrollerHeight,
	            scrollerWidth: size.scrollerWidth
	        };
	        if (height && (force || size.height != height)) {
	            size.height = height;
	            changes |= this.CHANGE_SIZE;

	            size.scrollerHeight = size.height;
	            if (this.$horizScroll)
	                size.scrollerHeight -= this.scrollBarH.getHeight();
	            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

	            changes = changes | this.CHANGE_SCROLL;
	        }

	        if (width && (force || size.width != width)) {
	            changes |= this.CHANGE_SIZE;
	            size.width = width;
	            
	            if (gutterWidth == null)
	                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	            
	            this.gutterWidth = gutterWidth;
	            
	            this.scrollBarH.element.style.left = 
	            this.scroller.style.left = gutterWidth + "px";
	            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
	            
	            this.scrollBarH.element.style.right = 
	            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
	            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

	            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
	                changes |= this.CHANGE_FULL;
	        }
	        
	        size.$dirty = !width || !height;

	        if (changes)
	            this._signal("resize", oldSize);

	        return changes;
	    };

	    this.onGutterResize = function() {
	        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	        if (gutterWidth != this.gutterWidth)
	            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

	        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else if (this.$size.$dirty) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else {
	            this.$computeLayerConfig();
	            this.$loop.schedule(this.CHANGE_MARKER);
	        }
	    };
	    this.adjustWrapLimit = function() {
	        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
	        var limit = Math.floor(availableWidth / this.characterWidth);
	        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
	    };
	    this.setAnimatedScroll = function(shouldAnimate){
	        this.setOption("animatedScroll", shouldAnimate);
	    };
	    this.getAnimatedScroll = function() {
	        return this.$animatedScroll;
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.setOption("showInvisibles", showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.getOption("showInvisibles");
	    };
	    this.getDisplayIndentGuides = function() {
	        return this.getOption("displayIndentGuides");
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.setOption("displayIndentGuides", display);
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.setOption("showPrintMargin", showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.getOption("showPrintMargin");
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.setOption("printMarginColumn", showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.getOption("printMarginColumn");
	    };
	    this.getShowGutter = function(){
	        return this.getOption("showGutter");
	    };
	    this.setShowGutter = function(show){
	        return this.setOption("showGutter", show);
	    };

	    this.getFadeFoldWidgets = function(){
	        return this.getOption("fadeFoldWidgets")
	    };

	    this.setFadeFoldWidgets = function(show) {
	        this.setOption("fadeFoldWidgets", show);
	    };

	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };

	    this.$updateGutterLineHighlight = function() {
	        var pos = this.$cursorLayer.$pixelPos;
	        var height = this.layerConfig.lineHeight;
	        if (this.session.getUseWrapMode()) {
	            var cursor = this.session.selection.getCursor();
	            cursor.column = 0;
	            pos = this.$cursorLayer.getPixelPosition(cursor, true);
	            height *= this.session.getRowLength(cursor.row);
	        }
	        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
	        this.$gutterLineHighlight.style.height = height + "px";
	    };

	    this.$updatePrintMargin = function() {
	        if (!this.$showPrintMargin && !this.$printMarginEl)
	            return;

	        if (!this.$printMarginEl) {
	            var containerEl = dom.createElement("div");
	            containerEl.className = "ace_layer ace_print-margin-layer";
	            this.$printMarginEl = dom.createElement("div");
	            this.$printMarginEl.className = "ace_print-margin";
	            containerEl.appendChild(this.$printMarginEl);
	            this.content.insertBefore(containerEl, this.content.firstChild);
	        }

	        var style = this.$printMarginEl.style;
	        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
	        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
	        
	        if (this.session && this.session.$wrap == -1)
	            this.adjustWrapLimit();
	    };
	    this.getContainerElement = function() {
	        return this.container;
	    };
	    this.getMouseEventTarget = function() {
	        return this.scroller;
	    };
	    this.getTextAreaContainer = function() {
	        return this.container;
	    };
	    this.$moveTextAreaToCursor = function() {
	        if (!this.$keepTextAreaAtCursor)
	            return;
	        var config = this.layerConfig;
	        var posTop = this.$cursorLayer.$pixelPos.top;
	        var posLeft = this.$cursorLayer.$pixelPos.left;
	        posTop -= config.offset;

	        var style = this.textarea.style;
	        var h = this.lineHeight;
	        if (posTop < 0 || posTop > config.height - h) {
	            style.top = style.left = "0";
	            return;
	        }

	        var w = this.characterWidth;
	        if (this.$composition) {
	            var val = this.textarea.value.replace(/^\x01+/, "");
	            w *= (this.session.$getStringScreenWidth(val)[0]+2);
	            h += 2;
	        }
	        posLeft -= this.scrollLeft;
	        if (posLeft > this.$size.scrollerWidth - w)
	            posLeft = this.$size.scrollerWidth - w;

	        posLeft += this.gutterWidth;
	        style.height = h + "px";
	        style.width = w + "px";
	        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
	        style.top = Math.min(posTop, this.$size.height - h) + "px";
	    };
	    this.getFirstVisibleRow = function() {
	        return this.layerConfig.firstRow;
	    };
	    this.getFirstFullyVisibleRow = function() {
	        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
	    };
	    this.getLastFullyVisibleRow = function() {
	        var config = this.layerConfig;
	        var lastRow = config.lastRow
	        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
	        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
	            return lastRow - 1;
	        return lastRow;
	    };
	    this.getLastVisibleRow = function() {
	        return this.layerConfig.lastRow;
	    };

	    this.$padding = null;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.$textLayer.setPadding(padding);
	        this.$cursorLayer.setPadding(padding);
	        this.$markerFront.setPadding(padding);
	        this.$markerBack.setPadding(padding);
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.$updatePrintMargin();
	    };
	    
	    this.setScrollMargin = function(top, bottom, left, right) {
	        var sm = this.scrollMargin;
	        sm.top = top|0;
	        sm.bottom = bottom|0;
	        sm.right = right|0;
	        sm.left = left|0;
	        sm.v = sm.top + sm.bottom;
	        sm.h = sm.left + sm.right;
	        if (sm.top && this.scrollTop <= 0 && this.session)
	            this.session.setScrollTop(-sm.top);
	        this.updateFull();
	    };
	    this.getHScrollBarAlwaysVisible = function() {
	        return this.$hScrollBarAlwaysVisible;
	    };
	    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
	    };
	    this.getVScrollBarAlwaysVisible = function() {
	        return this.$vScrollBarAlwaysVisible;
	    };
	    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
	    };

	    this.$updateScrollBarV = function() {
	        var scrollHeight = this.layerConfig.maxHeight;
	        var scrollerHeight = this.$size.scrollerHeight;
	        if (!this.$maxLines && this.$scrollPastEnd) {
	            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
	            if (this.scrollTop > scrollHeight - scrollerHeight) {
	                scrollHeight = this.scrollTop + scrollerHeight;
	                this.scrollBarV.scrollTop = null;
	            }
	        }
	        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
	        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
	    };
	    this.$updateScrollBarH = function() {
	        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
	        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
	    };
	    
	    this.$frozen = false;
	    this.freeze = function() {
	        this.$frozen = true;
	    };
	    
	    this.unfreeze = function() {
	        this.$frozen = false;
	    };

	    this.$renderChanges = function(changes, force) {
	        if (this.$changes) {
	            changes |= this.$changes;
	            this.$changes = 0;
	        }
	        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
	            this.$changes |= changes;
	            return; 
	        } 
	        if (this.$size.$dirty) {
	            this.$changes |= changes;
	            return this.onResize(true);
	        }
	        if (!this.lineHeight) {
	            this.$textLayer.checkForSizeChanges();
	        }
	        
	        this._signal("beforeRender");
	        var config = this.layerConfig;
	        if (changes & this.CHANGE_FULL ||
	            changes & this.CHANGE_SIZE ||
	            changes & this.CHANGE_TEXT ||
	            changes & this.CHANGE_LINES ||
	            changes & this.CHANGE_SCROLL ||
	            changes & this.CHANGE_H_SCROLL
	        ) {
	            changes |= this.$computeLayerConfig();
	            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
	                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
	                if (st > 0) {
	                    this.scrollTop = st;
	                    changes = changes | this.CHANGE_SCROLL;
	                    changes |= this.$computeLayerConfig();
	                }
	            }
	            config = this.layerConfig;
	            this.$updateScrollBarV();
	            if (changes & this.CHANGE_H_SCROLL)
	                this.$updateScrollBarH();
	            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
	            this.content.style.marginTop = (-config.offset) + "px";
	            this.content.style.width = config.width + 2 * this.$padding + "px";
	            this.content.style.height = config.minHeight + "px";
	        }
	        if (changes & this.CHANGE_H_SCROLL) {
	            this.content.style.marginLeft = -this.scrollLeft + "px";
	            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
	        }
	        if (changes & this.CHANGE_FULL) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this._signal("afterRender");
	            return;
	        }
	        if (changes & this.CHANGE_SCROLL) {
	            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
	                this.$textLayer.update(config);
	            else
	                this.$textLayer.scrollLines(config);

	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this.$moveTextAreaToCursor();
	            this._signal("afterRender");
	            return;
	        }

	        if (changes & this.CHANGE_TEXT) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_LINES) {
	            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }

	        if (changes & this.CHANGE_CURSOR) {
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
	            this.$markerFront.update(config);
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
	            this.$markerBack.update(config);
	        }

	        this._signal("afterRender");
	    };

	    
	    this.$autosize = function() {
	        var height = this.session.getScreenLength() * this.lineHeight;
	        var maxHeight = this.$maxLines * this.lineHeight;
	        var desiredHeight = Math.max(
	            (this.$minLines||1) * this.lineHeight,
	            Math.min(maxHeight, height)
	        ) + this.scrollMargin.v + (this.$extraHeight || 0);
	        if (this.$horizScroll)
	            desiredHeight += this.scrollBarH.getHeight();
	        var vScroll = height > maxHeight;
	        
	        if (desiredHeight != this.desiredHeight ||
	            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
	            if (vScroll != this.$vScroll) {
	                this.$vScroll = vScroll;
	                this.scrollBarV.setVisible(vScroll);
	            }
	            
	            var w = this.container.clientWidth;
	            this.container.style.height = desiredHeight + "px";
	            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
	            this.desiredHeight = desiredHeight;
	            
	            this._signal("autosize");
	        }
	    };
	    
	    this.$computeLayerConfig = function() {
	        var session = this.session;
	        var size = this.$size;
	        
	        var hideScrollbars = size.height <= 2 * this.lineHeight;
	        var screenLines = this.session.getScreenLength();
	        var maxHeight = screenLines * this.lineHeight;

	        var longestLine = this.$getLongestLine();
	        
	        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
	            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

	        var hScrollChanged = this.$horizScroll !== horizScroll;
	        if (hScrollChanged) {
	            this.$horizScroll = horizScroll;
	            this.scrollBarH.setVisible(horizScroll);
	        }
	        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
	        if (this.$maxLines && this.lineHeight > 1)
	            this.$autosize();

	        var offset = this.scrollTop % this.lineHeight;
	        var minHeight = size.scrollerHeight + this.lineHeight;
	        
	        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
	            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
	            : 0;
	        maxHeight += scrollPastEnd;
	        
	        var sm = this.scrollMargin;
	        this.session.setScrollTop(Math.max(-sm.top,
	            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

	        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
	            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
	        
	        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
	            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
	        var vScrollChanged = vScrollBefore !== vScroll;
	        if (vScrollChanged) {
	            this.$vScroll = vScroll;
	            this.scrollBarV.setVisible(vScroll);
	        }

	        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
	        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
	        var lastRow = firstRow + lineCount;
	        var firstRowScreen, firstRowHeight;
	        var lineHeight = this.lineHeight;
	        firstRow = session.screenToDocumentRow(firstRow, 0);
	        var foldLine = session.getFoldLine(firstRow);
	        if (foldLine) {
	            firstRow = foldLine.start.row;
	        }

	        firstRowScreen = session.documentToScreenRow(firstRow, 0);
	        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

	        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
	        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
	                                                firstRowHeight;

	        offset = this.scrollTop - firstRowScreen * lineHeight;

	        var changes = 0;
	        if (this.layerConfig.width != longestLine) 
	            changes = this.CHANGE_H_SCROLL;
	        if (hScrollChanged || vScrollChanged) {
	            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
	            this._signal("scrollbarVisibilityChanged");
	            if (vScrollChanged)
	                longestLine = this.$getLongestLine();
	        }
	        
	        this.layerConfig = {
	            width : longestLine,
	            padding : this.$padding,
	            firstRow : firstRow,
	            firstRowScreen: firstRowScreen,
	            lastRow : lastRow,
	            lineHeight : lineHeight,
	            characterWidth : this.characterWidth,
	            minHeight : minHeight,
	            maxHeight : maxHeight,
	            offset : offset,
	            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
	            height : this.$size.scrollerHeight
	        };

	        return changes;
	    };

	    this.$updateLines = function() {
	        var firstRow = this.$changedLines.firstRow;
	        var lastRow = this.$changedLines.lastRow;
	        this.$changedLines = null;

	        var layerConfig = this.layerConfig;

	        if (firstRow > layerConfig.lastRow + 1) { return; }
	        if (lastRow < layerConfig.firstRow) { return; }
	        if (lastRow === Infinity) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(layerConfig);
	            this.$textLayer.update(layerConfig);
	            return;
	        }
	        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
	        return true;
	    };

	    this.$getLongestLine = function() {
	        var charCount = this.session.getScreenWidth();
	        if (this.showInvisibles && !this.session.$useWrapMode)
	            charCount += 1;

	        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
	    };
	    this.updateFrontMarkers = function() {
	        this.$markerFront.setMarkers(this.session.getMarkers(true));
	        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
	    };
	    this.updateBackMarkers = function() {
	        this.$markerBack.setMarkers(this.session.getMarkers());
	        this.$loop.schedule(this.CHANGE_MARKER_BACK);
	    };
	    this.addGutterDecoration = function(row, className){
	        this.$gutterLayer.addGutterDecoration(row, className);
	    };
	    this.removeGutterDecoration = function(row, className){
	        this.$gutterLayer.removeGutterDecoration(row, className);
	    };
	    this.updateBreakpoints = function(rows) {
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.setAnnotations = function(annotations) {
	        this.$gutterLayer.setAnnotations(annotations);
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.updateCursor = function() {
	        this.$loop.schedule(this.CHANGE_CURSOR);
	    };
	    this.hideCursor = function() {
	        this.$cursorLayer.hideCursor();
	    };
	    this.showCursor = function() {
	        this.$cursorLayer.showCursor();
	    };

	    this.scrollSelectionIntoView = function(anchor, lead, offset) {
	        this.scrollCursorIntoView(anchor, offset);
	        this.scrollCursorIntoView(lead, offset);
	    };
	    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
	        if (this.$size.scrollerHeight === 0)
	            return;

	        var pos = this.$cursorLayer.getPixelPosition(cursor);

	        var left = pos.left;
	        var top = pos.top;
	        
	        var topMargin = $viewMargin && $viewMargin.top || 0;
	        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
	        
	        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
	        
	        if (scrollTop + topMargin > top) {
	            if (offset && scrollTop + topMargin > top + this.lineHeight)
	                top -= offset * this.$size.scrollerHeight;
	            if (top === 0)
	                top = -this.scrollMargin.top;
	            this.session.setScrollTop(top);
	        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
	            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
	                top += offset * this.$size.scrollerHeight;
	            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
	        }

	        var scrollLeft = this.scrollLeft;

	        if (scrollLeft > left) {
	            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
	                left = -this.scrollMargin.left;
	            this.session.setScrollLeft(left);
	        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
	            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
	        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
	            this.session.setScrollLeft(0);
	        }
	    };
	    this.getScrollTop = function() {
	        return this.session.getScrollTop();
	    };
	    this.getScrollLeft = function() {
	        return this.session.getScrollLeft();
	    };
	    this.getScrollTopRow = function() {
	        return this.scrollTop / this.lineHeight;
	    };
	    this.getScrollBottomRow = function() {
	        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
	    };
	    this.scrollToRow = function(row) {
	        this.session.setScrollTop(row * this.lineHeight);
	    };

	    this.alignCursor = function(cursor, alignment) {
	        if (typeof cursor == "number")
	            cursor = {row: cursor, column: 0};

	        var pos = this.$cursorLayer.getPixelPosition(cursor);
	        var h = this.$size.scrollerHeight - this.lineHeight;
	        var offset = pos.top - h * (alignment || 0);

	        this.session.setScrollTop(offset);
	        return offset;
	    };

	    this.STEPS = 8;
	    this.$calcSteps = function(fromValue, toValue){
	        var i = 0;
	        var l = this.STEPS;
	        var steps = [];

	        var func  = function(t, x_min, dx) {
	            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
	        };

	        for (i = 0; i < l; ++i)
	            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

	        return steps;
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
	        var offset = pos.top;
	        if (center)
	            offset -= this.$size.scrollerHeight / 2;

	        var initialScroll = this.scrollTop;
	        this.session.setScrollTop(offset);
	        if (animate !== false)
	            this.animateScrolling(initialScroll, callback);
	    };

	    this.animateScrolling = function(fromValue, callback) {
	        var toValue = this.scrollTop;
	        if (!this.$animatedScroll)
	            return;
	        var _self = this;
	        
	        if (fromValue == toValue)
	            return;
	        
	        if (this.$scrollAnimation) {
	            var oldSteps = this.$scrollAnimation.steps;
	            if (oldSteps.length) {
	                fromValue = oldSteps[0];
	                if (fromValue == toValue)
	                    return;
	            }
	        }
	        
	        var steps = _self.$calcSteps(fromValue, toValue);
	        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

	        clearInterval(this.$timer);

	        _self.session.setScrollTop(steps.shift());
	        _self.session.$scrollTop = toValue;
	        this.$timer = setInterval(function() {
	            if (steps.length) {
	                _self.session.setScrollTop(steps.shift());
	                _self.session.$scrollTop = toValue;
	            } else if (toValue != null) {
	                _self.session.$scrollTop = -1;
	                _self.session.setScrollTop(toValue);
	                toValue = null;
	            } else {
	                _self.$timer = clearInterval(_self.$timer);
	                _self.$scrollAnimation = null;
	                callback && callback();
	            }
	        }, 10);
	    };
	    this.scrollToY = function(scrollTop) {
	        if (this.scrollTop !== scrollTop) {
	            this.$loop.schedule(this.CHANGE_SCROLL);
	            this.scrollTop = scrollTop;
	        }
	    };
	    this.scrollToX = function(scrollLeft) {
	        if (this.scrollLeft !== scrollLeft)
	            this.scrollLeft = scrollLeft;
	        this.$loop.schedule(this.CHANGE_H_SCROLL);
	    };
	    this.scrollTo = function(x, y) {
	        this.session.setScrollTop(y);
	        this.session.setScrollLeft(y);
	    };
	    this.scrollBy = function(deltaX, deltaY) {
	        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
	        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
	    };
	    this.isScrollableBy = function(deltaX, deltaY) {
	        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
	           return true;
	        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
	            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
	           return true;
	        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
	            return true;
	        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
	            - this.layerConfig.width < -1 + this.scrollMargin.right)
	           return true;
	    };

	    this.pixelToScreenCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
	        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
	        var col = Math.round(offset);

	        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
	    };

	    this.screenToTextCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var col = Math.round(
	            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
	        );

	        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

	        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
	    };
	    this.textToScreenCoordinates = function(row, column) {
	        var canvasPos = this.scroller.getBoundingClientRect();
	        var pos = this.session.documentToScreenPosition(row, column);

	        var x = this.$padding + Math.round(pos.column * this.characterWidth);
	        var y = pos.row * this.lineHeight;

	        return {
	            pageX: canvasPos.left + x - this.scrollLeft,
	            pageY: canvasPos.top + y - this.scrollTop
	        };
	    };
	    this.visualizeFocus = function() {
	        dom.addCssClass(this.container, "ace_focus");
	    };
	    this.visualizeBlur = function() {
	        dom.removeCssClass(this.container, "ace_focus");
	    };
	    this.showComposition = function(position) {
	        if (!this.$composition)
	            this.$composition = {
	                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
	                cssText: this.textarea.style.cssText
	            };

	        this.$keepTextAreaAtCursor = true;
	        dom.addCssClass(this.textarea, "ace_composition");
	        this.textarea.style.cssText = "";
	        this.$moveTextAreaToCursor();
	    };
	    this.setCompositionText = function(text) {
	        this.$moveTextAreaToCursor();
	    };
	    this.hideComposition = function() {
	        if (!this.$composition)
	            return;

	        dom.removeCssClass(this.textarea, "ace_composition");
	        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
	        this.textarea.style.cssText = this.$composition.cssText;
	        this.$composition = null;
	    };
	    this.setTheme = function(theme, cb) {
	        var _self = this;
	        this.$themeId = theme;
	        _self._dispatchEvent('themeChange',{theme:theme});

	        if (!theme || typeof theme == "string") {
	            var moduleName = theme || this.$options.theme.initialValue;
	            config.loadModule(["theme", moduleName], afterLoad);
	        } else {
	            afterLoad(theme);
	        }

	        function afterLoad(module) {
	            if (_self.$themeId != theme)
	                return cb && cb();
	            if (!module.cssClass)
	                return;
	            dom.importCssString(
	                module.cssText,
	                module.cssClass,
	                _self.container.ownerDocument
	            );

	            if (_self.theme)
	                dom.removeCssClass(_self.container, _self.theme.cssClass);

	            var padding = "padding" in module ? module.padding 
	                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
	            if (_self.$padding && padding != _self.$padding)
	                _self.setPadding(padding);
	            _self.$theme = module.cssClass;

	            _self.theme = module;
	            dom.addCssClass(_self.container, module.cssClass);
	            dom.setCssClass(_self.container, "ace_dark", module.isDark);
	            if (_self.$size) {
	                _self.$size.width = 0;
	                _self.$updateSizeAsync();
	            }

	            _self._dispatchEvent('themeLoaded', {theme:module});
	            cb && cb();
	        }
	    };
	    this.getTheme = function() {
	        return this.$themeId;
	    };
	    this.setStyle = function(style, include) {
	        dom.setCssClass(this.container, style, include !== false);
	    };
	    this.unsetStyle = function(style) {
	        dom.removeCssClass(this.container, style);
	    };
	    
	    this.setCursorStyle = function(style) {
	        if (this.scroller.style.cursor != style)
	            this.scroller.style.cursor = style;
	    };
	    this.setMouseCursor = function(cursorStyle) {
	        this.scroller.style.cursor = cursorStyle;
	    };
	    this.destroy = function() {
	        this.$textLayer.destroy();
	        this.$cursorLayer.destroy();
	    };

	}).call(VirtualRenderer.prototype);


	config.defineOptions(VirtualRenderer.prototype, "renderer", {
	    animatedScroll: {initialValue: false},
	    showInvisibles: {
	        set: function(value) {
	            if (this.$textLayer.setShowInvisibles(value))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: false
	    },
	    showPrintMargin: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: true
	    },
	    printMarginColumn: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: 80
	    },
	    printMargin: {
	        set: function(val) {
	            if (typeof val == "number")
	                this.$printMarginColumn = val;
	            this.$showPrintMargin = !!val;
	            this.$updatePrintMargin();
	        },
	        get: function() {
	            return this.$showPrintMargin && this.$printMarginColumn; 
	        }
	    },
	    showGutter: {
	        set: function(show){
	            this.$gutter.style.display = show ? "block" : "none";
	            this.$loop.schedule(this.CHANGE_FULL);
	            this.onGutterResize();
	        },
	        initialValue: true
	    },
	    fadeFoldWidgets: {
	        set: function(show) {
	            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
	        },
	        initialValue: false
	    },
	    showFoldWidgets: {
	        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
	        initialValue: true
	    },
	    showLineNumbers: {
	        set: function(show) {
	            this.$gutterLayer.setShowLineNumbers(show);
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        },
	        initialValue: true
	    },
	    displayIndentGuides: {
	        set: function(show) {
	            if (this.$textLayer.setDisplayIndentGuides(show))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: true
	    },
	    highlightGutterLine: {
	        set: function(shouldHighlight) {
	            if (!this.$gutterLineHighlight) {
	                this.$gutterLineHighlight = dom.createElement("div");
	                this.$gutterLineHighlight.className = "ace_gutter-active-line";
	                this.$gutter.appendChild(this.$gutterLineHighlight);
	                return;
	            }

	            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
	            if (this.$cursorLayer.$pixelPos)
	                this.$updateGutterLineHighlight();
	        },
	        initialValue: false,
	        value: true
	    },
	    hScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    vScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    fontSize:  {
	        set: function(size) {
	            if (typeof size == "number")
	                size = size + "px";
	            this.container.style.fontSize = size;
	            this.updateFontSize();
	        },
	        initialValue: 12
	    },
	    fontFamily: {
	        set: function(name) {
	            this.container.style.fontFamily = name;
	            this.updateFontSize();
	        }
	    },
	    maxLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    minLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    scrollPastEnd: {
	        set: function(val) {
	            val = +val || 0;
	            if (this.$scrollPastEnd == val)
	                return;
	            this.$scrollPastEnd = val;
	            this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: 0,
	        handlesSet: true
	    },
	    fixedWidthGutter: {
	        set: function(val) {
	            this.$gutterLayer.$fixedWidth = !!val;
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        }
	    },
	    theme: {
	        set: function(val) { this.setTheme(val) },
	        get: function() { return this.$themeId || this.theme; },
	        initialValue: "./theme/textmate",
	        handlesSet: true
	    }
	});

	exports.VirtualRenderer = VirtualRenderer;
	});

	ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var net = acequire("../lib/net");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
	var config = acequire("../config");

	var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.onMessage = this.onMessage.bind(this);
	    if (acequire.nameToUrl && !acequire.toUrl)
	        acequire.toUrl = acequire.nameToUrl;
	    
	    if (config.get("packaged") || !acequire.toUrl) {
	        workerUrl = workerUrl || config.moduleUrl(mod.id, "worker")
	    } else {
	        var normalizePath = this.$normalizePath;
	        workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));

	        var tlns = {};
	        topLevelNamespaces.forEach(function(ns) {
	            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
	        });
	    }

	    try {
	            var workerSrc = mod.src;
	    var Blob = __webpack_require__(29);
	    var blob = new Blob([ workerSrc ], { type: 'application/javascript' });
	    var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);

	    this.$worker = new Worker(blobUrl);

	    } catch(e) {
	        if (e instanceof window.DOMException) {
	            var blob = this.$workerBlob(workerUrl);
	            var URL = window.URL || window.webkitURL;
	            var blobURL = URL.createObjectURL(blob);

	            this.$worker = new Worker(blobURL);
	            URL.revokeObjectURL(blobURL);
	        } else {
	            throw e;
	        }
	    }
	    this.$worker.postMessage({
	        init : true,
	        tlns : tlns,
	        module : mod.id,
	        classname : classname
	    });

	    this.callbackId = 1;
	    this.callbacks = {};

	    this.$worker.onmessage = this.onMessage;
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.onMessage = function(e) {
	        var msg = e.data;
	        switch(msg.type) {
	            case "event":
	                this._signal(msg.name, {data: msg.data});
	                break;
	            case "call":
	                var callback = this.callbacks[msg.id];
	                if (callback) {
	                    callback(msg.data);
	                    delete this.callbacks[msg.id];
	                }
	                break;
	            case "error":
	                this.reportError(msg.data);
	                break;
	            case "log":
	                window.console && console.log && console.log.apply(console, msg.data);
	                break;
	        }
	    };
	    
	    this.reportError = function(err) {
	        window.console && console.error && console.error(err);
	    };

	    this.$normalizePath = function(path) {
	        return net.qualifyURL(path);
	    };

	    this.terminate = function() {
	        this._signal("terminate", {});
	        this.deltaQueue = null;
	        this.$worker.terminate();
	        this.$worker = null;
	        if (this.$doc)
	            this.$doc.off("change", this.changeListener);
	        this.$doc = null;
	    };

	    this.send = function(cmd, args) {
	        this.$worker.postMessage({command: cmd, args: args});
	    };

	    this.call = function(cmd, args, callback) {
	        if (callback) {
	            var id = this.callbackId++;
	            this.callbacks[id] = callback;
	            args.push(id);
	        }
	        this.send(cmd, args);
	    };

	    this.emit = function(event, data) {
	        try {
	            this.$worker.postMessage({event: event, data: {data: data.data}});
	        }
	        catch(ex) {
	            console.error(ex.stack);
	        }
	    };

	    this.attachToDocument = function(doc) {
	        if(this.$doc)
	            this.terminate();

	        this.$doc = doc;
	        this.call("setValue", [doc.getValue()]);
	        doc.on("change", this.changeListener);
	    };

	    this.changeListener = function(delta) {
	        if (!this.deltaQueue) {
	            this.deltaQueue = [];
	            setTimeout(this.$sendDeltaQueue, 0);
	        }
	        if (delta.action == "insert")
	            this.deltaQueue.push(delta.start, delta.lines);
	        else
	            this.deltaQueue.push(delta.start, delta.end);
	    };

	    this.$sendDeltaQueue = function() {
	        var q = this.deltaQueue;
	        if (!q) return;
	        this.deltaQueue = null;
	        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
	            this.call("setValue", [this.$doc.getValue()]);
	        } else
	            this.emit("change", {data: q});
	    };

	    this.$workerBlob = function(workerUrl) {
	        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
	        try {
	            return new Blob([script], {"type": "application/javascript"});
	        } catch (e) { // Backwards-compatibility
	            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
	            var blobBuilder = new BlobBuilder();
	            blobBuilder.append(script);
	            return blobBuilder.getBlob("application/javascript");
	        }
	    };

	}).call(WorkerClient.prototype);


	var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.callbackId = 1;
	    this.callbacks = {};
	    this.messageBuffer = [];

	    var main = null;
	    var emitSync = false;
	    var sender = Object.create(EventEmitter);
	    var _self = this;

	    this.$worker = {};
	    this.$worker.terminate = function() {};
	    this.$worker.postMessage = function(e) {
	        _self.messageBuffer.push(e);
	        if (main) {
	            if (emitSync)
	                setTimeout(processNext);
	            else
	                processNext();
	        }
	    };
	    this.setEmitSync = function(val) { emitSync = val };

	    var processNext = function() {
	        var msg = _self.messageBuffer.shift();
	        if (msg.command)
	            main[msg.command].apply(main, msg.args);
	        else if (msg.event)
	            sender._signal(msg.event, msg.data);
	    };

	    sender.postMessage = function(msg) {
	        _self.onMessage({data: msg});
	    };
	    sender.callback = function(data, callbackId) {
	        this.postMessage({type: "call", id: callbackId, data: data});
	    };
	    sender.emit = function(name, data) {
	        this.postMessage({type: "event", name: name, data: data});
	    };

	    config.loadModule(["worker", mod], function(Main) {
	        main = new Main[classname](sender);
	        while (_self.messageBuffer.length)
	            processNext();
	    });
	};

	UIWorkerClient.prototype = WorkerClient.prototype;

	exports.UIWorkerClient = UIWorkerClient;
	exports.WorkerClient = WorkerClient;

	});

	ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var oop = acequire("./lib/oop");

	var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
	    var _self = this;
	    this.length = length;
	    this.session = session;
	    this.doc = session.getDocument();
	    this.mainClass = mainClass;
	    this.othersClass = othersClass;
	    this.$onUpdate = this.onUpdate.bind(this);
	    this.doc.on("change", this.$onUpdate);
	    this.$others = others;
	    
	    this.$onCursorChange = function() {
	        setTimeout(function() {
	            _self.onCursorChange();
	        });
	    };
	    
	    this.$pos = pos;
	    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
	    this.$undoStackDepth = undoStack.length;
	    this.setup();

	    session.selection.on("changeCursor", this.$onCursorChange);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setup = function() {
	        var _self = this;
	        var doc = this.doc;
	        var session = this.session;
	        
	        this.selectionBefore = session.selection.toJSON();
	        if (session.selection.inMultiSelectMode)
	            session.selection.toSingleRange();

	        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
	        var pos = this.pos;
	        pos.$insertRight = true;
	        pos.detach();
	        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
	        this.others = [];
	        this.$others.forEach(function(other) {
	            var anchor = doc.createAnchor(other.row, other.column);
	            anchor.$insertRight = true;
	            anchor.detach();
	            _self.others.push(anchor);
	        });
	        session.setUndoSelect(false);
	    };
	    this.showOtherMarkers = function() {
	        if (this.othersActive) return;
	        var session = this.session;
	        var _self = this;
	        this.othersActive = true;
	        this.others.forEach(function(anchor) {
	            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
	        });
	    };
	    this.hideOtherMarkers = function() {
	        if (!this.othersActive) return;
	        this.othersActive = false;
	        for (var i = 0; i < this.others.length; i++) {
	            this.session.removeMarker(this.others[i].markerId);
	        }
	    };
	    this.onUpdate = function(delta) {
	        if (this.$updating)
	            return this.updateAnchors(delta);
	            
	        var range = delta;
	        if (range.start.row !== range.end.row) return;
	        if (range.start.row !== this.pos.row) return;
	        this.$updating = true;
	        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
	        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
	        var distanceFromStart = range.start.column - this.pos.column;
	        
	        this.updateAnchors(delta);
	        
	        if (inMainRange)
	            this.length += lengthDiff;

	        if (inMainRange && !this.session.$fromUndo) {
	            if (delta.action === 'insert') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                    this.doc.insertMergedLines(newPos, delta.lines);
	                }
	            } else if (delta.action === 'remove') {
	                for (var i = this.others.length - 1; i >= 0; i--) {
	                    var otherPos = this.others[i];
	                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
	                }
	            }
	        }
	        
	        this.$updating = false;
	        this.updateMarkers();
	    };
	    
	    this.updateAnchors = function(delta) {
	        this.pos.onChange(delta);
	        for (var i = this.others.length; i--;)
	            this.others[i].onChange(delta);
	        this.updateMarkers();
	    };
	    
	    this.updateMarkers = function() {
	        if (this.$updating)
	            return;
	        var _self = this;
	        var session = this.session;
	        var updateMarker = function(pos, className) {
	            session.removeMarker(pos.markerId);
	            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
	        };
	        updateMarker(this.pos, this.mainClass);
	        for (var i = this.others.length; i--;)
	            updateMarker(this.others[i], this.othersClass);
	    };

	    this.onCursorChange = function(event) {
	        if (this.$updating || !this.session) return;
	        var pos = this.session.selection.getCursor();
	        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
	            this.showOtherMarkers();
	            this._emit("cursorEnter", event);
	        } else {
	            this.hideOtherMarkers();
	            this._emit("cursorLeave", event);
	        }
	    };    
	    this.detach = function() {
	        this.session.removeMarker(this.pos && this.pos.markerId);
	        this.hideOtherMarkers();
	        this.doc.removeEventListener("change", this.$onUpdate);
	        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
	        this.session.setUndoSelect(true);
	        this.session = null;
	    };
	    this.cancel = function() {
	        if (this.$undoStackDepth === -1)
	            return;
	        var undoManager = this.session.getUndoManager();
	        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
	        for (var i = 0; i < undosRequired; i++) {
	            undoManager.undo(true);
	        }
	        if (this.selectionBefore)
	            this.session.selection.fromJSON(this.selectionBefore);
	    };
	}).call(PlaceHolder.prototype);


	exports.PlaceHolder = PlaceHolder;
	});

	ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}

	function onMouseDown(e) {
	    var ev = e.domEvent;
	    var alt = ev.altKey;
	    var shift = ev.shiftKey;
	    var ctrl = ev.ctrlKey;
	    var accel = e.getAccelKey();
	    var button = e.getButton();
	    
	    if (ctrl && useragent.isMac)
	        button = ev.button;

	    if (e.editor.inMultiSelectMode && button == 2) {
	        e.editor.textInput.onContextMenu(e.domEvent);
	        return;
	    }
	    
	    if (!ctrl && !alt && !accel) {
	        if (button === 0 && e.editor.inMultiSelectMode)
	            e.editor.exitMultiSelectMode();
	        return;
	    }
	    
	    if (button !== 0)
	        return;

	    var editor = e.editor;
	    var selection = editor.selection;
	    var isMultiSelect = editor.inMultiSelectMode;
	    var pos = e.getDocumentPosition();
	    var cursor = selection.getCursor();
	    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

	    var mouseX = e.x, mouseY = e.y;
	    var onMouseSelection = function(e) {
	        mouseX = e.clientX;
	        mouseY = e.clientY;
	    };
	    
	    var session = editor.session;
	    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	    var screenCursor = screenAnchor;
	    
	    var selectionMode;
	    if (editor.$mouseHandler.$enableJumpToDef) {
	        if (ctrl && alt || accel && alt)
	            selectionMode = shift ? "block" : "add";
	        else if (alt && editor.$blockSelectEnabled)
	            selectionMode = "block";
	    } else {
	        if (accel && !alt) {
	            selectionMode = "add";
	            if (!isMultiSelect && shift)
	                return;
	        } else if (alt && editor.$blockSelectEnabled) {
	            selectionMode = "block";
	        }
	    }
	    
	    if (selectionMode && useragent.isMac && ev.ctrlKey) {
	        editor.$mouseHandler.cancelContextMenu();
	    }

	    if (selectionMode == "add") {
	        if (!isMultiSelect && inSelection)
	            return; // dragging

	        if (!isMultiSelect) {
	            var range = selection.toOrientedRange();
	            editor.addSelectionMarker(range);
	        }

	        var oldRange = selection.rangeList.rangeAtPoint(pos);
	        
	        
	        editor.$blockScrolling++;
	        editor.inVirtualSelectionMode = true;
	        
	        if (shift) {
	            oldRange = null;
	            range = selection.ranges[0] || range;
	            editor.removeSelectionMarker(range);
	        }
	        editor.once("mouseup", function() {
	            var tmpSel = selection.toOrientedRange();

	            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
	                selection.substractPoint(tmpSel.cursor);
	            else {
	                if (shift) {
	                    selection.substractPoint(range.cursor);
	                } else if (range) {
	                    editor.removeSelectionMarker(range);
	                    selection.addRange(range);
	                }
	                selection.addRange(tmpSel);
	            }
	            editor.$blockScrolling--;
	            editor.inVirtualSelectionMode = false;
	        });

	    } else if (selectionMode == "block") {
	        e.stop();
	        editor.inVirtualSelectionMode = true;        
	        var initialRange;
	        var rectSel = [];
	        var blockSelect = function() {
	            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

	            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
	                return;
	            screenCursor = newCursor;
	            
	            editor.$blockScrolling++;
	            editor.selection.moveToPosition(cursor);
	            editor.renderer.scrollCursorIntoView();

	            editor.removeSelectionMarkers(rectSel);
	            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
	            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
	                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
	            rectSel.forEach(editor.addSelectionMarker, editor);
	            editor.updateSelectionMarkers();
	            editor.$blockScrolling--;
	        };
	        editor.$blockScrolling++;
	        if (isMultiSelect && !accel) {
	            selection.toSingleRange();
	        } else if (!isMultiSelect && accel) {
	            initialRange = selection.toOrientedRange();
	            editor.addSelectionMarker(initialRange);
	        }
	        
	        if (shift)
	            screenAnchor = session.documentToScreenPosition(selection.lead);            
	        else
	            selection.moveToPosition(pos);
	        editor.$blockScrolling--;
	        
	        screenCursor = {row: -1, column: -1};

	        var onMouseSelectionEnd = function(e) {
	            clearInterval(timerId);
	            editor.removeSelectionMarkers(rectSel);
	            if (!rectSel.length)
	                rectSel = [selection.toOrientedRange()];
	            editor.$blockScrolling++;
	            if (initialRange) {
	                editor.removeSelectionMarker(initialRange);
	                selection.toSingleRange(initialRange);
	            }
	            for (var i = 0; i < rectSel.length; i++)
	                selection.addRange(rectSel[i]);
	            editor.inVirtualSelectionMode = false;
	            editor.$mouseHandler.$clickSelection = null;
	            editor.$blockScrolling--;
	        };

	        var onSelectionInterval = blockSelect;

	        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
	        var timerId = setInterval(function() {onSelectionInterval();}, 20);

	        return e.preventDefault();
	    }
	}


	exports.onMouseDown = onMouseDown;

	});

	ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(acequire, exports, module) {
	exports.defaultCommands = [{
	    name: "addCursorAbove",
	    exec: function(editor) { editor.selectMoreLines(-1); },
	    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorBelow",
	    exec: function(editor) { editor.selectMoreLines(1); },
	    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorAboveSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "addCursorBelowSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectMoreBefore",
	    exec: function(editor) { editor.selectMore(-1); },
	    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectMoreAfter",
	    exec: function(editor) { editor.selectMore(1); },
	    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectNextBefore",
	    exec: function(editor) { editor.selectMore(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectNextAfter",
	    exec: function(editor) { editor.selectMore(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "splitIntoLines",
	    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
	    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
	    readOnly: true
	}, {
	    name: "alignCursors",
	    exec: function(editor) { editor.alignCursors(); },
	    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
	    scrollIntoView: "cursor"
	}, {
	    name: "findAll",
	    exec: function(editor) { editor.findAll(); },
	    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
	    scrollIntoView: "cursor",
	    readOnly: true
	}];
	exports.multiSelectCommands = [{
	    name: "singleSelection",
	    bindKey: "esc",
	    exec: function(editor) { editor.exitMultiSelectMode(); },
	    scrollIntoView: "cursor",
	    readOnly: true,
	    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
	}];

	var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
	exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

	});

	ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(acequire, exports, module) {

	var RangeList = acequire("./range_list").RangeList;
	var Range = acequire("./range").Range;
	var Selection = acequire("./selection").Selection;
	var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
	var event = acequire("./lib/event");
	var lang = acequire("./lib/lang");
	var commands = acequire("./commands/multi_select_commands");
	exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
	var Search = acequire("./search").Search;
	var search = new Search();

	function find(session, needle, dir) {
	    search.$options.wrap = true;
	    search.$options.needle = needle;
	    search.$options.backwards = dir == -1;
	    return search.find(session);
	}
	var EditSession = acequire("./edit_session").EditSession;
	(function() {
	    this.getSelectionMarkers = function() {
	        return this.$selectionMarkers;
	    };
	}).call(EditSession.prototype);
	(function() {
	    this.ranges = null;
	    this.rangeList = null;
	    this.addRange = function(range, $blockChangeEvents) {
	        if (!range)
	            return;

	        if (!this.inMultiSelectMode && this.rangeCount === 0) {
	            var oldRange = this.toOrientedRange();
	            this.rangeList.add(oldRange);
	            this.rangeList.add(range);
	            if (this.rangeList.ranges.length != 2) {
	                this.rangeList.removeAll();
	                return $blockChangeEvents || this.fromOrientedRange(range);
	            }
	            this.rangeList.removeAll();
	            this.rangeList.add(oldRange);
	            this.$onAddRange(oldRange);
	        }

	        if (!range.cursor)
	            range.cursor = range.end;

	        var removed = this.rangeList.add(range);

	        this.$onAddRange(range);

	        if (removed.length)
	            this.$onRemoveRange(removed);

	        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
	            this._signal("multiSelect");
	            this.inMultiSelectMode = true;
	            this.session.$undoSelect = false;
	            this.rangeList.attach(this.session);
	        }

	        return $blockChangeEvents || this.fromOrientedRange(range);
	    };

	    this.toSingleRange = function(range) {
	        range = range || this.ranges[0];
	        var removed = this.rangeList.removeAll();
	        if (removed.length)
	            this.$onRemoveRange(removed);

	        range && this.fromOrientedRange(range);
	    };
	    this.substractPoint = function(pos) {
	        var removed = this.rangeList.substractPoint(pos);
	        if (removed) {
	            this.$onRemoveRange(removed);
	            return removed[0];
	        }
	    };
	    this.mergeOverlappingRanges = function() {
	        var removed = this.rangeList.merge();
	        if (removed.length)
	            this.$onRemoveRange(removed);
	        else if(this.ranges[0])
	            this.fromOrientedRange(this.ranges[0]);
	    };

	    this.$onAddRange = function(range) {
	        this.rangeCount = this.rangeList.ranges.length;
	        this.ranges.unshift(range);
	        this._signal("addRange", {range: range});
	    };

	    this.$onRemoveRange = function(removed) {
	        this.rangeCount = this.rangeList.ranges.length;
	        if (this.rangeCount == 1 && this.inMultiSelectMode) {
	            var lastRange = this.rangeList.ranges.pop();
	            removed.push(lastRange);
	            this.rangeCount = 0;
	        }

	        for (var i = removed.length; i--; ) {
	            var index = this.ranges.indexOf(removed[i]);
	            this.ranges.splice(index, 1);
	        }

	        this._signal("removeRange", {ranges: removed});

	        if (this.rangeCount === 0 && this.inMultiSelectMode) {
	            this.inMultiSelectMode = false;
	            this._signal("singleSelect");
	            this.session.$undoSelect = true;
	            this.rangeList.detach(this.session);
	        }

	        lastRange = lastRange || this.ranges[0];
	        if (lastRange && !lastRange.isEqual(this.getRange()))
	            this.fromOrientedRange(lastRange);
	    };
	    this.$initRangeList = function() {
	        if (this.rangeList)
	            return;

	        this.rangeList = new RangeList();
	        this.ranges = [];
	        this.rangeCount = 0;
	    };
	    this.getAllRanges = function() {
	        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
	    };

	    this.splitIntoLines = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var range = this.getRange();
	            var isBackwards = this.isBackwards();
	            var startRow = range.start.row;
	            var endRow = range.end.row;
	            if (startRow == endRow) {
	                if (isBackwards)
	                    var start = range.end, end = range.start;
	                else
	                    var start = range.start, end = range.end;
	                
	                this.addRange(Range.fromPoints(end, end));
	                this.addRange(Range.fromPoints(start, start));
	                return;
	            }

	            var rectSel = [];
	            var r = this.getLineRange(startRow, true);
	            r.start.column = range.start.column;
	            rectSel.push(r);

	            for (var i = startRow + 1; i < endRow; i++)
	                rectSel.push(this.getLineRange(i, true));

	            r = this.getLineRange(endRow, true);
	            r.end.column = range.end.column;
	            rectSel.push(r);

	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.toggleBlockSelection = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var cursor = this.session.documentToScreenPosition(this.selectionLead);
	            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

	            var rectSel = this.rectangularRangeBlock(cursor, anchor);
	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
	        var rectSel = [];

	        var xBackwards = screenCursor.column < screenAnchor.column;
	        if (xBackwards) {
	            var startColumn = screenCursor.column;
	            var endColumn = screenAnchor.column;
	        } else {
	            var startColumn = screenAnchor.column;
	            var endColumn = screenCursor.column;
	        }

	        var yBackwards = screenCursor.row < screenAnchor.row;
	        if (yBackwards) {
	            var startRow = screenCursor.row;
	            var endRow = screenAnchor.row;
	        } else {
	            var startRow = screenAnchor.row;
	            var endRow = screenCursor.row;
	        }

	        if (startColumn < 0)
	            startColumn = 0;
	        if (startRow < 0)
	            startRow = 0;

	        if (startRow == endRow)
	            includeEmptyLines = true;

	        for (var row = startRow; row <= endRow; row++) {
	            var range = Range.fromPoints(
	                this.session.screenToDocumentPosition(row, startColumn),
	                this.session.screenToDocumentPosition(row, endColumn)
	            );
	            if (range.isEmpty()) {
	                if (docEnd && isSamePoint(range.end, docEnd))
	                    break;
	                var docEnd = range.end;
	            }
	            range.cursor = xBackwards ? range.start : range.end;
	            rectSel.push(range);
	        }

	        if (yBackwards)
	            rectSel.reverse();

	        if (!includeEmptyLines) {
	            var end = rectSel.length - 1;
	            while (rectSel[end].isEmpty() && end > 0)
	                end--;
	            if (end > 0) {
	                var start = 0;
	                while (rectSel[start].isEmpty())
	                    start++;
	            }
	            for (var i = end; i >= start; i--) {
	                if (rectSel[i].isEmpty())
	                    rectSel.splice(i, 1);
	            }
	        }

	        return rectSel;
	    };
	}).call(Selection.prototype);
	var Editor = acequire("./editor").Editor;
	(function() {
	    this.updateSelectionMarkers = function() {
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.addSelectionMarker = function(orientedRange) {
	        if (!orientedRange.cursor)
	            orientedRange.cursor = orientedRange.end;

	        var style = this.getSelectionStyle();
	        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

	        this.session.$selectionMarkers.push(orientedRange);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	        return orientedRange;
	    };
	    this.removeSelectionMarker = function(range) {
	        if (!range.marker)
	            return;
	        this.session.removeMarker(range.marker);
	        var index = this.session.$selectionMarkers.indexOf(range);
	        if (index != -1)
	            this.session.$selectionMarkers.splice(index, 1);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	    };

	    this.removeSelectionMarkers = function(ranges) {
	        var markerList = this.session.$selectionMarkers;
	        for (var i = ranges.length; i--; ) {
	            var range = ranges[i];
	            if (!range.marker)
	                continue;
	            this.session.removeMarker(range.marker);
	            var index = markerList.indexOf(range);
	            if (index != -1)
	                markerList.splice(index, 1);
	        }
	        this.session.selectionMarkerCount = markerList.length;
	    };

	    this.$onAddRange = function(e) {
	        this.addSelectionMarker(e.range);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onRemoveRange = function(e) {
	        this.removeSelectionMarkers(e.ranges);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onMultiSelect = function(e) {
	        if (this.inMultiSelectMode)
	            return;
	        this.inMultiSelectMode = true;

	        this.setStyle("ace_multiselect");
	        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
	        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onSingleSelect = function(e) {
	        if (this.session.multiSelect.inVirtualMode)
	            return;
	        this.inMultiSelectMode = false;

	        this.unsetStyle("ace_multiselect");
	        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

	        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	        this._emit("changeSelection");
	    };

	    this.$onMultiSelectExec = function(e) {
	        var command = e.command;
	        var editor = e.editor;
	        if (!editor.multiSelect)
	            return;
	        if (!command.multiSelectAction) {
	            var result = command.exec(editor, e.args || {});
	            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
	            editor.multiSelect.mergeOverlappingRanges();
	        } else if (command.multiSelectAction == "forEach") {
	            result = editor.forEachSelection(command, e.args);
	        } else if (command.multiSelectAction == "forEachLine") {
	            result = editor.forEachSelection(command, e.args, true);
	        } else if (command.multiSelectAction == "single") {
	            editor.exitMultiSelectMode();
	            result = command.exec(editor, e.args || {});
	        } else {
	            result = command.multiSelectAction(editor, e.args || {});
	        }
	        return result;
	    }; 
	    this.forEachSelection = function(cmd, args, options) {
	        if (this.inVirtualSelectionMode)
	            return;
	        var keepOrder = options && options.keepOrder;
	        var $byLines = options == true || options && options.$byLines
	        var session = this.session;
	        var selection = this.selection;
	        var rangeList = selection.rangeList;
	        var ranges = (keepOrder ? selection : rangeList).ranges;
	        var result;
	        
	        if (!ranges.length)
	            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	        
	        var reg = selection._eventRegistry;
	        selection._eventRegistry = {};

	        var tmpSel = new Selection(session);
	        this.inVirtualSelectionMode = true;
	        for (var i = ranges.length; i--;) {
	            if ($byLines) {
	                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
	                    i--;
	            }
	            tmpSel.fromOrientedRange(ranges[i]);
	            tmpSel.index = i;
	            this.selection = session.selection = tmpSel;
	            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	            if (!result && cmdResult !== undefined)
	                result = cmdResult;
	            tmpSel.toOrientedRange(ranges[i]);
	        }
	        tmpSel.detach();

	        this.selection = session.selection = selection;
	        this.inVirtualSelectionMode = false;
	        selection._eventRegistry = reg;
	        selection.mergeOverlappingRanges();
	        
	        var anim = this.renderer.$scrollAnimation;
	        this.onCursorChange();
	        this.onSelectionChange();
	        if (anim && anim.from == anim.to)
	            this.renderer.animateScrolling(anim.from);
	        
	        return result;
	    };
	    this.exitMultiSelectMode = function() {
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
	            return;
	        this.multiSelect.toSingleRange();
	    };

	    this.getSelectedText = function() {
	        var text = "";
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var ranges = this.multiSelect.rangeList.ranges;
	            var buf = [];
	            for (var i = 0; i < ranges.length; i++) {
	                buf.push(this.session.getTextRange(ranges[i]));
	            }
	            var nl = this.session.getDocument().getNewLineCharacter();
	            text = buf.join(nl);
	            if (text.length == (buf.length - 1) * nl.length)
	                text = "";
	        } else if (!this.selection.isEmpty()) {
	            text = this.session.getTextRange(this.getSelectionRange());
	        }
	        return text;
	    };
	    
	    this.$checkMultiselectChange = function(e, anchor) {
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var range = this.multiSelect.ranges[0];
	            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
	                return;
	            var pos = anchor == this.multiSelect.anchor
	                ? range.cursor == range.start ? range.end : range.start
	                : range.cursor;
	            if (pos.row != anchor.row 
	                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
	                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
	        }
	    };
	    this.findAll = function(needle, options, additive) {
	        options = options || {};
	        options.needle = needle || options.needle;
	        if (options.needle == undefined) {
	            var range = this.selection.isEmpty()
	                ? this.selection.getWordRange()
	                : this.selection.getRange();
	            options.needle = this.session.getTextRange(range);
	        }    
	        this.$search.set(options);
	        
	        var ranges = this.$search.findAll(this.session);
	        if (!ranges.length)
	            return 0;

	        this.$blockScrolling += 1;
	        var selection = this.multiSelect;

	        if (!additive)
	            selection.toSingleRange(ranges[0]);

	        for (var i = ranges.length; i--; )
	            selection.addRange(ranges[i], true);
	        if (range && selection.rangeList.rangeAtPoint(range.start))
	            selection.addRange(range, true);
	        
	        this.$blockScrolling -= 1;

	        return ranges.length;
	    };
	    this.selectMoreLines = function(dir, skip) {
	        var range = this.selection.toOrientedRange();
	        var isBackwards = range.cursor == range.end;

	        var screenLead = this.session.documentToScreenPosition(range.cursor);
	        if (this.selection.$desiredColumn)
	            screenLead.column = this.selection.$desiredColumn;

	        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

	        if (!range.isEmpty()) {
	            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
	            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
	        } else {
	            var anchor = lead;
	        }

	        if (isBackwards) {
	            var newRange = Range.fromPoints(lead, anchor);
	            newRange.cursor = newRange.start;
	        } else {
	            var newRange = Range.fromPoints(anchor, lead);
	            newRange.cursor = newRange.end;
	        }

	        newRange.desiredColumn = screenLead.column;
	        if (!this.selection.inMultiSelectMode) {
	            this.selection.addRange(range);
	        } else {
	            if (skip)
	                var toRemove = range.cursor;
	        }

	        this.selection.addRange(newRange);
	        if (toRemove)
	            this.selection.substractPoint(toRemove);
	    };
	    this.transposeSelections = function(dir) {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var all = sel.ranges;

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            if (range.isEmpty()) {
	                var tmp = session.getWordRange(range.start.row, range.start.column);
	                range.start.row = tmp.start.row;
	                range.start.column = tmp.start.column;
	                range.end.row = tmp.end.row;
	                range.end.column = tmp.end.column;
	            }
	        }
	        sel.mergeOverlappingRanges();

	        var words = [];
	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            words.unshift(session.getTextRange(range));
	        }

	        if (dir < 0)
	            words.unshift(words.pop());
	        else
	            words.push(words.shift());

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            var tmp = range.clone();
	            session.replace(range, words[i]);
	            range.start.row = tmp.start.row;
	            range.start.column = tmp.start.column;
	        }
	    };
	    this.selectMore = function(dir, skip, stopAtFirst) {
	        var session = this.session;
	        var sel = session.multiSelect;

	        var range = sel.toOrientedRange();
	        if (range.isEmpty()) {
	            range = session.getWordRange(range.start.row, range.start.column);
	            range.cursor = dir == -1 ? range.start : range.end;
	            this.multiSelect.addRange(range);
	            if (stopAtFirst)
	                return;
	        }
	        var needle = session.getTextRange(range);

	        var newRange = find(session, needle, dir);
	        if (newRange) {
	            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
	            this.$blockScrolling += 1;
	            this.session.unfold(newRange);
	            this.multiSelect.addRange(newRange);
	            this.$blockScrolling -= 1;
	            this.renderer.scrollCursorIntoView(null, 0.5);
	        }
	        if (skip)
	            this.multiSelect.substractPoint(range.cursor);
	    };
	    this.alignCursors = function() {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var ranges = sel.ranges;
	        var row = -1;
	        var sameRowRanges = ranges.filter(function(r) {
	            if (r.cursor.row == row)
	                return true;
	            row = r.cursor.row;
	        });
	        
	        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
	            var range = this.selection.getRange();
	            var fr = range.start.row, lr = range.end.row;
	            var guessRange = fr == lr;
	            if (guessRange) {
	                var max = this.session.getLength();
	                var line;
	                do {
	                    line = this.session.getLine(lr);
	                } while (/[=:]/.test(line) && ++lr < max);
	                do {
	                    line = this.session.getLine(fr);
	                } while (/[=:]/.test(line) && --fr > 0);
	                
	                if (fr < 0) fr = 0;
	                if (lr >= max) lr = max - 1;
	            }
	            var lines = this.session.removeFullLines(fr, lr);
	            lines = this.$reAlignText(lines, guessRange);
	            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
	            if (!guessRange) {
	                range.start.column = 0;
	                range.end.column = lines[lines.length - 1].length;
	            }
	            this.selection.setRange(range);
	        } else {
	            sameRowRanges.forEach(function(r) {
	                sel.substractPoint(r.cursor);
	            });

	            var maxCol = 0;
	            var minSpace = Infinity;
	            var spaceOffsets = ranges.map(function(r) {
	                var p = r.cursor;
	                var line = session.getLine(p.row);
	                var spaceOffset = line.substr(p.column).search(/\S/g);
	                if (spaceOffset == -1)
	                    spaceOffset = 0;

	                if (p.column > maxCol)
	                    maxCol = p.column;
	                if (spaceOffset < minSpace)
	                    minSpace = spaceOffset;
	                return spaceOffset;
	            });
	            ranges.forEach(function(r, i) {
	                var p = r.cursor;
	                var l = maxCol - p.column;
	                var d = spaceOffsets[i] - minSpace;
	                if (l > d)
	                    session.insert(p, lang.stringRepeat(" ", l - d));
	                else
	                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

	                r.start.column = r.end.column = maxCol;
	                r.start.row = r.end.row = p.row;
	                r.cursor = r.end;
	            });
	            sel.fromOrientedRange(ranges[0]);
	            this.renderer.updateCursor();
	            this.renderer.updateBackMarkers();
	        }
	    };

	    this.$reAlignText = function(lines, forceLeft) {
	        var isLeftAligned = true, isRightAligned = true;
	        var startW, textW, endW;

	        return lines.map(function(line) {
	            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
	            if (!m)
	                return [line];

	            if (startW == null) {
	                startW = m[1].length;
	                textW = m[2].length;
	                endW = m[3].length;
	                return m;
	            }

	            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
	                isRightAligned = false;
	            if (startW != m[1].length)
	                isLeftAligned = false;

	            if (startW > m[1].length)
	                startW = m[1].length;
	            if (textW < m[2].length)
	                textW = m[2].length;
	            if (endW > m[3].length)
	                endW = m[3].length;

	            return m;
	        }).map(forceLeft ? alignLeft :
	            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

	        function spaces(n) {
	            return lang.stringRepeat(" ", n);
	        }

	        function alignLeft(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(textW - m[2].length + endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function alignRight(m) {
	            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
	                + spaces(endW, " ")
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function unAlign(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	    };
	}).call(Editor.prototype);


	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}
	exports.onSessionChange = function(e) {
	    var session = e.session;
	    if (session && !session.multiSelect) {
	        session.$selectionMarkers = [];
	        session.selection.$initRangeList();
	        session.multiSelect = session.selection;
	    }
	    this.multiSelect = session && session.multiSelect;

	    var oldSession = e.oldSession;
	    if (oldSession) {
	        oldSession.multiSelect.off("addRange", this.$onAddRange);
	        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
	        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
	        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
	        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
	        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
	    }

	    if (session) {
	        session.multiSelect.on("addRange", this.$onAddRange);
	        session.multiSelect.on("removeRange", this.$onRemoveRange);
	        session.multiSelect.on("multiSelect", this.$onMultiSelect);
	        session.multiSelect.on("singleSelect", this.$onSingleSelect);
	        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
	        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
	    }

	    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
	        if (session.selection.inMultiSelectMode)
	            this.$onMultiSelect();
	        else
	            this.$onSingleSelect();
	    }
	};
	function MultiSelect(editor) {
	    if (editor.$multiselectOnSessionChange)
	        return;
	    editor.$onAddRange = editor.$onAddRange.bind(editor);
	    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
	    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
	    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
	    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
	    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

	    editor.$multiselectOnSessionChange(editor);
	    editor.on("changeSession", editor.$multiselectOnSessionChange);

	    editor.on("mousedown", onMouseDown);
	    editor.commands.addCommands(commands.defaultCommands);

	    addAltCursorListeners(editor);
	}

	function addAltCursorListeners(editor){
	    var el = editor.textInput.getElement();
	    var altCursor = false;
	    event.addListener(el, "keydown", function(e) {
	        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
	        if (editor.$blockSelectEnabled && altDown) {
	            if (!altCursor) {
	                editor.renderer.setMouseCursor("crosshair");
	                altCursor = true;
	            }
	        } else if (altCursor) {
	            reset();
	        }
	    });

	    event.addListener(el, "keyup", reset);
	    event.addListener(el, "blur", reset);
	    function reset(e) {
	        if (altCursor) {
	            editor.renderer.setMouseCursor("");
	            altCursor = false;
	        }
	    }
	}

	exports.MultiSelect = MultiSelect;


	acequire("./config").defineOptions(Editor.prototype, "editor", {
	    enableMultiselect: {
	        set: function(val) {
	            MultiSelect(this);
	            if (val) {
	                this.on("changeSession", this.$multiselectOnSessionChange);
	                this.on("mousedown", onMouseDown);
	            } else {
	                this.off("changeSession", this.$multiselectOnSessionChange);
	                this.off("mousedown", onMouseDown);
	            }
	        },
	        value: true
	    },
	    enableBlockSelect: {
	        set: function(val) {
	            this.$blockSelectEnabled = val;
	        },
	        value: true
	    }
	});



	});

	ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../../range").Range;

	var FoldMode = exports.FoldMode = function() {};

	(function() {

	    this.foldingStartMarker = null;
	    this.foldingStopMarker = null;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	        if (this.foldingStartMarker.test(line))
	            return "start";
	        if (foldStyle == "markbeginend"
	                && this.foldingStopMarker
	                && this.foldingStopMarker.test(line))
	            return "end";
	        return "";
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        return null;
	    };

	    this.indentationBlock = function(session, row, column) {
	        var re = /\S/;
	        var line = session.getLine(row);
	        var startLevel = line.search(re);
	        if (startLevel == -1)
	            return;

	        var startColumn = column || line.length;
	        var maxRow = session.getLength();
	        var startRow = row;
	        var endRow = row;

	        while (++row < maxRow) {
	            var level = session.getLine(row).search(re);

	            if (level == -1)
	                continue;

	            if (level <= startLevel)
	                break;

	            endRow = row;
	        }

	        if (endRow > startRow) {
	            var endColumn = session.getLine(endRow).length;
	            return new Range(startRow, startColumn, endRow, endColumn);
	        }
	    };

	    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var start = {row: row, column: column + 1};
	        var end = session.$findClosingBracket(bracket, start, typeRe);
	        if (!end)
	            return;

	        var fw = session.foldWidgets[end.row];
	        if (fw == null)
	            fw = session.getFoldWidget(end.row);

	        if (fw == "start" && end.row > start.row) {
	            end.row --;
	            end.column = session.getLine(end.row).length;
	        }
	        return Range.fromPoints(start, end);
	    };

	    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var end = {row: row, column: column};
	        var start = session.$findOpeningBracket(bracket, end);

	        if (!start)
	            return;

	        start.column++;
	        end.column--;

	        return  Range.fromPoints(start, end);
	    };
	}).call(FoldMode.prototype);

	});

	ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	exports.isDark = false;
	exports.cssClass = "ace-tm";
	exports.cssText = ".ace-tm .ace_gutter {\
	background: #f0f0f0;\
	color: #333;\
	}\
	.ace-tm .ace_print-margin {\
	width: 1px;\
	background: #e8e8e8;\
	}\
	.ace-tm .ace_fold {\
	background-color: #6B72E6;\
	}\
	.ace-tm {\
	background-color: #FFFFFF;\
	color: black;\
	}\
	.ace-tm .ace_cursor {\
	color: black;\
	}\
	.ace-tm .ace_invisible {\
	color: rgb(191, 191, 191);\
	}\
	.ace-tm .ace_storage,\
	.ace-tm .ace_keyword {\
	color: blue;\
	}\
	.ace-tm .ace_constant {\
	color: rgb(197, 6, 11);\
	}\
	.ace-tm .ace_constant.ace_buildin {\
	color: rgb(88, 72, 246);\
	}\
	.ace-tm .ace_constant.ace_language {\
	color: rgb(88, 92, 246);\
	}\
	.ace-tm .ace_constant.ace_library {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_invalid {\
	background-color: rgba(255, 0, 0, 0.1);\
	color: red;\
	}\
	.ace-tm .ace_support.ace_function {\
	color: rgb(60, 76, 114);\
	}\
	.ace-tm .ace_support.ace_constant {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_support.ace_type,\
	.ace-tm .ace_support.ace_class {\
	color: rgb(109, 121, 222);\
	}\
	.ace-tm .ace_keyword.ace_operator {\
	color: rgb(104, 118, 135);\
	}\
	.ace-tm .ace_string {\
	color: rgb(3, 106, 7);\
	}\
	.ace-tm .ace_comment {\
	color: rgb(76, 136, 107);\
	}\
	.ace-tm .ace_comment.ace_doc {\
	color: rgb(0, 102, 255);\
	}\
	.ace-tm .ace_comment.ace_doc.ace_tag {\
	color: rgb(128, 159, 191);\
	}\
	.ace-tm .ace_constant.ace_numeric {\
	color: rgb(0, 0, 205);\
	}\
	.ace-tm .ace_variable {\
	color: rgb(49, 132, 149);\
	}\
	.ace-tm .ace_xml-pe {\
	color: rgb(104, 104, 91);\
	}\
	.ace-tm .ace_entity.ace_name.ace_function {\
	color: #0000A2;\
	}\
	.ace-tm .ace_heading {\
	color: rgb(12, 7, 255);\
	}\
	.ace-tm .ace_list {\
	color:rgb(185, 6, 144);\
	}\
	.ace-tm .ace_meta.ace_tag {\
	color:rgb(0, 22, 142);\
	}\
	.ace-tm .ace_string.ace_regex {\
	color: rgb(255, 0, 0)\
	}\
	.ace-tm .ace_marker-layer .ace_selection {\
	background: rgb(181, 213, 255);\
	}\
	.ace-tm.ace_multiselect .ace_selection.ace_start {\
	box-shadow: 0 0 3px 0px white;\
	}\
	.ace-tm .ace_marker-layer .ace_step {\
	background: rgb(252, 255, 0);\
	}\
	.ace-tm .ace_marker-layer .ace_stack {\
	background: rgb(164, 229, 101);\
	}\
	.ace-tm .ace_marker-layer .ace_bracket {\
	margin: -1px 0 0 -1px;\
	border: 1px solid rgb(192, 192, 192);\
	}\
	.ace-tm .ace_marker-layer .ace_active-line {\
	background: rgba(0, 0, 0, 0.07);\
	}\
	.ace-tm .ace_gutter-active-line {\
	background-color : #dcdcdc;\
	}\
	.ace-tm .ace_marker-layer .ace_selected-word {\
	background: rgb(250, 250, 255);\
	border: 1px solid rgb(200, 200, 250);\
	}\
	.ace-tm .ace_indent-guide {\
	background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
	}\
	";

	var dom = acequire("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass);
	});

	ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var Range = acequire("./range").Range;


	function LineWidgets(session) {
	    this.session = session;
	    this.session.widgetManager = this;
	    this.session.getRowLength = this.getRowLength;
	    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
	    this.updateOnChange = this.updateOnChange.bind(this);
	    this.renderWidgets = this.renderWidgets.bind(this);
	    this.measureWidgets = this.measureWidgets.bind(this);
	    this.session._changedWidgets = [];
	    this.$onChangeEditor = this.$onChangeEditor.bind(this);
	    
	    this.session.on("change", this.updateOnChange);
	    this.session.on("changeFold", this.updateOnFold);
	    this.session.on("changeEditor", this.$onChangeEditor);
	}

	(function() {
	    this.getRowLength = function(row) {
	        var h;
	        if (this.lineWidgets)
	            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0;
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };

	    this.$getWidgetScreenLength = function() {
	        var screenRows = 0;
	        this.lineWidgets.forEach(function(w){
	            if (w && w.rowCount && !w.hidden)
	                screenRows += w.rowCount;
	        });
	        return screenRows;
	    };    
	    
	    this.$onChangeEditor = function(e) {
	        this.attach(e.editor);
	    };
	    
	    this.attach = function(editor) {
	        if (editor  && editor.widgetManager && editor.widgetManager != this)
	            editor.widgetManager.detach();

	        if (this.editor == editor)
	            return;

	        this.detach();
	        this.editor = editor;
	        
	        if (editor) {
	            editor.widgetManager = this;
	            editor.renderer.on("beforeRender", this.measureWidgets);
	            editor.renderer.on("afterRender", this.renderWidgets);
	        }
	    };
	    this.detach = function(e) {
	        var editor = this.editor;
	        if (!editor)
	            return;
	        
	        this.editor = null;
	        editor.widgetManager = null;
	        
	        editor.renderer.off("beforeRender", this.measureWidgets);
	        editor.renderer.off("afterRender", this.renderWidgets);
	        var lineWidgets = this.session.lineWidgets;
	        lineWidgets && lineWidgets.forEach(function(w) {
	            if (w && w.el && w.el.parentNode) {
	                w._inDocument = false;
	                w.el.parentNode.removeChild(w.el);
	            }
	        });
	    };

	    this.updateOnFold = function(e, session) {
	        var lineWidgets = session.lineWidgets;
	        if (!lineWidgets || !e.action)
	            return;
	        var fold = e.data;
	        var start = fold.start.row;
	        var end = fold.end.row;
	        var hide = e.action == "add";
	        for (var i = start + 1; i < end; i++) {
	            if (lineWidgets[i])
	                lineWidgets[i].hidden = hide;
	        }
	        if (lineWidgets[end]) {
	            if (hide) {
	                if (!lineWidgets[start])
	                    lineWidgets[start] = lineWidgets[end];
	                else
	                    lineWidgets[end].hidden = hide;
	            } else {
	                if (lineWidgets[start] == lineWidgets[end])
	                    lineWidgets[start] = undefined;
	                lineWidgets[end].hidden = hide;
	            }
	        }
	    };
	    
	    this.updateOnChange = function(delta) {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	        
	        var startRow = delta.start.row;
	        var len = delta.end.row - startRow;

	        if (len === 0) {
	        } else if (delta.action == 'remove') {
	            var removed = lineWidgets.splice(startRow + 1, len);
	            removed.forEach(function(w) {
	                w && this.removeLineWidget(w);
	            }, this);
	            this.$updateRows();
	        } else {
	            var args = new Array(len);
	            args.unshift(startRow, 0);
	            lineWidgets.splice.apply(lineWidgets, args);
	            this.$updateRows();
	        }
	    };
	    
	    this.$updateRows = function() {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	        var noWidgets = true;
	        lineWidgets.forEach(function(w, i) {
	            if (w) {
	                noWidgets = false;
	                w.row = i;
	                while (w.$oldWidget) {
	                    w.$oldWidget.row = i;
	                    w = w.$oldWidget;
	                }
	            }
	        });
	        if (noWidgets)
	            this.session.lineWidgets = null;
	    };

	    this.addLineWidget = function(w) {
	        if (!this.session.lineWidgets)
	            this.session.lineWidgets = new Array(this.session.getLength());
	        
	        var old = this.session.lineWidgets[w.row];
	        if (old) {
	            w.$oldWidget = old;
	            if (old.el && old.el.parentNode) {
	                old.el.parentNode.removeChild(old.el);
	                old._inDocument = false;
	            }
	        }
	            
	        this.session.lineWidgets[w.row] = w;
	        
	        w.session = this.session;
	        
	        var renderer = this.editor.renderer;
	        if (w.html && !w.el) {
	            w.el = dom.createElement("div");
	            w.el.innerHTML = w.html;
	        }
	        if (w.el) {
	            dom.addCssClass(w.el, "ace_lineWidgetContainer");
	            w.el.style.position = "absolute";
	            w.el.style.zIndex = 5;
	            renderer.container.appendChild(w.el);
	            w._inDocument = true;
	        }
	        
	        if (!w.coverGutter) {
	            w.el.style.zIndex = 3;
	        }
	        if (!w.pixelHeight) {
	            w.pixelHeight = w.el.offsetHeight;
	        }
	        if (w.rowCount == null) {
	            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
	        }
	        
	        var fold = this.session.getFoldAt(w.row, 0);
	        w.$fold = fold;
	        if (fold) {
	            var lineWidgets = this.session.lineWidgets;
	            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
	                lineWidgets[fold.start.row] = w;
	            else
	                w.hidden = true;
	        }
	            
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        
	        this.$updateRows();
	        this.renderWidgets(null, renderer);
	        this.onWidgetChanged(w);
	        return w;
	    };
	    
	    this.removeLineWidget = function(w) {
	        w._inDocument = false;
	        w.session = null;
	        if (w.el && w.el.parentNode)
	            w.el.parentNode.removeChild(w.el);
	        if (w.editor && w.editor.destroy) try {
	            w.editor.destroy();
	        } catch(e){}
	        if (this.session.lineWidgets) {
	            var w1 = this.session.lineWidgets[w.row]
	            if (w1 == w) {
	                this.session.lineWidgets[w.row] = w.$oldWidget;
	                if (w.$oldWidget)
	                    this.onWidgetChanged(w.$oldWidget);
	            } else {
	                while (w1) {
	                    if (w1.$oldWidget == w) {
	                        w1.$oldWidget = w.$oldWidget;
	                        break;
	                    }
	                    w1 = w1.$oldWidget;
	                }
	            }
	        }
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        this.$updateRows();
	    };
	    
	    this.getWidgetsAtRow = function(row) {
	        var lineWidgets = this.session.lineWidgets;
	        var w = lineWidgets && lineWidgets[row];
	        var list = [];
	        while (w) {
	            list.push(w);
	            w = w.$oldWidget;
	        }
	        return list;
	    };
	    
	    this.onWidgetChanged = function(w) {
	        this.session._changedWidgets.push(w);
	        this.editor && this.editor.renderer.updateFull();
	    };
	    
	    this.measureWidgets = function(e, renderer) {
	        var changedWidgets = this.session._changedWidgets;
	        var config = renderer.layerConfig;
	        
	        if (!changedWidgets || !changedWidgets.length) return;
	        var min = Infinity;
	        for (var i = 0; i < changedWidgets.length; i++) {
	            var w = changedWidgets[i];
	            if (!w || !w.el) continue;
	            if (w.session != this.session) continue;
	            if (!w._inDocument) {
	                if (this.session.lineWidgets[w.row] != w)
	                    continue;
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            
	            w.h = w.el.offsetHeight;
	            
	            if (!w.fixedWidth) {
	                w.w = w.el.offsetWidth;
	                w.screenWidth = Math.ceil(w.w / config.characterWidth);
	            }
	            
	            var rowCount = w.h / config.lineHeight;
	            if (w.coverLine) {
	                rowCount -= this.session.getRowLineCount(w.row);
	                if (rowCount < 0)
	                    rowCount = 0;
	            }
	            if (w.rowCount != rowCount) {
	                w.rowCount = rowCount;
	                if (w.row < min)
	                    min = w.row;
	            }
	        }
	        if (min != Infinity) {
	            this.session._emit("changeFold", {data:{start:{row: min}}});
	            this.session.lineWidgetWidth = null;
	        }
	        this.session._changedWidgets = [];
	    };
	    
	    this.renderWidgets = function(e, renderer) {
	        var config = renderer.layerConfig;
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var first = Math.min(this.firstRow, config.firstRow);
	        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
	        
	        while (first > 0 && !lineWidgets[first])
	            first--;
	        
	        this.firstRow = config.firstRow;
	        this.lastRow = config.lastRow;

	        renderer.$cursorLayer.config = config;
	        for (var i = first; i <= last; i++) {
	            var w = lineWidgets[i];
	            if (!w || !w.el) continue;
	            if (w.hidden) {
	                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
	                continue;
	            }
	            if (!w._inDocument) {
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
	            if (!w.coverLine)
	                top += config.lineHeight * this.session.getRowLineCount(w.row);
	            w.el.style.top = top - config.offset + "px";
	            
	            var left = w.coverGutter ? 0 : renderer.gutterWidth;
	            if (!w.fixedWidth)
	                left -= renderer.scrollLeft;
	            w.el.style.left = left + "px";
	            
	            if (w.fullWidth && w.screenWidth) {
	                w.el.style.minWidth = config.width + 2 * config.padding + "px";
	            }
	            
	            if (w.fixedWidth) {
	                w.el.style.right = renderer.scrollBar.getWidth() + "px";
	            } else {
	                w.el.style.right = "";
	            }
	        }
	    };
	    
	}).call(LineWidgets.prototype);


	exports.LineWidgets = LineWidgets;

	});

	ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";
	var LineWidgets = acequire("../line_widgets").LineWidgets;
	var dom = acequire("../lib/dom");
	var Range = acequire("../range").Range;

	function binarySearch(array, needle, comparator) {
	    var first = 0;
	    var last = array.length - 1;

	    while (first <= last) {
	        var mid = (first + last) >> 1;
	        var c = comparator(needle, array[mid]);
	        if (c > 0)
	            first = mid + 1;
	        else if (c < 0)
	            last = mid - 1;
	        else
	            return mid;
	    }
	    return -(first + 1);
	}

	function findAnnotations(session, row, dir) {
	    var annotations = session.getAnnotations().sort(Range.comparePoints);
	    if (!annotations.length)
	        return;
	    
	    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
	    if (i < 0)
	        i = -i - 1;
	    
	    if (i >= annotations.length)
	        i = dir > 0 ? 0 : annotations.length - 1;
	    else if (i === 0 && dir < 0)
	        i = annotations.length - 1;
	    
	    var annotation = annotations[i];
	    if (!annotation || !dir)
	        return;

	    if (annotation.row === row) {
	        do {
	            annotation = annotations[i += dir];
	        } while (annotation && annotation.row === row);
	        if (!annotation)
	            return annotations.slice();
	    }
	    
	    
	    var matched = [];
	    row = annotation.row;
	    do {
	        matched[dir < 0 ? "unshift" : "push"](annotation);
	        annotation = annotations[i += dir];
	    } while (annotation && annotation.row == row);
	    return matched.length && matched;
	}

	exports.showErrorMarker = function(editor, dir) {
	    var session = editor.session;
	    if (!session.widgetManager) {
	        session.widgetManager = new LineWidgets(session);
	        session.widgetManager.attach(editor);
	    }
	    
	    var pos = editor.getCursorPosition();
	    var row = pos.row;
	    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
	        return w.type == "errorMarker";
	    })[0];
	    if (oldWidget) {
	        oldWidget.destroy();
	    } else {
	        row -= dir;
	    }
	    var annotations = findAnnotations(session, row, dir);
	    var gutterAnno;
	    if (annotations) {
	        var annotation = annotations[0];
	        pos.column = (annotation.pos && typeof annotation.column != "number"
	            ? annotation.pos.sc
	            : annotation.column) || 0;
	        pos.row = annotation.row;
	        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
	    } else if (oldWidget) {
	        return;
	    } else {
	        gutterAnno = {
	            text: ["Looks good!"],
	            className: "ace_ok"
	        };
	    }
	    editor.session.unfold(pos.row);
	    editor.selection.moveToPosition(pos);
	    
	    var w = {
	        row: pos.row, 
	        fixedWidth: true,
	        coverGutter: true,
	        el: dom.createElement("div"),
	        type: "errorMarker"
	    };
	    var el = w.el.appendChild(dom.createElement("div"));
	    var arrow = w.el.appendChild(dom.createElement("div"));
	    arrow.className = "error_widget_arrow " + gutterAnno.className;
	    
	    var left = editor.renderer.$cursorLayer
	        .getPixelPosition(pos).left;
	    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
	    
	    w.el.className = "error_widget_wrapper";
	    el.className = "error_widget " + gutterAnno.className;
	    el.innerHTML = gutterAnno.text.join("<br>");
	    
	    el.appendChild(dom.createElement("div"));
	    
	    var kb = function(_, hashId, keyString) {
	        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
	            w.destroy();
	            return {command: "null"};
	        }
	    };
	    
	    w.destroy = function() {
	        if (editor.$mouseHandler.isMousePressed)
	            return;
	        editor.keyBinding.removeKeyboardHandler(kb);
	        session.widgetManager.removeLineWidget(w);
	        editor.off("changeSelection", w.destroy);
	        editor.off("changeSession", w.destroy);
	        editor.off("mouseup", w.destroy);
	        editor.off("change", w.destroy);
	    };
	    
	    editor.keyBinding.addKeyboardHandler(kb);
	    editor.on("changeSelection", w.destroy);
	    editor.on("changeSession", w.destroy);
	    editor.on("mouseup", w.destroy);
	    editor.on("change", w.destroy);
	    
	    editor.session.widgetManager.addLineWidget(w);
	    
	    w.el.onmousedown = editor.focus.bind(editor);
	    
	    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
	};


	dom.importCssString("\
	    .error_widget_wrapper {\
	        background: inherit;\
	        color: inherit;\
	        border:none\
	    }\
	    .error_widget {\
	        border-top: solid 2px;\
	        border-bottom: solid 2px;\
	        margin: 5px 0;\
	        padding: 10px 40px;\
	        white-space: pre-wrap;\
	    }\
	    .error_widget.ace_error, .error_widget_arrow.ace_error{\
	        border-color: #ff5a5a\
	    }\
	    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
	        border-color: #F1D817\
	    }\
	    .error_widget.ace_info, .error_widget_arrow.ace_info{\
	        border-color: #5a5a5a\
	    }\
	    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
	        border-color: #5aaa5a\
	    }\
	    .error_widget_arrow {\
	        position: absolute;\
	        border: solid 5px;\
	        border-top-color: transparent!important;\
	        border-right-color: transparent!important;\
	        border-left-color: transparent!important;\
	        top: -5px;\
	    }\
	", "");

	});

	ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");

	var Editor = acequire("./editor").Editor;
	var EditSession = acequire("./edit_session").EditSession;
	var UndoManager = acequire("./undomanager").UndoManager;
	var Renderer = acequire("./virtual_renderer").VirtualRenderer;
	acequire("./worker/worker_client");
	acequire("./keyboard/hash_handler");
	acequire("./placeholder");
	acequire("./multi_select");
	acequire("./mode/folding/fold_mode");
	acequire("./theme/textmate");
	acequire("./ext/error_marker");

	exports.config = acequire("./config");
	exports.acequire = acequire;
	exports.edit = function(el) {
	    if (typeof el == "string") {
	        var _id = el;
	        el = document.getElementById(_id);
	        if (!el)
	            throw new Error("ace.edit can't find div #" + _id);
	    }

	    if (el && el.env && el.env.editor instanceof Editor)
	        return el.env.editor;

	    var value = "";
	    if (el && /input|textarea/i.test(el.tagName)) {
	        var oldNode = el;
	        value = oldNode.value;
	        el = dom.createElement("pre");
	        oldNode.parentNode.replaceChild(el, oldNode);
	    } else if (el) {
	        value = dom.getInnerText(el);
	        el.innerHTML = "";
	    }

	    var doc = exports.createEditSession(value);

	    var editor = new Editor(new Renderer(el));
	    editor.setSession(doc);

	    var env = {
	        document: doc,
	        editor: editor,
	        onResize: editor.resize.bind(editor, null)
	    };
	    if (oldNode) env.textarea = oldNode;
	    event.addListener(window, "resize", env.onResize);
	    editor.on("destroy", function() {
	        event.removeListener(window, "resize", env.onResize);
	        env.editor.container.env = null; // prevent memory leak on old ie
	    });
	    editor.container.env = editor.env = env;
	    return editor;
	};
	exports.createEditSession = function(text, mode) {
	    var doc = new EditSession(text, mode);
	    doc.setUndoManager(new UndoManager());
	    return doc;
	}
	exports.EditSession = EditSession;
	exports.UndoManager = UndoManager;
	exports.version = "1.2.3";
	});
	            (function() {
	                ace.acequire(["ace/ace"], function(a) {
	                    a && a.config.init(true);
	                    if (!window.ace)
	                        window.ace = a;
	                    for (var key in a) if (a.hasOwnProperty(key))
	                        window.ace[key] = a[key];
	                });
	            })();
	        
	module.exports = window.ace.acequire("ace/ace");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = get_blob()

	function get_blob() {
	  if(global.Blob) {
	    try {
	      new Blob(['asdf'], {type: 'text/plain'})
	      return Blob
	    } catch(err) {}
	  }

	  var Builder = global.WebKitBlobBuilder ||
	                global.MozBlobBuilder ||
	                global.MSBlobBuilder

	  return function(parts, bag) {
	    var builder = new Builder
	      , endings = bag.endings
	      , type = bag.type

	    if(endings) for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i], endings)
	    } else for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i])
	    }

	    return type ? builder.getBlob(type) : builder.getBlob()
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEqual;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(31)(module)))

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  The MIT License (MIT)

	  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	*/

	/**
	The following batches are equivalent:

	var beautify_js = require('js-beautify');
	var beautify_js = require('js-beautify').js;
	var beautify_js = require('js-beautify').js_beautify;

	var beautify_css = require('js-beautify').css;
	var beautify_css = require('js-beautify').css_beautify;

	var beautify_html = require('js-beautify').html;
	var beautify_html = require('js-beautify').html_beautify;

	All methods returned accept two arguments, the source string and an options object.
	**/

	function get_beautify(js_beautify, css_beautify, html_beautify) {
	    // the default is js
	    var beautify = function(src, config) {
	        return js_beautify.js_beautify(src, config);
	    };

	    // short aliases
	    beautify.js = js_beautify.js_beautify;
	    beautify.css = css_beautify.css_beautify;
	    beautify.html = html_beautify.html_beautify;

	    // legacy aliases
	    beautify.js_beautify = js_beautify.js_beautify;
	    beautify.css_beautify = css_beautify.css_beautify;
	    beautify.html_beautify = html_beautify.html_beautify;

	    return beautify;
	}

	if (true) {
	    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(33),
	        __webpack_require__(34),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(js_beautify, css_beautify, html_beautify) {
	        return get_beautify(js_beautify, css_beautify, html_beautify);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
	    (function(mod) {
	        var js_beautify = require('./lib/beautify');
	        var css_beautify = require('./lib/beautify-css');
	        var html_beautify = require('./lib/beautify-html');

	        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

	    })(module);
	}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	 JS Beautifier
	---------------


	  Written by Einar Lielmanis, <einar@jsbeautifier.org>
	      http://jsbeautifier.org/

	  Originally converted to javascript by Vital, <vital76@gmail.com>
	  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
	  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


	  Usage:
	    js_beautify(js_source_text);
	    js_beautify(js_source_text, options);

	  The options are:
	    indent_size (default 4)          - indentation size,
	    indent_char (default space)      - character to indent with,
	    preserve_newlines (default true) - whether existing line breaks should be preserved,
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

	    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

	            jslint_happy        !jslint_happy
	            ---------------------------------
	            function ()         function()

	            switch () {         switch() {
	            case 1:               case 1:
	              break;                break;
	            }                   }

	    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
	          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
	            preserve-inline will try to preserve inline blocks of curly braces

	    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

	    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

	    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
	          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
	                be preserved if it were present.

	    end_with_newline (default false)  - end output with a newline


	    e.g

	    js_beautify(js_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t'
	    });

	*/

	// Object.values polyfill found here:
	// http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html
	if (!Object.values) {
	    Object.values = function(o) {
	        if (o !== Object(o)) {
	            throw new TypeError('Object.values called on a non-object');
	        }
	        var k = [],
	            p;
	        for (p in o) {
	            if (Object.prototype.hasOwnProperty.call(o, p)) {
	                k.push(o[p]);
	            }
	        }
	        return k;
	    };
	}

	(function() {

	    function mergeOpts(allOptions, targetType) {
	        var finalOpts = {};
	        var name;

	        for (name in allOptions) {
	            if (name !== targetType) {
	                finalOpts[name] = allOptions[name];
	            }
	        }

	        //merge in the per type settings for the targetType
	        if (targetType in allOptions) {
	            for (name in allOptions[targetType]) {
	                finalOpts[name] = allOptions[targetType][name];
	            }
	        }
	        return finalOpts;
	    }

	    function js_beautify(js_source_text, options) {

	        var acorn = {};
	        (function(exports) {
	            /* jshint curly: false */
	            // This section of code is taken from acorn.
	            //
	            // Acorn was written by Marijn Haverbeke and released under an MIT
	            // license. The Unicode regexps (for identifiers and whitespace) were
	            // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
	            //
	            // Git repositories for Acorn are available at
	            //
	            //     http://marijnhaverbeke.nl/git/acorn
	            //     https://github.com/marijnh/acorn.git

	            // ## Character categories

	            // Big ugly regular expressions that match characters in the
	            // whitespace, identifier, and identifier-start categories. These
	            // are only applied when a character is found to actually have a
	            // code point above 128.

	            var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
	            var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	            var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
	            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	            // Whether a single character denotes a newline.

	            exports.newline = /[\n\r\u2028\u2029]/;

	            // Matches a whole line break (where CRLF is considered a single
	            // line break). Used to count lines.

	            // in javascript, these two differ
	            // in python they are the same, different methods are called on them
	            exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
	            exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


	            // Test whether a given character code starts an identifier.

	            exports.isIdentifierStart = function(code) {
	                // permit $ (36) and @ (64). @ is used in ES7 decorators.
	                if (code < 65) return code === 36 || code === 64;
	                // 65 through 91 are uppercase letters.
	                if (code < 91) return true;
	                // permit _ (95).
	                if (code < 97) return code === 95;
	                // 97 through 123 are lowercase letters.
	                if (code < 123) return true;
	                return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	            };

	            // Test whether a given character is part of an identifier.

	            exports.isIdentifierChar = function(code) {
	                if (code < 48) return code === 36;
	                if (code < 58) return true;
	                if (code < 65) return false;
	                if (code < 91) return true;
	                if (code < 97) return code === 95;
	                if (code < 123) return true;
	                return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	            };
	        })(acorn);
	        /* jshint curly: true */

	        function in_array(what, arr) {
	            for (var i = 0; i < arr.length; i += 1) {
	                if (arr[i] === what) {
	                    return true;
	                }
	            }
	            return false;
	        }

	        function trim(s) {
	            return s.replace(/^\s+|\s+$/g, '');
	        }

	        function ltrim(s) {
	            return s.replace(/^\s+/g, '');
	        }

	        // function rtrim(s) {
	        //     return s.replace(/\s+$/g, '');
	        // }

	        function sanitizeOperatorPosition(opPosition) {
	            opPosition = opPosition || OPERATOR_POSITION.before_newline;

	            var validPositionValues = Object.values(OPERATOR_POSITION);

	            if (!in_array(opPosition, validPositionValues)) {
	                throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n" +
	                    validPositionValues +
	                    "\nYou passed in: '" + opPosition + "'");
	            }

	            return opPosition;
	        }

	        var OPERATOR_POSITION = {
	            before_newline: 'before-newline',
	            after_newline: 'after-newline',
	            preserve_newline: 'preserve-newline',
	        };

	        var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

	        var MODE = {
	            BlockStatement: 'BlockStatement', // 'BLOCK'
	            Statement: 'Statement', // 'STATEMENT'
	            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	            Conditional: 'Conditional', //'(COND-EXPRESSION)',
	            Expression: 'Expression' //'(EXPRESSION)'
	        };

	        function Beautifier(js_source_text, options) {
	            "use strict";
	            var output;
	            var tokens = [],
	                token_pos;
	            var Tokenizer;
	            var current_token;
	            var last_type, last_last_text, indent_string;
	            var flags, previous_flags, flag_store;
	            var prefix;

	            var handlers, opt;
	            var baseIndentString = '';

	            handlers = {
	                'TK_START_EXPR': handle_start_expr,
	                'TK_END_EXPR': handle_end_expr,
	                'TK_START_BLOCK': handle_start_block,
	                'TK_END_BLOCK': handle_end_block,
	                'TK_WORD': handle_word,
	                'TK_RESERVED': handle_word,
	                'TK_SEMICOLON': handle_semicolon,
	                'TK_STRING': handle_string,
	                'TK_EQUALS': handle_equals,
	                'TK_OPERATOR': handle_operator,
	                'TK_COMMA': handle_comma,
	                'TK_BLOCK_COMMENT': handle_block_comment,
	                'TK_COMMENT': handle_comment,
	                'TK_DOT': handle_dot,
	                'TK_UNKNOWN': handle_unknown,
	                'TK_EOF': handle_eof
	            };

	            function create_flags(flags_base, mode) {
	                var next_indent_level = 0;
	                if (flags_base) {
	                    next_indent_level = flags_base.indentation_level;
	                    if (!output.just_added_newline() &&
	                        flags_base.line_indent_level > next_indent_level) {
	                        next_indent_level = flags_base.line_indent_level;
	                    }
	                }

	                var next_flags = {
	                    mode: mode,
	                    parent: flags_base,
	                    last_text: flags_base ? flags_base.last_text : '', // last token text
	                    last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
	                    declaration_statement: false,
	                    declaration_assignment: false,
	                    multiline_frame: false,
	                    inline_frame: false,
	                    if_block: false,
	                    else_block: false,
	                    do_block: false,
	                    do_while: false,
	                    import_block: false,
	                    in_case_statement: false, // switch(..){ INSIDE HERE }
	                    in_case: false, // we're on the exact line with "case 0:"
	                    case_body: false, // the indented case-action block
	                    indentation_level: next_indent_level,
	                    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	                    start_line_index: output.get_line_number(),
	                    ternary_depth: 0
	                };
	                return next_flags;
	            }

	            // Some interpreters have unexpected results with foo = baz || bar;
	            options = options ? options : {};

	            // Allow the setting of language/file-type specific options
	            // with inheritance of overall settings
	            options = mergeOpts(options, 'js');

	            opt = {};

	            // compatibility, re
	            if (options.brace_style === "expand-strict") { //graceful handling of deprecated option
	                options.brace_style = "expand";
	            } else if (options.brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
	                options.brace_style = "collapse,preserve-inline";
	            } else if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
	                options.brace_style = options.braces_on_own_line ? "expand" : "collapse";
	            } else if (!options.brace_style) //Nothing exists to set it
	            {
	                options.brace_style = "collapse";
	            }


	            var brace_style_split = options.brace_style.split(/[^a-zA-Z0-9_\-]+/);
	            opt.brace_style = brace_style_split[0];
	            opt.brace_preserve_inline = brace_style_split[1] ? brace_style_split[1] : false;

	            opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	            opt.indent_char = options.indent_char ? options.indent_char : ' ';
	            opt.eol = options.eol ? options.eol : 'auto';
	            opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	            opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
	            opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
	            opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
	            opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
	            opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
	            opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
	            opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
	            opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
	            opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
	            opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
	            opt.e4x = (options.e4x === undefined) ? false : options.e4x;
	            opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	            opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;
	            opt.operator_position = sanitizeOperatorPosition(options.operator_position);

	            // For testing of beautify ignore:start directive
	            opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

	            // force opt.space_after_anon_function to true if opt.jslint_happy
	            if (opt.jslint_happy) {
	                opt.space_after_anon_function = true;
	            }

	            if (options.indent_with_tabs) {
	                opt.indent_char = '\t';
	                opt.indent_size = 1;
	            }

	            if (opt.eol === 'auto') {
	                opt.eol = '\n';
	                if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {
	                    opt.eol = js_source_text.match(acorn.lineBreak)[0];
	                }
	            }

	            opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

	            //----------------------------------
	            indent_string = '';
	            while (opt.indent_size > 0) {
	                indent_string += opt.indent_char;
	                opt.indent_size -= 1;
	            }

	            var preindent_index = 0;
	            if (js_source_text && js_source_text.length) {
	                while ((js_source_text.charAt(preindent_index) === ' ' ||
	                        js_source_text.charAt(preindent_index) === '\t')) {
	                    baseIndentString += js_source_text.charAt(preindent_index);
	                    preindent_index += 1;
	                }
	                js_source_text = js_source_text.substring(preindent_index);
	            }

	            last_type = 'TK_START_BLOCK'; // last token type
	            last_last_text = ''; // pre-last token text
	            output = new Output(indent_string, baseIndentString);

	            // If testing the ignore directive, start with output disable set to true
	            output.raw = opt.test_output_raw;


	            // Stack of parsing/formatting states, including MODE.
	            // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	            // and formatted output.  This makes the beautifier less accurate than full parsers
	            // but also far more tolerant of syntax errors.
	            //
	            // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	            // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	            // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	            // most full parsers would die, but the beautifier gracefully falls back to
	            // MODE.BlockStatement and continues on.
	            flag_store = [];
	            set_mode(MODE.BlockStatement);

	            this.beautify = function() {

	                /*jshint onevar:true */
	                var sweet_code;
	                Tokenizer = new tokenizer(js_source_text, opt, indent_string);
	                tokens = Tokenizer.tokenize();
	                token_pos = 0;

	                current_token = get_token();
	                while (current_token) {
	                    handlers[current_token.type]();

	                    last_last_text = flags.last_text;
	                    last_type = current_token.type;
	                    flags.last_text = current_token.text;

	                    token_pos += 1;
	                    current_token = get_token();
	                }

	                sweet_code = output.get_code();
	                if (opt.end_with_newline) {
	                    sweet_code += '\n';
	                }

	                if (opt.eol !== '\n') {
	                    sweet_code = sweet_code.replace(/[\n]/g, opt.eol);
	                }

	                return sweet_code;
	            };

	            function handle_whitespace_and_comments(local_token, preserve_statement_flags) {
	                var newlines = local_token.newlines;
	                var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
	                var temp_token = current_token;

	                for (var h = 0; h < local_token.comments_before.length; h++) {
	                    // The cleanest handling of inline comments is to treat them as though they aren't there.
	                    // Just continue formatting and the behavior should be logical.
	                    // Also ignore unknown tokens.  Again, this should result in better behavior.
	                    current_token = local_token.comments_before[h];
	                    handle_whitespace_and_comments(current_token, preserve_statement_flags);
	                    handlers[current_token.type](preserve_statement_flags);
	                }
	                current_token = temp_token;

	                if (keep_whitespace) {
	                    for (var i = 0; i < newlines; i += 1) {
	                        print_newline(i > 0, preserve_statement_flags);
	                    }
	                } else {
	                    if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
	                        newlines = opt.max_preserve_newlines;
	                    }

	                    if (opt.preserve_newlines) {
	                        if (local_token.newlines > 1) {
	                            print_newline(false, preserve_statement_flags);
	                            for (var j = 1; j < newlines; j += 1) {
	                                print_newline(true, preserve_statement_flags);
	                            }
	                        }
	                    }
	                }

	            }

	            // we could use just string.split, but
	            // IE doesn't like returning empty strings
	            function split_linebreaks(s) {
	                //return s.split(/\x0d\x0a|\x0a/);

	                s = s.replace(acorn.allLineBreaks, '\n');
	                var out = [],
	                    idx = s.indexOf("\n");
	                while (idx !== -1) {
	                    out.push(s.substring(0, idx));
	                    s = s.substring(idx + 1);
	                    idx = s.indexOf("\n");
	                }
	                if (s.length) {
	                    out.push(s);
	                }
	                return out;
	            }

	            var newline_restricted_tokens = ['break', 'continue', 'return', 'throw'];

	            function allow_wrap_or_preserved_newline(force_linewrap) {
	                force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

	                // Never wrap the first token on a line
	                if (output.just_added_newline()) {
	                    return;
	                }

	                var shouldPreserveOrForce = (opt.preserve_newlines && current_token.wanted_newline) || force_linewrap;
	                var operatorLogicApplies = in_array(flags.last_text, Tokenizer.positionable_operators) || in_array(current_token.text, Tokenizer.positionable_operators);

	                if (operatorLogicApplies) {
	                    var shouldPrintOperatorNewline = (
	                            in_array(flags.last_text, Tokenizer.positionable_operators) &&
	                            in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
	                        ) ||
	                        in_array(current_token.text, Tokenizer.positionable_operators);
	                    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
	                }

	                if (shouldPreserveOrForce) {
	                    print_newline(false, true);
	                } else if (opt.wrap_line_length) {
	                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {
	                        // These tokens should never have a newline inserted
	                        // between them and the following expression.
	                        return;
	                    }
	                    var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
	                        (output.space_before_token ? 1 : 0);
	                    if (proposed_line_length >= opt.wrap_line_length) {
	                        print_newline(false, true);
	                    }
	                }
	            }

	            function print_newline(force_newline, preserve_statement_flags) {
	                if (!preserve_statement_flags) {
	                    if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
	                        var next_token = get_token(1);
	                        while (flags.mode === MODE.Statement &&
	                            !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
	                            !flags.do_block) {
	                            restore_mode();
	                        }
	                    }
	                }

	                if (output.add_new_line(force_newline)) {
	                    flags.multiline_frame = true;
	                }
	            }

	            function print_token_line_indentation() {
	                if (output.just_added_newline()) {
	                    if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
	                        output.current_line.push(current_token.whitespace_before);
	                        output.space_before_token = false;
	                    } else if (output.set_indent(flags.indentation_level)) {
	                        flags.line_indent_level = flags.indentation_level;
	                    }
	                }
	            }

	            function print_token(printable_token) {
	                if (output.raw) {
	                    output.add_raw_token(current_token);
	                    return;
	                }

	                if (opt.comma_first && last_type === 'TK_COMMA' &&
	                    output.just_added_newline()) {
	                    if (output.previous_line.last() === ',') {
	                        var popped = output.previous_line.pop();
	                        // if the comma was already at the start of the line,
	                        // pull back onto that line and reprint the indentation
	                        if (output.previous_line.is_empty()) {
	                            output.previous_line.push(popped);
	                            output.trim(true);
	                            output.current_line.pop();
	                            output.trim();
	                        }

	                        // add the comma in front of the next token
	                        print_token_line_indentation();
	                        output.add_token(',');
	                        output.space_before_token = true;
	                    }
	                }

	                printable_token = printable_token || current_token.text;
	                print_token_line_indentation();
	                output.add_token(printable_token);
	            }

	            function indent() {
	                flags.indentation_level += 1;
	            }

	            function deindent() {
	                if (flags.indentation_level > 0 &&
	                    ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level)) {
	                    flags.indentation_level -= 1;

	                }
	            }

	            function set_mode(mode) {
	                if (flags) {
	                    flag_store.push(flags);
	                    previous_flags = flags;
	                } else {
	                    previous_flags = create_flags(null, mode);
	                }

	                flags = create_flags(previous_flags, mode);
	            }

	            function is_array(mode) {
	                return mode === MODE.ArrayLiteral;
	            }

	            function is_expression(mode) {
	                return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	            }

	            function restore_mode() {
	                if (flag_store.length > 0) {
	                    previous_flags = flags;
	                    flags = flag_store.pop();
	                    if (previous_flags.mode === MODE.Statement) {
	                        output.remove_redundant_indentation(previous_flags);
	                    }
	                }
	            }

	            function start_of_object_property() {
	                return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
	                    (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
	            }

	            function start_of_statement() {
	                if (
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
	                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw']) && !current_token.wanted_newline) ||
	                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' &&
	                        !(current_token.type === 'TK_RESERVED' && current_token.text === 'if' && !current_token.comments_before.length)) ||
	                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
	                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement &&
	                        !flags.in_case &&
	                        !(current_token.text === '--' || current_token.text === '++') &&
	                        last_last_text !== 'function' &&
	                        current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
	                    (flags.mode === MODE.ObjectLiteral && (
	                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
	                ) {

	                    set_mode(MODE.Statement);
	                    indent();

	                    handle_whitespace_and_comments(current_token, true);

	                    // Issue #276:
	                    // If starting a new statement with [if, for, while, do], push to a new line.
	                    // if (a) if (b) if(c) d(); else e(); else f();
	                    if (!start_of_object_property()) {
	                        allow_wrap_or_preserved_newline(
	                            current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
	                    }

	                    return true;
	                }
	                return false;
	            }

	            function all_lines_start_with(lines, c) {
	                for (var i = 0; i < lines.length; i++) {
	                    var line = trim(lines[i]);
	                    if (line.charAt(0) !== c) {
	                        return false;
	                    }
	                }
	                return true;
	            }

	            function each_line_matches_indent(lines, indent) {
	                var i = 0,
	                    len = lines.length,
	                    line;
	                for (; i < len; i++) {
	                    line = lines[i];
	                    // allow empty lines to pass through
	                    if (line && line.indexOf(indent) !== 0) {
	                        return false;
	                    }
	                }
	                return true;
	            }

	            function is_special_word(word) {
	                return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
	            }

	            function get_token(offset) {
	                var index = token_pos + (offset || 0);
	                return (index < 0 || index >= tokens.length) ? null : tokens[index];
	            }

	            function handle_start_expr() {
	                // The conditional starts the statement if appropriate.
	                if (!start_of_statement()) {
	                    handle_whitespace_and_comments(current_token);
	                }

	                var next_mode = MODE.Expression;
	                if (current_token.text === '[') {

	                    if (last_type === 'TK_WORD' || flags.last_text === ')') {
	                        // this is array index specifier, break immediately
	                        // a[x], fn()[x]
	                        if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {
	                            output.space_before_token = true;
	                        }
	                        set_mode(next_mode);
	                        print_token();
	                        indent();
	                        if (opt.space_in_paren) {
	                            output.space_before_token = true;
	                        }
	                        return;
	                    }

	                    next_mode = MODE.ArrayLiteral;
	                    if (is_array(flags.mode)) {
	                        if (flags.last_text === '[' ||
	                            (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
	                            // ], [ goes to new line
	                            // }, [ goes to new line
	                            if (!opt.keep_array_indentation) {
	                                print_newline();
	                            }
	                        }
	                    }

	                } else {
	                    if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
	                        next_mode = MODE.ForInitializer;
	                    } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
	                        next_mode = MODE.Conditional;
	                    } else {
	                        // next_mode = MODE.Expression;
	                    }
	                }

	                if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
	                    print_newline();
	                } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
	                    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	                    allow_wrap_or_preserved_newline(current_token.wanted_newline);
	                    // do nothing on (( and )( and ][ and ]( and .(
	                } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
	                    output.space_before_token = true;
	                } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
	                    (flags.last_text === '*' &&
	                        (in_array(last_last_text, ['function', 'yield']) ||
	                            (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
	                    // function() vs function ()
	                    // yield*() vs yield* ()
	                    // function*() vs function* ()
	                    if (opt.space_after_anon_function) {
	                        output.space_before_token = true;
	                    }
	                } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {
	                    if (opt.space_before_conditional) {
	                        output.space_before_token = true;
	                    }
	                }

	                // Should be a space between await and an IIFE
	                if (current_token.text === '(' && last_type === 'TK_RESERVED' && flags.last_word === 'await') {
	                    output.space_before_token = true;
	                }

	                // Support of this kind of newline preservation.
	                // a = (b &&
	                //     (c || d));
	                if (current_token.text === '(') {
	                    if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                        if (!start_of_object_property()) {
	                            allow_wrap_or_preserved_newline();
	                        }
	                    }
	                }

	                // Support preserving wrapped arrow function expressions
	                // a.b('c',
	                //     () => d.e
	                // )
	                if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {
	                    allow_wrap_or_preserved_newline();
	                }

	                set_mode(next_mode);
	                print_token();
	                if (opt.space_in_paren) {
	                    output.space_before_token = true;
	                }

	                // In all cases, if we newline while inside an expression it should be indented.
	                indent();
	            }

	            function handle_end_expr() {
	                // statements inside expressions are not valid syntax, but...
	                // statements must all be closed when their container closes
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }

	                handle_whitespace_and_comments(current_token);

	                if (flags.multiline_frame) {
	                    allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
	                }

	                if (opt.space_in_paren) {
	                    if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {
	                        // () [] no inner space in empty parens like these, ever, ref #320
	                        output.trim();
	                        output.space_before_token = false;
	                    } else {
	                        output.space_before_token = true;
	                    }
	                }
	                if (current_token.text === ']' && opt.keep_array_indentation) {
	                    print_token();
	                    restore_mode();
	                } else {
	                    restore_mode();
	                    print_token();
	                }
	                output.remove_redundant_indentation(previous_flags);

	                // do {} while () // no statement required after
	                if (flags.do_while && previous_flags.mode === MODE.Conditional) {
	                    previous_flags.mode = MODE.Expression;
	                    flags.do_block = false;
	                    flags.do_while = false;

	                }
	            }

	            function handle_start_block() {
	                handle_whitespace_and_comments(current_token);

	                // Check if this is should be treated as a ObjectLiteral
	                var next_token = get_token(1);
	                var second_token = get_token(2);
	                if (second_token && (
	                        (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED'])) ||
	                        (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
	                    )) {
	                    // We don't support TypeScript,but we didn't break it for a very long time.
	                    // We'll try to keep not breaking it.
	                    if (!in_array(last_last_text, ['class', 'interface'])) {
	                        set_mode(MODE.ObjectLiteral);
	                    } else {
	                        set_mode(MODE.BlockStatement);
	                    }
	                } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {
	                    // arrow function: (param1, paramN) => { statements }
	                    set_mode(MODE.BlockStatement);
	                } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import', 'default']))
	                ) {
	                    // Detecting shorthand function syntax is difficult by scanning forward,
	                    //     so check the surrounding context.
	                    // If the block is being returned, imported, export default, passed as arg,
	                    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
	                    set_mode(MODE.ObjectLiteral);
	                } else {
	                    set_mode(MODE.BlockStatement);
	                }

	                var empty_braces = !next_token.comments_before.length && next_token.text === '}';
	                var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
	                    last_type === 'TK_END_EXPR';

	                if (opt.brace_preserve_inline) // check for inline, set inline_frame if so
	                {
	                    // search forward for a newline wanted inside this block
	                    var index = 0;
	                    var check_token = null;
	                    flags.inline_frame = true;
	                    do {
	                        index += 1;
	                        check_token = get_token(index);
	                        if (check_token.wanted_newline) {
	                            flags.inline_frame = false;
	                            break;
	                        }
	                    } while (check_token.type !== 'TK_EOF' &&
	                        !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token));
	                }

	                if ((opt.brace_style === "expand" ||
	                        (opt.brace_style === "none" && current_token.wanted_newline)) &&
	                    !flags.inline_frame) {
	                    if (last_type !== 'TK_OPERATOR' &&
	                        (empty_anonymous_function ||
	                            last_type === 'TK_EQUALS' ||
	                            (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
	                        output.space_before_token = true;
	                    } else {
	                        print_newline(false, true);
	                    }
	                } else { // collapse || inline_frame
	                    if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {
	                        if (last_type === 'TK_COMMA' || opt.space_in_paren) {
	                            output.space_before_token = true;
	                        }

	                        if (last_type === 'TK_COMMA' || (last_type === 'TK_START_EXPR' && flags.inline_frame)) {
	                            allow_wrap_or_preserved_newline();
	                            previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;
	                            flags.multiline_frame = false;
	                        }
	                    }
	                    if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
	                        if (last_type === 'TK_START_BLOCK' && !flags.inline_frame) {
	                            print_newline();
	                        } else {
	                            output.space_before_token = true;
	                        }
	                    }
	                }
	                print_token();
	                indent();
	            }

	            function handle_end_block() {
	                // statements must all be closed when their container closes
	                handle_whitespace_and_comments(current_token);

	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }

	                var empty_braces = last_type === 'TK_START_BLOCK';

	                if (flags.inline_frame && !empty_braces) { // try inline_frame (only set if opt.braces-preserve-inline) first
	                    output.space_before_token = true;
	                } else if (opt.brace_style === "expand") {
	                    if (!empty_braces) {
	                        print_newline();
	                    }
	                } else {
	                    // skip {}
	                    if (!empty_braces) {
	                        if (is_array(flags.mode) && opt.keep_array_indentation) {
	                            // we REALLY need a newline here, but newliner would skip that
	                            opt.keep_array_indentation = false;
	                            print_newline();
	                            opt.keep_array_indentation = true;

	                        } else {
	                            print_newline();
	                        }
	                    }
	                }
	                restore_mode();
	                print_token();
	            }

	            function handle_word() {
	                if (current_token.type === 'TK_RESERVED') {
	                    if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {
	                        current_token.type = 'TK_WORD';
	                    } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {
	                        current_token.type = 'TK_WORD';
	                    } else if (flags.mode === MODE.ObjectLiteral) {
	                        var next_token = get_token(1);
	                        if (next_token.text === ':') {
	                            current_token.type = 'TK_WORD';
	                        }
	                    }
	                }

	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
	                        flags.declaration_statement = true;
	                    }
	                } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
	                    (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
	                    last_type !== 'TK_EQUALS' &&
	                    (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {
	                    handle_whitespace_and_comments(current_token);
	                    print_newline();
	                } else {
	                    handle_whitespace_and_comments(current_token);
	                }

	                if (flags.do_block && !flags.do_while) {
	                    if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
	                        // do {} ## while ()
	                        output.space_before_token = true;
	                        print_token();
	                        output.space_before_token = true;
	                        flags.do_while = true;
	                        return;
	                    } else {
	                        // do {} should always have while as the next word.
	                        // if we don't see the expected while, recover
	                        print_newline();
	                        flags.do_block = false;
	                    }
	                }

	                // if may be followed by else, or not
	                // Bare/inline ifs are tricky
	                // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	                if (flags.if_block) {
	                    if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
	                        flags.else_block = true;
	                    } else {
	                        while (flags.mode === MODE.Statement) {
	                            restore_mode();
	                        }
	                        flags.if_block = false;
	                        flags.else_block = false;
	                    }
	                }

	                if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
	                    print_newline();
	                    if (flags.case_body || opt.jslint_happy) {
	                        // switch cases following one another
	                        deindent();
	                        flags.case_body = false;
	                    }
	                    print_token();
	                    flags.in_case = true;
	                    flags.in_case_statement = true;
	                    return;
	                }

	                if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                    if (!start_of_object_property()) {
	                        allow_wrap_or_preserved_newline();
	                    }
	                }

	                if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
	                    if (in_array(flags.last_text, ['}', ';']) ||
	                        (output.just_added_newline() && !(in_array(flags.last_text, ['(', '[', '{', ':', '=', ',']) || last_type === 'TK_OPERATOR'))) {
	                        // make sure there is a nice clean space of at least one blank line
	                        // before a new function definition
	                        if (!output.just_added_blankline() && !current_token.comments_before.length) {
	                            print_newline();
	                            print_newline(true);
	                        }
	                    }
	                    if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                        if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export', 'async'])) {
	                            output.space_before_token = true;
	                        } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
	                            output.space_before_token = true;
	                        } else {
	                            print_newline();
	                        }
	                    } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
	                        // foo = function
	                        output.space_before_token = true;
	                    } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
	                        // (function
	                    } else {
	                        print_newline();
	                    }

	                    print_token();
	                    flags.last_word = current_token.text;
	                    return;
	                }

	                prefix = 'NONE';

	                if (last_type === 'TK_END_BLOCK') {

	                    if (previous_flags.inline_frame) {
	                        prefix = 'SPACE';
	                    } else if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {
	                        prefix = 'NEWLINE';
	                    } else {
	                        if (opt.brace_style === "expand" ||
	                            opt.brace_style === "end-expand" ||
	                            (opt.brace_style === "none" && current_token.wanted_newline)) {
	                            prefix = 'NEWLINE';
	                        } else {
	                            prefix = 'SPACE';
	                            output.space_before_token = true;
	                        }
	                    }
	                } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
	                    // TODO: Should this be for STATEMENT as well?
	                    prefix = 'NEWLINE';
	                } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
	                    prefix = 'SPACE';
	                } else if (last_type === 'TK_STRING') {
	                    prefix = 'NEWLINE';
	                } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
	                    (flags.last_text === '*' &&
	                        (in_array(last_last_text, ['function', 'yield']) ||
	                            (flags.mode === MODE.ObjectLiteral && in_array(last_last_text, ['{', ',']))))) {
	                    prefix = 'SPACE';
	                } else if (last_type === 'TK_START_BLOCK') {
	                    if (flags.inline_frame) {
	                        prefix = 'SPACE';
	                    } else {
	                        prefix = 'NEWLINE';
	                    }
	                } else if (last_type === 'TK_END_EXPR') {
	                    output.space_before_token = true;
	                    prefix = 'NEWLINE';
	                }

	                if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
	                    if (flags.inline_frame || flags.last_text === 'else' || flags.last_text === 'export') {
	                        prefix = 'SPACE';
	                    } else {
	                        prefix = 'NEWLINE';
	                    }

	                }

	                if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
	                    if ((!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||
	                            opt.brace_style === "expand" ||
	                            opt.brace_style === "end-expand" ||
	                            (opt.brace_style === "none" && current_token.wanted_newline)) &&
	                        !flags.inline_frame) {
	                        print_newline();
	                    } else {
	                        output.trim(true);
	                        var line = output.current_line;
	                        // If we trimmed and there's something other than a close block before us
	                        // put a newline back in.  Handles '} // comment' scenario.
	                        if (line.last() !== '}') {
	                            print_newline();
	                        }
	                        output.space_before_token = true;
	                    }
	                } else if (prefix === 'NEWLINE') {
	                    if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                        // no newline between 'return nnn'
	                        output.space_before_token = true;
	                    } else if (last_type !== 'TK_END_EXPR') {
	                        if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
	                            // no need to force newline on 'var': for (var x = 0...)
	                            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
	                                // no newline for } else if {
	                                output.space_before_token = true;
	                            } else {
	                                print_newline();
	                            }
	                        }
	                    } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
	                        print_newline();
	                    }
	                } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
	                    print_newline(); // }, in lists get a newline treatment
	                } else if (prefix === 'SPACE') {
	                    output.space_before_token = true;
	                }
	                print_token();
	                flags.last_word = current_token.text;

	                if (current_token.type === 'TK_RESERVED') {
	                    if (current_token.text === 'do') {
	                        flags.do_block = true;
	                    } else if (current_token.text === 'if') {
	                        flags.if_block = true;
	                    } else if (current_token.text === 'import') {
	                        flags.import_block = true;
	                    } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {
	                        flags.import_block = false;
	                    }
	                }
	            }

	            function handle_semicolon() {
	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                    // Semicolon can be the start (and end) of a statement
	                    output.space_before_token = false;
	                } else {
	                    handle_whitespace_and_comments(current_token);
	                }

	                var next_token = get_token(1);
	                while (flags.mode === MODE.Statement &&
	                    !(flags.if_block && next_token && next_token.type === 'TK_RESERVED' && next_token.text === 'else') &&
	                    !flags.do_block) {
	                    restore_mode();
	                }

	                // hacky but effective for the moment
	                if (flags.import_block) {
	                    flags.import_block = false;
	                }
	                print_token();
	            }

	            function handle_string() {
	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                    // One difference - strings want at least a space before
	                    output.space_before_token = true;
	                } else {
	                    handle_whitespace_and_comments(current_token);
	                    if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {
	                        output.space_before_token = true;
	                    } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                        if (!start_of_object_property()) {
	                            allow_wrap_or_preserved_newline();
	                        }
	                    } else {
	                        print_newline();
	                    }
	                }
	                print_token();
	            }

	            function handle_equals() {
	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                } else {
	                    handle_whitespace_and_comments(current_token);
	                }

	                if (flags.declaration_statement) {
	                    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	                    flags.declaration_assignment = true;
	                }
	                output.space_before_token = true;
	                print_token();
	                output.space_before_token = true;
	            }

	            function handle_comma() {
	                handle_whitespace_and_comments(current_token, true);

	                print_token();
	                output.space_before_token = true;
	                if (flags.declaration_statement) {
	                    if (is_expression(flags.parent.mode)) {
	                        // do not break on comma, for(var a = 1, b = 2)
	                        flags.declaration_assignment = false;
	                    }

	                    if (flags.declaration_assignment) {
	                        flags.declaration_assignment = false;
	                        print_newline(false, true);
	                    } else if (opt.comma_first) {
	                        // for comma-first, we want to allow a newline before the comma
	                        // to turn into a newline after the comma, which we will fixup later
	                        allow_wrap_or_preserved_newline();
	                    }
	                } else if (flags.mode === MODE.ObjectLiteral ||
	                    (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
	                    if (flags.mode === MODE.Statement) {
	                        restore_mode();
	                    }

	                    if (!flags.inline_frame) {
	                        print_newline();
	                    }
	                } else if (opt.comma_first) {
	                    // EXPR or DO_BLOCK
	                    // for comma-first, we want to allow a newline before the comma
	                    // to turn into a newline after the comma, which we will fixup later
	                    allow_wrap_or_preserved_newline();
	                }
	            }

	            function handle_operator() {
	                var isGeneratorAsterisk = current_token.text === '*' &&
	                    ((last_type === 'TK_RESERVED' && in_array(flags.last_text, ['function', 'yield'])) ||
	                        (in_array(last_type, ['TK_START_BLOCK', 'TK_COMMA', 'TK_END_BLOCK', 'TK_SEMICOLON']))
	                    );
	                var isUnary = in_array(current_token.text, ['-', '+']) && (
	                    in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) ||
	                    in_array(flags.last_text, Tokenizer.line_starters) ||
	                    flags.last_text === ','
	                );

	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                } else {
	                    var preserve_statement_flags = !isGeneratorAsterisk;
	                    handle_whitespace_and_comments(current_token, preserve_statement_flags);
	                }

	                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                    // "return" had a special handling in TK_WORD. Now we need to return the favor
	                    output.space_before_token = true;
	                    print_token();
	                    return;
	                }

	                // hack for actionscript's import .*;
	                if (current_token.text === '*' && last_type === 'TK_DOT') {
	                    print_token();
	                    return;
	                }

	                if (current_token.text === '::') {
	                    // no spaces around exotic namespacing syntax operator
	                    print_token();
	                    return;
	                }

	                // Allow line wrapping between operators when operator_position is
	                //   set to before or preserve
	                if (last_type === 'TK_OPERATOR' && in_array(opt.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
	                    allow_wrap_or_preserved_newline();
	                }

	                if (current_token.text === ':' && flags.in_case) {
	                    flags.case_body = true;
	                    indent();
	                    print_token();
	                    print_newline();
	                    flags.in_case = false;
	                    return;
	                }

	                var space_before = true;
	                var space_after = true;
	                var in_ternary = false;
	                if (current_token.text === ':') {
	                    if (flags.ternary_depth === 0) {
	                        // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
	                        space_before = false;
	                    } else {
	                        flags.ternary_depth -= 1;
	                        in_ternary = true;
	                    }
	                } else if (current_token.text === '?') {
	                    flags.ternary_depth += 1;
	                }

	                // let's handle the operator_position option prior to any conflicting logic
	                if (!isUnary && !isGeneratorAsterisk && opt.preserve_newlines && in_array(current_token.text, Tokenizer.positionable_operators)) {
	                    var isColon = current_token.text === ':';
	                    var isTernaryColon = (isColon && in_ternary);
	                    var isOtherColon = (isColon && !in_ternary);

	                    switch (opt.operator_position) {
	                        case OPERATOR_POSITION.before_newline:
	                            // if the current token is : and it's not a ternary statement then we set space_before to false
	                            output.space_before_token = !isOtherColon;

	                            print_token();

	                            if (!isColon || isTernaryColon) {
	                                allow_wrap_or_preserved_newline();
	                            }

	                            output.space_before_token = true;
	                            return;

	                        case OPERATOR_POSITION.after_newline:
	                            // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
	                            //   then print a newline.

	                            output.space_before_token = true;

	                            if (!isColon || isTernaryColon) {
	                                if (get_token(1).wanted_newline) {
	                                    print_newline(false, true);
	                                } else {
	                                    allow_wrap_or_preserved_newline();
	                                }
	                            } else {
	                                output.space_before_token = false;
	                            }

	                            print_token();

	                            output.space_before_token = true;
	                            return;

	                        case OPERATOR_POSITION.preserve_newline:
	                            if (!isOtherColon) {
	                                allow_wrap_or_preserved_newline();
	                            }

	                            // if we just added a newline, or the current token is : and it's not a ternary statement,
	                            //   then we set space_before to false
	                            space_before = !(output.just_added_newline() || isOtherColon);

	                            output.space_before_token = space_before;
	                            print_token();
	                            output.space_before_token = true;
	                            return;
	                    }
	                }

	                if (isGeneratorAsterisk) {
	                    allow_wrap_or_preserved_newline();
	                    space_before = false;
	                    var next_token = get_token(1);
	                    space_after = next_token && in_array(next_token.type, ['TK_WORD', 'TK_RESERVED']);
	                } else if (current_token.text === '...') {
	                    allow_wrap_or_preserved_newline();
	                    space_before = last_type === 'TK_START_BLOCK';
	                    space_after = false;
	                } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
	                    // unary operators (and binary +/- pretending to be unary) special cases

	                    space_before = false;
	                    space_after = false;

	                    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	                    // if there is a newline between -- or ++ and anything else we should preserve it.
	                    if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
	                        print_newline(false, true);
	                    }

	                    if (flags.last_text === ';' && is_expression(flags.mode)) {
	                        // for (;; ++i)
	                        //        ^^^
	                        space_before = true;
	                    }

	                    if (last_type === 'TK_RESERVED') {
	                        space_before = true;
	                    } else if (last_type === 'TK_END_EXPR') {
	                        space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
	                    } else if (last_type === 'TK_OPERATOR') {
	                        // a++ + ++b;
	                        // a - -b
	                        space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
	                        // + and - are not unary when preceeded by -- or ++ operator
	                        // a-- + b
	                        // a * +b
	                        // a - -b
	                        if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
	                            space_after = true;
	                        }
	                    }


	                    if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement) &&
	                        (flags.last_text === '{' || flags.last_text === ';')) {
	                        // { foo; --i }
	                        // foo(); --bar;
	                        print_newline();
	                    }
	                }

	                output.space_before_token = output.space_before_token || space_before;
	                print_token();
	                output.space_before_token = space_after;
	            }

	            function handle_block_comment(preserve_statement_flags) {
	                if (output.raw) {
	                    output.add_raw_token(current_token);
	                    if (current_token.directives && current_token.directives.preserve === 'end') {
	                        // If we're testing the raw output behavior, do not allow a directive to turn it off.
	                        output.raw = opt.test_output_raw;
	                    }
	                    return;
	                }

	                if (current_token.directives) {
	                    print_newline(false, preserve_statement_flags);
	                    print_token();
	                    if (current_token.directives.preserve === 'start') {
	                        output.raw = true;
	                    }
	                    print_newline(false, true);
	                    return;
	                }

	                // inline block
	                if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
	                    output.space_before_token = true;
	                    print_token();
	                    output.space_before_token = true;
	                    return;
	                }

	                var lines = split_linebreaks(current_token.text);
	                var j; // iterator for this case
	                var javadoc = false;
	                var starless = false;
	                var lastIndent = current_token.whitespace_before;
	                var lastIndentLength = lastIndent.length;

	                // block comment starts with a new line
	                print_newline(false, preserve_statement_flags);
	                if (lines.length > 1) {
	                    javadoc = all_lines_start_with(lines.slice(1), '*');
	                    starless = each_line_matches_indent(lines.slice(1), lastIndent);
	                }

	                // first line always indented
	                print_token(lines[0]);
	                for (j = 1; j < lines.length; j++) {
	                    print_newline(false, true);
	                    if (javadoc) {
	                        // javadoc: reformat and re-indent
	                        print_token(' ' + ltrim(lines[j]));
	                    } else if (starless && lines[j].length > lastIndentLength) {
	                        // starless: re-indent non-empty content, avoiding trim
	                        print_token(lines[j].substring(lastIndentLength));
	                    } else {
	                        // normal comments output raw
	                        output.add_token(lines[j]);
	                    }
	                }

	                // for comments of more than one line, make sure there's a new line after
	                print_newline(false, preserve_statement_flags);
	            }

	            function handle_comment(preserve_statement_flags) {
	                if (current_token.wanted_newline) {
	                    print_newline(false, preserve_statement_flags);
	                } else {
	                    output.trim(true);
	                }

	                output.space_before_token = true;
	                print_token();
	                print_newline(false, preserve_statement_flags);
	            }

	            function handle_dot() {
	                if (start_of_statement()) {
	                    // The conditional starts the statement if appropriate.
	                } else {
	                    handle_whitespace_and_comments(current_token, true);
	                }

	                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                    output.space_before_token = true;
	                } else {
	                    // allow preserved newlines before dots in general
	                    // force newlines on dots after close paren when break_chained - for bar().baz()
	                    allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
	                }

	                print_token();
	            }

	            function handle_unknown(preserve_statement_flags) {
	                print_token();

	                if (current_token.text[current_token.text.length - 1] === '\n') {
	                    print_newline(false, preserve_statement_flags);
	                }
	            }

	            function handle_eof() {
	                // Unwind any open statements
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                handle_whitespace_and_comments(current_token);
	            }
	        }


	        function OutputLine(parent) {
	            var _character_count = 0;
	            // use indent_count as a marker for lines that have preserved indentation
	            var _indent_count = -1;

	            var _items = [];
	            var _empty = true;

	            this.set_indent = function(level) {
	                _character_count = parent.baseIndentLength + level * parent.indent_length;
	                _indent_count = level;
	            };

	            this.get_character_count = function() {
	                return _character_count;
	            };

	            this.is_empty = function() {
	                return _empty;
	            };

	            this.last = function() {
	                if (!this._empty) {
	                    return _items[_items.length - 1];
	                } else {
	                    return null;
	                }
	            };

	            this.push = function(input) {
	                _items.push(input);
	                _character_count += input.length;
	                _empty = false;
	            };

	            this.pop = function() {
	                var item = null;
	                if (!_empty) {
	                    item = _items.pop();
	                    _character_count -= item.length;
	                    _empty = _items.length === 0;
	                }
	                return item;
	            };

	            this.remove_indent = function() {
	                if (_indent_count > 0) {
	                    _indent_count -= 1;
	                    _character_count -= parent.indent_length;
	                }
	            };

	            this.trim = function() {
	                while (this.last() === ' ') {
	                    _items.pop();
	                    _character_count -= 1;
	                }
	                _empty = _items.length === 0;
	            };

	            this.toString = function() {
	                var result = '';
	                if (!this._empty) {
	                    if (_indent_count >= 0) {
	                        result = parent.indent_cache[_indent_count];
	                    }
	                    result += _items.join('');
	                }
	                return result;
	            };
	        }

	        function Output(indent_string, baseIndentString) {
	            baseIndentString = baseIndentString || '';
	            this.indent_cache = [baseIndentString];
	            this.baseIndentLength = baseIndentString.length;
	            this.indent_length = indent_string.length;
	            this.raw = false;

	            var lines = [];
	            this.baseIndentString = baseIndentString;
	            this.indent_string = indent_string;
	            this.previous_line = null;
	            this.current_line = null;
	            this.space_before_token = false;

	            this.add_outputline = function() {
	                this.previous_line = this.current_line;
	                this.current_line = new OutputLine(this);
	                lines.push(this.current_line);
	            };

	            // initialize
	            this.add_outputline();


	            this.get_line_number = function() {
	                return lines.length;
	            };

	            // Using object instead of string to allow for later expansion of info about each line
	            this.add_new_line = function(force_newline) {
	                if (this.get_line_number() === 1 && this.just_added_newline()) {
	                    return false; // no newline on start of file
	                }

	                if (force_newline || !this.just_added_newline()) {
	                    if (!this.raw) {
	                        this.add_outputline();
	                    }
	                    return true;
	                }

	                return false;
	            };

	            this.get_code = function() {
	                var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');
	                return sweet_code;
	            };

	            this.set_indent = function(level) {
	                // Never indent your first output indent at the start of the file
	                if (lines.length > 1) {
	                    while (level >= this.indent_cache.length) {
	                        this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
	                    }

	                    this.current_line.set_indent(level);
	                    return true;
	                }
	                this.current_line.set_indent(0);
	                return false;
	            };

	            this.add_raw_token = function(token) {
	                for (var x = 0; x < token.newlines; x++) {
	                    this.add_outputline();
	                }
	                this.current_line.push(token.whitespace_before);
	                this.current_line.push(token.text);
	                this.space_before_token = false;
	            };

	            this.add_token = function(printable_token) {
	                this.add_space_before_token();
	                this.current_line.push(printable_token);
	            };

	            this.add_space_before_token = function() {
	                if (this.space_before_token && !this.just_added_newline()) {
	                    this.current_line.push(' ');
	                }
	                this.space_before_token = false;
	            };

	            this.remove_redundant_indentation = function(frame) {
	                // This implementation is effective but has some issues:
	                //     - can cause line wrap to happen too soon due to indent removal
	                //           after wrap points are calculated
	                // These issues are minor compared to ugly indentation.

	                if (frame.multiline_frame ||
	                    frame.mode === MODE.ForInitializer ||
	                    frame.mode === MODE.Conditional) {
	                    return;
	                }

	                // remove one indent from each line inside this section
	                var index = frame.start_line_index;

	                var output_length = lines.length;
	                while (index < output_length) {
	                    lines[index].remove_indent();
	                    index++;
	                }
	            };

	            this.trim = function(eat_newlines) {
	                eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

	                this.current_line.trim(indent_string, baseIndentString);

	                while (eat_newlines && lines.length > 1 &&
	                    this.current_line.is_empty()) {
	                    lines.pop();
	                    this.current_line = lines[lines.length - 1];
	                    this.current_line.trim();
	                }

	                this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
	            };

	            this.just_added_newline = function() {
	                return this.current_line.is_empty();
	            };

	            this.just_added_blankline = function() {
	                if (this.just_added_newline()) {
	                    if (lines.length === 1) {
	                        return true; // start of the file and newline = blank
	                    }

	                    var line = lines[lines.length - 2];
	                    return line.is_empty();
	                }
	                return false;
	            };
	        }

	        var InputScanner = function(input) {
	            var _input = input;
	            var _input_length = _input.length;
	            var _position = 0;

	            this.back = function() {
	                _position -= 1;
	            };

	            this.hasNext = function() {
	                return _position < _input_length;
	            };

	            this.next = function() {
	                var val = null;
	                if (this.hasNext()) {
	                    val = _input.charAt(_position);
	                    _position += 1;
	                }
	                return val;
	            };

	            this.peek = function(index) {
	                var val = null;
	                index = index || 0;
	                index += _position;
	                if (index >= 0 && index < _input_length) {
	                    val = _input.charAt(index);
	                }
	                return val;
	            };

	            this.peekCharCode = function(index) {
	                var val = 0;
	                index = index || 0;
	                index += _position;
	                if (index >= 0 && index < _input_length) {
	                    val = _input.charCodeAt(index);
	                }
	                return val;
	            };

	            this.test = function(pattern, index) {
	                index = index || 0;
	                pattern.lastIndex = _position + index;
	                return pattern.test(_input);
	            };

	            this.testChar = function(pattern, index) {
	                var val = this.peek(index);
	                return val !== null && pattern.test(val);
	            };

	            this.match = function(pattern) {
	                pattern.lastIndex = _position;
	                var pattern_match = pattern.exec(_input);
	                if (pattern_match && pattern_match.index === _position) {
	                    _position += pattern_match[0].length;
	                } else {
	                    pattern_match = null;
	                }
	                return pattern_match;
	            };
	        };

	        var Token = function(type, text, newlines, whitespace_before, parent) {
	            this.type = type;
	            this.text = text;

	            // comments_before are
	            // comments that have a new line before them
	            // and may or may not have a newline after
	            // this is a set of comments before
	            this.comments_before = /* inline comment*/ [];


	            this.comments_after = []; // no new line before and newline after
	            this.newlines = newlines || 0;
	            this.wanted_newline = newlines > 0;
	            this.whitespace_before = whitespace_before || '';
	            this.parent = parent || null;
	            this.opened = null;
	            this.directives = null;
	        };

	        function tokenizer(input_string, opts) {

	            var whitespace = "\n\r\t ".split('');
	            var digit = /[0-9]/;
	            var digit_bin = /[01]/;
	            var digit_oct = /[01234567]/;
	            var digit_hex = /[0123456789abcdefABCDEF]/;

	            this.positionable_operators = '!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');
	            var punct = this.positionable_operators.concat(
	                // non-positionable operators - these do not follow operator position settings
	                '! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...'.split(' '));

	            // words which should always start on new line.
	            this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
	            var reserved_words = this.line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);

	            //  /* ... */ comment ends with nearest */ or end of file
	            var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

	            // comment ends just before nearest linefeed or end of file
	            var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

	            var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
	            var directive_pattern = / (\w+)[:](\w+)/g;
	            var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

	            var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;

	            var n_newlines, whitespace_before_token, in_html_comment, tokens;
	            var input;

	            this.tokenize = function() {
	                input = new InputScanner(input_string);
	                in_html_comment = false;
	                tokens = [];

	                var next, last;
	                var token_values;
	                var open = null;
	                var open_stack = [];
	                var comments = [];

	                while (!(last && last.type === 'TK_EOF')) {
	                    token_values = tokenize_next();
	                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
	                    while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
	                        if (next.type === 'TK_BLOCK_COMMENT') {
	                            next.directives = token_values[2];
	                        }
	                        comments.push(next);
	                        token_values = tokenize_next();
	                        next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
	                    }

	                    if (comments.length) {
	                        next.comments_before = comments;
	                        comments = [];
	                    }

	                    if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
	                        next.parent = last;
	                        open_stack.push(open);
	                        open = next;
	                    } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
	                        (open && (
	                            (next.text === ']' && open.text === '[') ||
	                            (next.text === ')' && open.text === '(') ||
	                            (next.text === '}' && open.text === '{')))) {
	                        next.parent = open.parent;
	                        next.opened = open;

	                        open = open_stack.pop();
	                    }

	                    tokens.push(next);
	                    last = next;
	                }

	                return tokens;
	            };

	            function get_directives(text) {
	                if (!text.match(directives_block_pattern)) {
	                    return null;
	                }

	                var directives = {};
	                directive_pattern.lastIndex = 0;
	                var directive_match = directive_pattern.exec(text);

	                while (directive_match) {
	                    directives[directive_match[1]] = directive_match[2];
	                    directive_match = directive_pattern.exec(text);
	                }

	                return directives;
	            }

	            function tokenize_next() {
	                var resulting_string;
	                var whitespace_on_this_line = [];

	                n_newlines = 0;
	                whitespace_before_token = '';

	                var c = input.next();

	                if (c === null) {
	                    return ['', 'TK_EOF'];
	                }

	                var last_token;
	                if (tokens.length) {
	                    last_token = tokens[tokens.length - 1];
	                } else {
	                    // For the sake of tokenizing we can pretend that there was on open brace to start
	                    last_token = new Token('TK_START_BLOCK', '{');
	                }

	                while (in_array(c, whitespace)) {

	                    if (acorn.newline.test(c)) {
	                        if (!(c === '\n' && input.peek(-2) === '\r')) {
	                            n_newlines += 1;
	                            whitespace_on_this_line = [];
	                        }
	                    } else {
	                        whitespace_on_this_line.push(c);
	                    }

	                    c = input.next();

	                    if (c === null) {
	                        return ['', 'TK_EOF'];
	                    }
	                }

	                if (whitespace_on_this_line.length) {
	                    whitespace_before_token = whitespace_on_this_line.join('');
	                }

	                if (digit.test(c) || (c === '.' && input.testChar(digit))) {
	                    var allow_decimal = true;
	                    var allow_e = true;
	                    var local_digit = digit;

	                    if (c === '0' && input.testChar(/[XxOoBb]/)) {
	                        // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits
	                        allow_decimal = false;
	                        allow_e = false;
	                        if (input.testChar(/[Bb]/)) {
	                            local_digit = digit_bin;
	                        } else if (input.testChar(/[Oo]/)) {
	                            local_digit = digit_oct;
	                        } else {
	                            local_digit = digit_hex;
	                        }
	                        c += input.next();
	                    } else if (c === '.') {
	                        // Already have a decimal for this literal, don't allow another
	                        allow_decimal = false;
	                    } else {
	                        // we know this first loop will run.  It keeps the logic simpler.
	                        c = '';
	                        input.back();
	                    }

	                    // Add the digits
	                    while (input.testChar(local_digit)) {
	                        c += input.next();

	                        if (allow_decimal && input.peek() === '.') {
	                            c += input.next();
	                            allow_decimal = false;
	                        }

	                        // a = 1.e-7 is valid, so we test for . then e in one loop
	                        if (allow_e && input.testChar(/[Ee]/)) {
	                            c += input.next();

	                            if (input.testChar(/[+-]/)) {
	                                c += input.next();
	                            }

	                            allow_e = false;
	                            allow_decimal = false;
	                        }
	                    }

	                    return [c, 'TK_WORD'];
	                }

	                if (acorn.isIdentifierStart(input.peekCharCode(-1))) {
	                    if (input.hasNext()) {
	                        while (acorn.isIdentifierChar(input.peekCharCode())) {
	                            c += input.next();
	                            if (!input.hasNext()) {
	                                break;
	                            }
	                        }
	                    }

	                    if (!(last_token.type === 'TK_DOT' ||
	                            (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get']))) &&
	                        in_array(c, reserved_words)) {
	                        if (c === 'in' || c === 'of') { // hack for 'in' and 'of' operators
	                            return [c, 'TK_OPERATOR'];
	                        }
	                        return [c, 'TK_RESERVED'];
	                    }

	                    return [c, 'TK_WORD'];
	                }

	                if (c === '(' || c === '[') {
	                    return [c, 'TK_START_EXPR'];
	                }

	                if (c === ')' || c === ']') {
	                    return [c, 'TK_END_EXPR'];
	                }

	                if (c === '{') {
	                    return [c, 'TK_START_BLOCK'];
	                }

	                if (c === '}') {
	                    return [c, 'TK_END_BLOCK'];
	                }

	                if (c === ';') {
	                    return [c, 'TK_SEMICOLON'];
	                }

	                if (c === '/') {
	                    var comment = '';
	                    var comment_match;
	                    // peek for comment /* ... */
	                    if (input.peek() === '*') {
	                        input.next();
	                        comment_match = input.match(block_comment_pattern);
	                        comment = '/*' + comment_match[0];
	                        var directives = get_directives(comment);
	                        if (directives && directives.ignore === 'start') {
	                            comment_match = input.match(directives_end_ignore_pattern);
	                            comment += comment_match[0];
	                        }
	                        comment = comment.replace(acorn.allLineBreaks, '\n');
	                        return [comment, 'TK_BLOCK_COMMENT', directives];
	                    }
	                    // peek for comment // ...
	                    if (input.peek() === '/') {
	                        input.next();
	                        comment_match = input.match(comment_pattern);
	                        comment = '//' + comment_match[0];
	                        return [comment, 'TK_COMMENT'];
	                    }

	                }

	                var startXmlRegExp = /<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;

	                if (c === '`' || c === "'" || c === '"' || // string
	                    (
	                        (c === '/') || // regexp
	                        (opts.e4x && c === "<" && input.test(startXmlRegExp, -1)) // xml
	                    ) && ( // regex and xml can only appear in specific locations during parsing
	                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
	                        (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
	                            last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
	                        (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
	                            'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
	                        ]))
	                    )) {

	                    var sep = c,
	                        esc = false,
	                        has_char_escapes = false;

	                    resulting_string = c;

	                    if (sep === '/') {
	                        //
	                        // handle regexp
	                        //
	                        var in_char_class = false;
	                        while (input.hasNext() &&
	                            ((esc || in_char_class || input.peek() !== sep) &&
	                                !input.testChar(acorn.newline))) {
	                            resulting_string += input.peek();
	                            if (!esc) {
	                                esc = input.peek() === '\\';
	                                if (input.peek() === '[') {
	                                    in_char_class = true;
	                                } else if (input.peek() === ']') {
	                                    in_char_class = false;
	                                }
	                            } else {
	                                esc = false;
	                            }
	                            input.next();
	                        }
	                    } else if (opts.e4x && sep === '<') {
	                        //
	                        // handle e4x xml literals
	                        //

	                        var xmlRegExp = /[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;
	                        input.back();
	                        var xmlStr = '';
	                        var match = input.match(startXmlRegExp);
	                        if (match) {
	                            // Trim root tag to attempt to
	                            var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
	                            var isCurlyRoot = rootTag.indexOf('{') === 0;
	                            var depth = 0;
	                            while (match) {
	                                var isEndTag = !!match[1];
	                                var tagName = match[2];
	                                var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
	                                if (!isSingletonTag &&
	                                    (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
	                                    if (isEndTag) {
	                                        --depth;
	                                    } else {
	                                        ++depth;
	                                    }
	                                }
	                                xmlStr += match[0];
	                                if (depth <= 0) {
	                                    break;
	                                }
	                                match = input.match(xmlRegExp);
	                            }
	                            // if we didn't close correctly, keep unformatted.
	                            if (!match) {
	                                xmlStr += input.match(/[\s\S]*/g)[0];
	                            }
	                            xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
	                            return [xmlStr, "TK_STRING"];
	                        }
	                    } else {
	                        //
	                        // handle string
	                        //
	                        var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {
	                            // Template strings can travers lines without escape characters.
	                            // Other strings cannot
	                            var current_char;
	                            while (input.hasNext()) {
	                                current_char = input.peek();
	                                if (!(esc || (current_char !== delimiter &&
	                                        (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {
	                                    break;
	                                }

	                                // Handle \r\n linebreaks after escapes or in template strings
	                                if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {
	                                    if (current_char === '\r' && input.peek(1) === '\n') {
	                                        input.next();
	                                        current_char = input.peek();
	                                    }
	                                    resulting_string += '\n';
	                                } else {
	                                    resulting_string += current_char;
	                                }

	                                if (esc) {
	                                    if (current_char === 'x' || current_char === 'u') {
	                                        has_char_escapes = true;
	                                    }
	                                    esc = false;
	                                } else {
	                                    esc = current_char === '\\';
	                                }

	                                input.next();

	                                if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {
	                                    if (delimiter === '`') {
	                                        parse_string('}', allow_unescaped_newlines, '`');
	                                    } else {
	                                        parse_string('`', allow_unescaped_newlines, '${');
	                                    }

	                                    if (input.hasNext()) {
	                                        resulting_string += input.next();
	                                    }
	                                }
	                            }
	                        };

	                        if (sep === '`') {
	                            parse_string('`', true, '${');
	                        } else {
	                            parse_string(sep);
	                        }
	                    }

	                    if (has_char_escapes && opts.unescape_strings) {
	                        resulting_string = unescape_string(resulting_string);
	                    }

	                    if (input.peek() === sep) {
	                        resulting_string += sep;
	                        input.next();

	                        if (sep === '/') {
	                            // regexps may have modifiers /regexp/MOD , so fetch those, too
	                            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
	                            while (input.hasNext() && acorn.isIdentifierStart(input.peekCharCode())) {
	                                resulting_string += input.next();
	                            }
	                        }
	                    }
	                    return [resulting_string, 'TK_STRING'];
	                }

	                if (c === '#') {

	                    if (tokens.length === 0 && input.peek() === '!') {
	                        // shebang
	                        resulting_string = c;
	                        while (input.hasNext() && c !== '\n') {
	                            c = input.next();
	                            resulting_string += c;
	                        }
	                        return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
	                    }



	                    // Spidermonkey-specific sharp variables for circular references
	                    // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
	                    // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
	                    var sharp = '#';
	                    if (input.hasNext() && input.testChar(digit)) {
	                        do {
	                            c = input.next();
	                            sharp += c;
	                        } while (input.hasNext() && c !== '#' && c !== '=');
	                        if (c === '#') {
	                            //
	                        } else if (input.peek() === '[' && input.peek(1) === ']') {
	                            sharp += '[]';
	                            input.next();
	                            input.next();
	                        } else if (input.peek() === '{' && input.peek(1) === '}') {
	                            sharp += '{}';
	                            input.next();
	                            input.next();
	                        }
	                        return [sharp, 'TK_WORD'];
	                    }
	                }

	                if (c === '<' && (input.peek() === '?' || input.peek() === '%')) {
	                    input.back();
	                    var template_match = input.match(template_pattern);
	                    if (template_match) {
	                        c = template_match[0];
	                        c = c.replace(acorn.allLineBreaks, '\n');
	                        return [c, 'TK_STRING'];
	                    }
	                }

	                if (c === '<' && input.match(/\!--/g)) {
	                    c = '<!--';
	                    while (input.hasNext() && !input.testChar(acorn.newline)) {
	                        c += input.next();
	                    }
	                    in_html_comment = true;
	                    return [c, 'TK_COMMENT'];
	                }

	                if (c === '-' && in_html_comment && input.match(/->/g)) {
	                    in_html_comment = false;
	                    return ['-->', 'TK_COMMENT'];
	                }

	                if (c === '.') {
	                    if (input.peek() === '.' && input.peek(1) === '.') {
	                        c += input.next() + input.next();
	                        return [c, 'TK_OPERATOR'];
	                    }
	                    return [c, 'TK_DOT'];
	                }

	                if (in_array(c, punct)) {
	                    while (input.hasNext() && in_array(c + input.peek(), punct)) {
	                        c += input.next();
	                        if (!input.hasNext()) {
	                            break;
	                        }
	                    }

	                    if (c === ',') {
	                        return [c, 'TK_COMMA'];
	                    } else if (c === '=') {
	                        return [c, 'TK_EQUALS'];
	                    } else {
	                        return [c, 'TK_OPERATOR'];
	                    }
	                }

	                return [c, 'TK_UNKNOWN'];
	            }


	            function unescape_string(s) {
	                // You think that a regex would work for this
	                // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
	                //         return String.fromCharCode(parseInt(val, 16));
	                //     })
	                // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
	                var out = '',
	                    escaped = 0;

	                var input_scan = new InputScanner(s);
	                var matched = null;

	                while (input_scan.hasNext()) {
	                    // Keep any whitespace, non-slash characters
	                    // also keep slash pairs.
	                    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

	                    if (matched) {
	                        out += matched[0];
	                    }

	                    if (input_scan.peek() === '\\') {
	                        input_scan.next();
	                        if (input_scan.peek() === 'x') {
	                            matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
	                        } else if (input_scan.peek() === 'u') {
	                            matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
	                        } else {
	                            out += '\\';
	                            if (input_scan.hasNext()) {
	                                out += input_scan.next();
	                            }
	                            continue;
	                        }

	                        // If there's some error decoding, return the original string
	                        if (!matched) {
	                            return s;
	                        }

	                        escaped = parseInt(matched[1], 16);

	                        if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
	                            // we bail out on \x7f..\xff,
	                            // leaving whole string escaped,
	                            // as it's probably completely binary
	                            return s;
	                        } else if (escaped >= 0x00 && escaped < 0x20) {
	                            // leave 0x00...0x1f escaped
	                            out += '\\' + matched[0];
	                            continue;
	                        } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	                            // single-quote, apostrophe, backslash - escape these
	                            out += '\\' + String.fromCharCode(escaped);
	                        } else {
	                            out += String.fromCharCode(escaped);
	                        }
	                    }
	                }

	                return out;
	            }
	        }

	        var beautifier = new Beautifier(js_source_text, options);
	        return beautifier.beautify();

	    }

	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return { js_beautify: js_beautify };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var js_beautify = require("beautify").js_beautify`.
	        exports.js_beautify = js_beautify;
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.js_beautify = js_beautify;
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.js_beautify = js_beautify;
	    }

	}());

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 CSS Beautifier
	---------------

	    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

	    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	        http://jsbeautifier.org/

	    Usage:
	        css_beautify(source_text);
	        css_beautify(source_text, options);

	    The options are (default in brackets):
	        indent_size (4)                         â€” indentation size,
	        indent_char (space)                     â€” character to indent with,
	        preserve_newlines (default false)       - whether existing line breaks should be preserved,
	        selector_separator_newline (true)       - separate selectors with newline or
	                                                  not (e.g. "a,\nbr" or "a, br")
	        end_with_newline (false)                - end with a newline
	        newline_between_rules (true)            - add a new line after every css rule
	        space_around_selector_separator (false) - ensure space around selector separators:
	                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
	    e.g

	    css_beautify(css_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t',
	      'selector_separator': ' ',
	      'end_with_newline': false,
	      'newline_between_rules': true,
	      'space_around_selector_separator': true
	    });
	*/

	// http://www.w3.org/TR/CSS21/syndata.html#tokenization
	// http://www.w3.org/TR/css3-syntax/

	(function() {

	    function mergeOpts(allOptions, targetType) {
	        var finalOpts = {};
	        var name;

	        for (name in allOptions) {
	            if (name !== targetType) {
	                finalOpts[name] = allOptions[name];
	            }
	        }


	        //merge in the per type settings for the targetType
	        if (targetType in allOptions) {
	            for (name in allOptions[targetType]) {
	                finalOpts[name] = allOptions[targetType][name];
	            }
	        }
	        return finalOpts;
	    }

	    var lineBreak = /\r\n|[\n\r\u2028\u2029]/;
	    var allLineBreaks = new RegExp(lineBreak.source, 'g');

	    function css_beautify(source_text, options) {
	        options = options || {};

	        // Allow the setting of language/file-type specific options
	        // with inheritance of overall settings
	        options = mergeOpts(options, 'css');

	        source_text = source_text || '';

	        var newlinesFromLastWSEat = 0;
	        var indentSize = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	        var indentCharacter = options.indent_char || ' ';
	        var preserve_newlines = (options.preserve_newlines === undefined) ? false : options.preserve_newlines;
	        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
	        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	        var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
	        var space_around_combinator = (options.space_around_combinator === undefined) ? false : options.space_around_combinator;
	        space_around_combinator = space_around_combinator || ((options.space_around_selector_separator === undefined) ? false : options.space_around_selector_separator);
	        var eol = options.eol ? options.eol : 'auto';

	        if (options.indent_with_tabs) {
	            indentCharacter = '\t';
	            indentSize = 1;
	        }

	        if (eol === 'auto') {
	            eol = '\n';
	            if (source_text && lineBreak.test(source_text || '')) {
	                eol = source_text.match(lineBreak)[0];
	            }
	        }

	        eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

	        // HACK: newline parsing inconsistent. This brute force normalizes the input.
	        source_text = source_text.replace(allLineBreaks, '\n');

	        // tokenizer
	        var whiteRe = /^\s+$/;

	        var pos = -1,
	            ch;
	        var parenLevel = 0;

	        function next() {
	            ch = source_text.charAt(++pos);
	            return ch || '';
	        }

	        function peek(skipWhitespace) {
	            var result = '';
	            var prev_pos = pos;
	            if (skipWhitespace) {
	                eatWhitespace();
	            }
	            result = source_text.charAt(pos + 1) || '';
	            pos = prev_pos - 1;
	            next();
	            return result;
	        }

	        function eatString(endChars) {
	            var start = pos;
	            while (next()) {
	                if (ch === "\\") {
	                    next();
	                } else if (endChars.indexOf(ch) !== -1) {
	                    break;
	                } else if (ch === "\n") {
	                    break;
	                }
	            }
	            return source_text.substring(start, pos + 1);
	        }

	        function peekString(endChar) {
	            var prev_pos = pos;
	            var str = eatString(endChar);
	            pos = prev_pos - 1;
	            next();
	            return str;
	        }

	        function eatWhitespace(preserve_newlines_local) {
	            var result = 0;
	            while (whiteRe.test(peek())) {
	                next();
	                if (ch === '\n' && preserve_newlines_local && preserve_newlines) {
	                    print.newLine(true);
	                    result++;
	                }
	            }
	            newlinesFromLastWSEat = result;
	            return result;
	        }

	        function skipWhitespace() {
	            var result = '';
	            if (ch && whiteRe.test(ch)) {
	                result = ch;
	            }
	            while (whiteRe.test(next())) {
	                result += ch;
	            }
	            return result;
	        }

	        function eatComment(singleLine) {
	            var start = pos;
	            singleLine = peek() === "/";
	            next();
	            while (next()) {
	                if (!singleLine && ch === "*" && peek() === "/") {
	                    next();
	                    break;
	                } else if (singleLine && ch === "\n") {
	                    return source_text.substring(start, pos);
	                }
	            }

	            return source_text.substring(start, pos) + ch;
	        }


	        function lookBack(str) {
	            return source_text.substring(pos - str.length, pos).toLowerCase() ===
	                str;
	        }

	        // Nested pseudo-class if we are insideRule
	        // and the next special character found opens
	        // a new block
	        function foundNestedPseudoClass() {
	            var openParen = 0;
	            for (var i = pos + 1; i < source_text.length; i++) {
	                var ch = source_text.charAt(i);
	                if (ch === "{") {
	                    return true;
	                } else if (ch === '(') {
	                    // pseudoclasses can contain ()
	                    openParen += 1;
	                } else if (ch === ')') {
	                    if (openParen === 0) {
	                        return false;
	                    }
	                    openParen -= 1;
	                } else if (ch === ";" || ch === "}") {
	                    return false;
	                }
	            }
	            return false;
	        }

	        // printer
	        var basebaseIndentString = source_text.match(/^[\t ]*/)[0];
	        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
	        var indentLevel = 0;
	        var nestedLevel = 0;

	        function indent() {
	            indentLevel++;
	            basebaseIndentString += singleIndent;
	        }

	        function outdent() {
	            indentLevel--;
	            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);
	        }

	        var print = {};
	        print["{"] = function(ch) {
	            print.singleSpace();
	            output.push(ch);
	            if (!eatWhitespace(true)) {
	                print.newLine();
	            }
	        };
	        print["}"] = function(newline) {
	            if (newline) {
	                print.newLine();
	            }
	            output.push('}');
	            if (!eatWhitespace(true)) {
	                print.newLine();
	            }
	        };

	        print._lastCharWhitespace = function() {
	            return whiteRe.test(output[output.length - 1]);
	        };

	        print.newLine = function(keepWhitespace) {
	            if (output.length) {
	                if (!keepWhitespace && output[output.length - 1] !== '\n') {
	                    print.trim();
	                } else if (output[output.length - 1] === basebaseIndentString) {
	                    output.pop();
	                }
	                output.push('\n');

	                if (basebaseIndentString) {
	                    output.push(basebaseIndentString);
	                }
	            }
	        };
	        print.singleSpace = function() {
	            if (output.length && !print._lastCharWhitespace()) {
	                output.push(' ');
	            }
	        };

	        print.preserveSingleSpace = function() {
	            if (isAfterSpace) {
	                print.singleSpace();
	            }
	        };

	        print.trim = function() {
	            while (print._lastCharWhitespace()) {
	                output.pop();
	            }
	        };


	        var output = [];
	        /*_____________________--------------------_____________________*/

	        var insideRule = false;
	        var insidePropertyValue = false;
	        var enteringConditionalGroup = false;
	        var top_ch = '';
	        var last_top_ch = '';

	        while (true) {
	            var whitespace = skipWhitespace();
	            var isAfterSpace = whitespace !== '';
	            var isAfterNewline = whitespace.indexOf('\n') !== -1;
	            last_top_ch = top_ch;
	            top_ch = ch;

	            if (!ch) {
	                break;
	            } else if (ch === '/' && peek() === '*') { /* css comment */
	                var header = indentLevel === 0;

	                if (isAfterNewline || header) {
	                    print.newLine();
	                }

	                output.push(eatComment());
	                print.newLine();
	                if (header) {
	                    print.newLine(true);
	                }
	            } else if (ch === '/' && peek() === '/') { // single line comment
	                if (!isAfterNewline && last_top_ch !== '{') {
	                    print.trim();
	                }
	                print.singleSpace();
	                output.push(eatComment());
	                print.newLine();
	            } else if (ch === '@') {
	                print.preserveSingleSpace();

	                // deal with less propery mixins @{...}
	                if (peek() === '{') {
	                    output.push(eatString('}'));
	                } else {
	                    output.push(ch);

	                    // strip trailing space, if present, for hash property checks
	                    var variableOrRule = peekString(": ,;{}()[]/='\"");

	                    if (variableOrRule.match(/[ :]$/)) {
	                        // we have a variable or pseudo-class, add it and insert one space before continuing
	                        next();
	                        variableOrRule = eatString(": ").replace(/\s$/, '');
	                        output.push(variableOrRule);
	                        print.singleSpace();
	                    }

	                    variableOrRule = variableOrRule.replace(/\s$/, '');

	                    // might be a nesting at-rule
	                    if (variableOrRule in css_beautify.NESTED_AT_RULE) {
	                        nestedLevel += 1;
	                        if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {
	                            enteringConditionalGroup = true;
	                        }
	                    }
	                }
	            } else if (ch === '#' && peek() === '{') {
	                print.preserveSingleSpace();
	                output.push(eatString('}'));
	            } else if (ch === '{') {
	                if (peek(true) === '}') {
	                    eatWhitespace();
	                    next();
	                    print.singleSpace();
	                    output.push("{");
	                    print['}'](false);
	                    if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
	                        print.newLine(true);
	                    }
	                } else {
	                    indent();
	                    print["{"](ch);
	                    // when entering conditional groups, only rulesets are allowed
	                    if (enteringConditionalGroup) {
	                        enteringConditionalGroup = false;
	                        insideRule = (indentLevel > nestedLevel);
	                    } else {
	                        // otherwise, declarations are also allowed
	                        insideRule = (indentLevel >= nestedLevel);
	                    }
	                }
	            } else if (ch === '}') {
	                outdent();
	                print["}"](true);
	                insideRule = false;
	                insidePropertyValue = false;
	                if (nestedLevel) {
	                    nestedLevel--;
	                }
	                if (newlinesFromLastWSEat < 2 && newline_between_rules && indentLevel === 0) {
	                    print.newLine(true);
	                }
	            } else if (ch === ":") {
	                eatWhitespace();
	                if ((insideRule || enteringConditionalGroup) &&
	                    !(lookBack("&") || foundNestedPseudoClass()) &&
	                    !lookBack("(")) {
	                    // 'property: value' delimiter
	                    // which could be in a conditional group query
	                    output.push(':');
	                    if (!insidePropertyValue) {
	                        insidePropertyValue = true;
	                        print.singleSpace();
	                    }
	                } else {
	                    // sass/less parent reference don't use a space
	                    // sass nested pseudo-class don't use a space

	                    // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
	                    if (lookBack(" ") && output[output.length - 1] !== " ") {
	                        output.push(" ");
	                    }
	                    if (peek() === ":") {
	                        // pseudo-element
	                        next();
	                        output.push("::");
	                    } else {
	                        // pseudo-class
	                        output.push(':');
	                    }
	                }
	            } else if (ch === '"' || ch === '\'') {
	                print.preserveSingleSpace();
	                output.push(eatString(ch));
	            } else if (ch === ';') {
	                insidePropertyValue = false;
	                output.push(ch);
	                if (!eatWhitespace(true)) {
	                    print.newLine();
	                }
	            } else if (ch === '(') { // may be a url
	                if (lookBack("url")) {
	                    output.push(ch);
	                    eatWhitespace();
	                    if (next()) {
	                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
	                            output.push(eatString(')'));
	                        } else {
	                            pos--;
	                        }
	                    }
	                } else {
	                    parenLevel++;
	                    print.preserveSingleSpace();
	                    output.push(ch);
	                    eatWhitespace();
	                }
	            } else if (ch === ')') {
	                output.push(ch);
	                parenLevel--;
	            } else if (ch === ',') {
	                output.push(ch);
	                if (!eatWhitespace(true) && selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
	                    print.newLine();
	                } else {
	                    print.singleSpace();
	                }
	            } else if ((ch === '>' || ch === '+' || ch === '~') &&
	                !insidePropertyValue && parenLevel < 1) {
	                //handle combinator spacing
	                if (space_around_combinator) {
	                    print.singleSpace();
	                    output.push(ch);
	                    print.singleSpace();
	                } else {
	                    output.push(ch);
	                    eatWhitespace();
	                    // squash extra whitespace
	                    if (ch && whiteRe.test(ch)) {
	                        ch = '';
	                    }
	                }
	            } else if (ch === ']') {
	                output.push(ch);
	            } else if (ch === '[') {
	                print.preserveSingleSpace();
	                output.push(ch);
	            } else if (ch === '=') { // no whitespace before or after
	                eatWhitespace();
	                output.push('=');
	                if (whiteRe.test(ch)) {
	                    ch = '';
	                }
	            } else {
	                print.preserveSingleSpace();
	                output.push(ch);
	            }
	        }


	        var sweetCode = '';
	        if (basebaseIndentString) {
	            sweetCode += basebaseIndentString;
	        }

	        sweetCode += output.join('').replace(/[\r\n\t ]+$/, '');

	        // establish end_with_newline
	        if (end_with_newline) {
	            sweetCode += '\n';
	        }

	        if (eol !== '\n') {
	            sweetCode = sweetCode.replace(/[\n]/g, eol);
	        }

	        return sweetCode;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	    css_beautify.NESTED_AT_RULE = {
	        "@page": true,
	        "@font-face": true,
	        "@keyframes": true,
	        // also in CONDITIONAL_GROUP_RULE below
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };
	    css_beautify.CONDITIONAL_GROUP_RULE = {
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };

	    /*global define */
	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return {
	                css_beautify: css_beautify
	            };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
	        exports.css_beautify = css_beautify;
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.css_beautify = css_beautify;
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.css_beautify = css_beautify;
	    }

	}());

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2017 Einar Lielmanis, Liam Newman, and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 Style HTML
	---------------

	  Written by Nochum Sossonko, (nsossonko@hotmail.com)

	  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	    http://jsbeautifier.org/

	  Usage:
	    style_html(html_source);

	    style_html(html_source, options);

	  The options are:
	    indent_inner_html (default false)  â€” indent <head> and <body> sections,
	    indent_size (default 4)          â€” indentation size,
	    indent_char (default space)      â€” character to indent with,
	    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
	    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
	    content_unformatted (defaults to pre tag) - list of tags, that its content shouldn't be reformatted
	    indent_scripts (default normal)  - "keep"|"separate"|"normal"
	    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
	                                        Only works before elements, not inside tags or for text.
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
	    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
	    end_with_newline (false)          - end with a newline
	    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

	    e.g.

	    style_html(html_source, {
	      'indent_inner_html': false,
	      'indent_size': 2,
	      'indent_char': ' ',
	      'wrap_line_length': 78,
	      'brace_style': 'expand',
	      'preserve_newlines': true,
	      'max_preserve_newlines': 5,
	      'indent_handlebars': false,
	      'extra_liners': ['/html']
	    });
	*/

	(function() {

	    // function trim(s) {
	    //     return s.replace(/^\s+|\s+$/g, '');
	    // }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function rtrim(s) {
	        return s.replace(/\s+$/g, '');
	    }

	    function mergeOpts(allOptions, targetType) {
	        var finalOpts = {};
	        var name;

	        for (name in allOptions) {
	            if (name !== targetType) {
	                finalOpts[name] = allOptions[name];
	            }
	        }

	        //merge in the per type settings for the targetType
	        if (targetType in allOptions) {
	            for (name in allOptions[targetType]) {
	                finalOpts[name] = allOptions[targetType][name];
	            }
	        }
	        return finalOpts;
	    }

	    var lineBreak = /\r\n|[\n\r\u2028\u2029]/;
	    var allLineBreaks = new RegExp(lineBreak.source, 'g');

	    function style_html(html_source, options, js_beautify, css_beautify) {
	        //Wrapper function to invoke all the necessary constructors and deal with the output.

	        var multi_parser,
	            indent_inner_html,
	            indent_body_inner_html,
	            indent_head_inner_html,
	            indent_size,
	            indent_character,
	            wrap_line_length,
	            brace_style,
	            unformatted,
	            content_unformatted,
	            preserve_newlines,
	            max_preserve_newlines,
	            indent_handlebars,
	            wrap_attributes,
	            wrap_attributes_indent_size,
	            is_wrap_attributes_force,
	            is_wrap_attributes_force_expand_multiline,
	            is_wrap_attributes_force_aligned,
	            end_with_newline,
	            extra_liners,
	            eol;

	        options = options || {};

	        // Allow the setting of language/file-type specific options
	        // with inheritance of overall settings
	        options = mergeOpts(options, 'html');

	        // backwards compatibility to 1.3.4
	        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
	            (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
	            options.wrap_line_length = options.max_char;
	        }

	        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
	        indent_body_inner_html = (options.indent_body_inner_html === undefined) ? true : options.indent_body_inner_html;
	        indent_head_inner_html = (options.indent_head_inner_html === undefined) ? true : options.indent_head_inner_html;
	        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
	        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
	        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
	        wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
	        unformatted = options.unformatted || [
	            // https://www.w3.org/TR/html5/dom.html#phrasing-content
	            'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
	            'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
	            'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
	            'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
	            'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
	            'video', 'wbr', 'text',
	            // prexisting - not sure of full effect of removing, leaving in
	            'acronym', 'address', 'big', 'dt', 'ins', 'strike', 'tt',
	        ];
	        content_unformatted = options.content_unformatted || [
	            'pre',
	        ];
	        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	        max_preserve_newlines = preserve_newlines ?
	            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) :
	            0;
	        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
	        wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
	        wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);
	        is_wrap_attributes_force = wrap_attributes.substr(0, 'force'.length) === 'force';
	        is_wrap_attributes_force_expand_multiline = (wrap_attributes === 'force-expand-multiline');
	        is_wrap_attributes_force_aligned = (wrap_attributes === 'force-aligned');
	        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	        extra_liners = (typeof options.extra_liners === 'object') && options.extra_liners ?
	            options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
	            options.extra_liners.split(',') : 'head,body,/html'.split(',');
	        eol = options.eol ? options.eol : 'auto';

	        if (options.indent_with_tabs) {
	            indent_character = '\t';
	            indent_size = 1;
	        }

	        if (eol === 'auto') {
	            eol = '\n';
	            if (html_source && lineBreak.test(html_source || '')) {
	                eol = html_source.match(lineBreak)[0];
	            }
	        }

	        eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n');

	        // HACK: newline parsing inconsistent. This brute force normalizes the input.
	        html_source = html_source.replace(allLineBreaks, '\n');

	        function Parser() {

	            this.pos = 0; //Parser position
	            this.token = '';
	            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
	            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
	                parent: 'parent1',
	                parentcount: 1,
	                parent1: ''
	            };
	            this.tag_type = '';
	            this.token_text = this.last_token = this.last_text = this.token_type = '';
	            this.newlines = 0;
	            this.indent_content = indent_inner_html;
	            this.indent_body_inner_html = indent_body_inner_html;
	            this.indent_head_inner_html = indent_head_inner_html;

	            this.Utils = { //Uilities made available to the various functions
	                whitespace: "\n\r\t ".split(''),

	                single_token: options.void_elements || [
	                    // HTLM void elements - aka self-closing tags - aka singletons
	                    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
	                    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
	                    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
	                    // NOTE: Optional tags - are not understood.
	                    // https://www.w3.org/TR/html5/syntax.html#optional-tags
	                    // The rules for optional tags are too complex for a simple list
	                    // Also, the content of these tags should still be indented in many cases.
	                    // 'li' is a good exmple.

	                    // Doctype and xml elements
	                    '!doctype', '?xml',
	                    // ?php tag
	                    '?php',
	                    // other tags that were in this list, keeping just in case
	                    'basefont', 'isindex'
	                ],
	                extra_liners: extra_liners, //for tags that need a line of whitespace before them
	                in_array: function(what, arr) {
	                    for (var i = 0; i < arr.length; i++) {
	                        if (what === arr[i]) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            };

	            // Return true if the given text is composed entirely of whitespace.
	            this.is_whitespace = function(text) {
	                for (var n = 0; n < text.length; n++) {
	                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
	                        return false;
	                    }
	                }
	                return true;
	            };

	            this.traverse_whitespace = function() {
	                var input_char = '';

	                input_char = this.input.charAt(this.pos);
	                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                    this.newlines = 0;
	                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
	                            this.newlines += 1;
	                        }

	                        this.pos++;
	                        input_char = this.input.charAt(this.pos);
	                    }
	                    return true;
	                }
	                return false;
	            };

	            // Append a space to the given content (string array) or, if we are
	            // at the wrap_line_length, append a newline/indentation.
	            // return true if a newline was added, false if a space was added
	            this.space_or_wrap = function(content) {
	                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
	                    this.print_newline(false, content);
	                    this.print_indentation(content);
	                    return true;
	                } else {
	                    this.line_char_count++;
	                    content.push(' ');
	                    return false;
	                }
	            };

	            this.get_content = function() { //function to capture regular content between tags
	                var input_char = '',
	                    content = [],
	                    handlebarsStarted = 0;

	                while (this.input.charAt(this.pos) !== '<' || handlebarsStarted === 2) {
	                    if (this.pos >= this.input.length) {
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    if (handlebarsStarted < 2 && this.traverse_whitespace()) {
	                        this.space_or_wrap(content);
	                        continue;
	                    }

	                    input_char = this.input.charAt(this.pos);

	                    if (indent_handlebars) {
	                        if (input_char === '{') {
	                            handlebarsStarted += 1;
	                        } else if (handlebarsStarted < 2) {
	                            handlebarsStarted = 0;
	                        }

	                        if (input_char === '}' && handlebarsStarted > 0) {
	                            if (handlebarsStarted-- === 0) {
	                                break;
	                            }
	                        }
	                        // Handlebars parsing is complicated.
	                        // {{#foo}} and {{/foo}} are formatted tags.
	                        // {{something}} should get treated as content, except:
	                        // {{else}} specifically behaves like {{#if}} and {{/if}}
	                        var peek3 = this.input.substr(this.pos, 3);
	                        if (peek3 === '{{#' || peek3 === '{{/') {
	                            // These are tags and not content.
	                            break;
	                        } else if (peek3 === '{{!') {
	                            return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
	                        } else if (this.input.substr(this.pos, 2) === '{{') {
	                            if (this.get_tag(true) === '{{else}}') {
	                                break;
	                            }
	                        }
	                    }

	                    this.pos++;
	                    this.line_char_count++;
	                    content.push(input_char); //letter at-a-time (or string) inserted to an array
	                }
	                return content.length ? content.join('') : '';
	            };

	            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
	                if (this.pos === this.input.length) {
	                    return ['', 'TK_EOF'];
	                }
	                var content = '';
	                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
	                reg_match.lastIndex = this.pos;
	                var reg_array = reg_match.exec(this.input);
	                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
	                if (this.pos < end_script) { //get everything in between the script tags
	                    content = this.input.substring(this.pos, end_script);
	                    this.pos = end_script;
	                }
	                return content;
	            };

	            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
	                if (this.tags[tag + 'count']) { //check for the existence of this tag type
	                    this.tags[tag + 'count']++;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                } else { //otherwise initialize this tag type
	                    this.tags[tag + 'count'] = 1;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                }
	                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
	                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
	            };

	            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
	                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
	                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
	                    while (temp_parent) { //till we reach '' (the initial value);
	                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
	                            break;
	                        }
	                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
	                    }
	                    if (temp_parent) { //if we caught something
	                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
	                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
	                    }
	                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
	                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
	                    if (this.tags[tag + 'count'] === 1) {
	                        delete this.tags[tag + 'count'];
	                    } else {
	                        this.tags[tag + 'count']--;
	                    }
	                }
	            };

	            this.indent_to_tag = function(tag) {
	                // Match the indentation level to the last use of this tag, but don't remove it.
	                if (!this.tags[tag + 'count']) {
	                    return;
	                }
	                var temp_parent = this.tags.parent;
	                while (temp_parent) {
	                    if (tag + this.tags[tag + 'count'] === temp_parent) {
	                        break;
	                    }
	                    temp_parent = this.tags[temp_parent + 'parent'];
	                }
	                if (temp_parent) {
	                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
	                }
	            };

	            this.get_tag = function(peek) { //function to get a full tag and parse its type
	                var input_char = '',
	                    content = [],
	                    comment = '',
	                    space = false,
	                    first_attr = true,
	                    has_wrapped_attrs = false,
	                    tag_start, tag_end,
	                    tag_start_char,
	                    orig_pos = this.pos,
	                    orig_line_char_count = this.line_char_count,
	                    is_tag_closed = false,
	                    tail;

	                peek = peek !== undefined ? peek : false;

	                do {
	                    if (this.pos >= this.input.length) {
	                        if (peek) {
	                            this.pos = orig_pos;
	                            this.line_char_count = orig_line_char_count;
	                        }
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
	                        space = true;
	                        continue;
	                    }

	                    if (input_char === "'" || input_char === '"') {
	                        input_char += this.get_unformatted(input_char);
	                        space = true;
	                    }

	                    if (input_char === '=') { //no space before =
	                        space = false;
	                    }
	                    tail = this.input.substr(this.pos - 1);
	                    if (is_wrap_attributes_force_expand_multiline && has_wrapped_attrs && !is_tag_closed && (input_char === '>' || input_char === '/')) {
	                        if (tail.match(/^\/?\s*>/)) {
	                            space = false;
	                            is_tag_closed = true;
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        }
	                    }
	                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
	                        //no space after = or before >
	                        var wrapped = this.space_or_wrap(content);
	                        var indentAttrs = wrapped && input_char !== '/' && !is_wrap_attributes_force;
	                        space = false;

	                        if (is_wrap_attributes_force && input_char !== '/') {
	                            var force_first_attr_wrap = false;
	                            if (is_wrap_attributes_force_expand_multiline && first_attr) {
	                                var is_only_attribute = tail.match(/^\S*(="([^"]|\\")*")?\s*\/?\s*>/) !== null;
	                                force_first_attr_wrap = !is_only_attribute;
	                            }
	                            if (!first_attr || force_first_attr_wrap) {
	                                this.print_newline(false, content);
	                                this.print_indentation(content);
	                                indentAttrs = true;
	                            }
	                        }
	                        if (indentAttrs) {
	                            has_wrapped_attrs = true;

	                            //indent attributes an auto, forced, or forced-align line-wrap
	                            var alignment_size = wrap_attributes_indent_size;
	                            if (is_wrap_attributes_force_aligned) {
	                                alignment_size = content.indexOf(' ') + 1;
	                            }

	                            for (var count = 0; count < alignment_size; count++) {
	                                // only ever further indent with spaces since we're trying to align characters
	                                content.push(' ');
	                            }
	                        }
	                        if (first_attr) {
	                            for (var i = 0; i < content.length; i++) {
	                                if (content[i] === ' ') {
	                                    first_attr = false;
	                                    break;
	                                }
	                            }
	                        }
	                    }

	                    if (indent_handlebars && tag_start_char === '<') {
	                        // When inside an angle-bracket tag, put spaces around
	                        // handlebars not inside of strings.
	                        if ((input_char + this.input.charAt(this.pos)) === '{{') {
	                            input_char += this.get_unformatted('}}');
	                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
	                                input_char = ' ' + input_char;
	                            }
	                            space = true;
	                        }
	                    }

	                    if (input_char === '<' && !tag_start_char) {
	                        tag_start = this.pos - 1;
	                        tag_start_char = '<';
	                    }

	                    if (indent_handlebars && !tag_start_char) {
	                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
	                            if (input_char === '#' || input_char === '/' || input_char === '!') {
	                                tag_start = this.pos - 3;
	                            } else {
	                                tag_start = this.pos - 2;
	                            }
	                            tag_start_char = '{';
	                        }
	                    }

	                    this.line_char_count++;
	                    content.push(input_char); //inserts character at-a-time (or string)

	                    if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
	                        break;
	                    }
	                } while (input_char !== '>');

	                var tag_complete = content.join('');
	                var tag_index;
	                var tag_offset;

	                // must check for space first otherwise the tag could have the first attribute included, and
	                // then not un-indent correctly
	                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
	                    tag_index = tag_complete.indexOf(' ');
	                } else if (tag_complete.indexOf('\n') !== -1) { //if there's a line break, thats where the tag name ends
	                    tag_index = tag_complete.indexOf('\n');
	                } else if (tag_complete.charAt(0) === '{') {
	                    tag_index = tag_complete.indexOf('}');
	                } else { //otherwise go with the tag ending
	                    tag_index = tag_complete.indexOf('>');
	                }
	                if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
	                    tag_offset = 1;
	                } else {
	                    tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
	                }
	                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
	                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
	                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                    }
	                } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
	                    if (!peek) {
	                        this.indent_to_tag('if');
	                        this.tag_type = 'HANDLEBARS_ELSE';
	                        this.indent_content = true;
	                        this.traverse_whitespace();
	                    }
	                } else if (this.is_unformatted(tag_check, unformatted) ||
	                    this.is_unformatted(tag_check, content_unformatted)) {
	                    // do not reformat the "unformatted" or "content_unformatted" tags
	                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
	                    content.push(comment);
	                    tag_end = this.pos - 1;
	                    this.tag_type = 'SINGLE';
	                } else if (tag_check === 'script' &&
	                    (tag_complete.search('type') === -1 ||
	                        (tag_complete.search('type') > -1 &&
	                            tag_complete.search(/\b(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'SCRIPT';
	                    }
	                } else if (tag_check === 'style' &&
	                    (tag_complete.search('type') === -1 ||
	                        (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'STYLE';
	                    }
	                } else if (tag_check.charAt(0) === '!') { //peek for <! comment
	                    // for comments content is already correct.
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                        this.traverse_whitespace();
	                    }
	                } else if (!peek) {
	                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
	                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
	                        this.tag_type = 'END';
	                    } else { //otherwise it's a start-tag
	                        this.record_tag(tag_check); //push it on the tag stack
	                        if (tag_check.toLowerCase() !== 'html') {
	                            this.indent_content = true;
	                        }
	                        this.tag_type = 'START';
	                    }

	                    // Allow preserving of newlines after a start or end tag
	                    if (this.traverse_whitespace()) {
	                        this.space_or_wrap(content);
	                    }

	                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
	                        this.print_newline(false, this.output);
	                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
	                            this.print_newline(true, this.output);
	                        }
	                    }
	                }

	                if (peek) {
	                    this.pos = orig_pos;
	                    this.line_char_count = orig_line_char_count;
	                }

	                return content.join(''); //returns fully formatted tag
	            };

	            this.get_comment = function(start_pos) { //function to return comment content in its entirety
	                // this is will have very poor perf, but will work for now.
	                var comment = '',
	                    delimiter = '>',
	                    matched = false;

	                this.pos = start_pos;
	                var input_char = this.input.charAt(this.pos);
	                this.pos++;

	                while (this.pos <= this.input.length) {
	                    comment += input_char;

	                    // only need to check for the delimiter if the last chars match
	                    if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
	                        comment.indexOf(delimiter) !== -1) {
	                        break;
	                    }

	                    // only need to search for custom delimiter for the first few characters
	                    if (!matched && comment.length < 10) {
	                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
	                            delimiter = '<![endif]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
	                            delimiter = ']]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
	                            delimiter = ']>';
	                            matched = true;
	                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
	                            delimiter = '-->';
	                            matched = true;
	                        } else if (comment.indexOf('{{!--') === 0) { // {{!-- handlebars comment
	                            delimiter = '--}}';
	                            matched = true;
	                        } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
	                            if (comment.length === 5 && comment.indexOf('{{!--') === -1) {
	                                delimiter = '}}';
	                                matched = true;
	                            }
	                        } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
	                            delimiter = '?>';
	                            matched = true;
	                        } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
	                            delimiter = '%>';
	                            matched = true;
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                }

	                return comment;
	            };

	            function tokenMatcher(delimiter) {
	                var token = '';

	                var add = function(str) {
	                    var newToken = token + str.toLowerCase();
	                    token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);
	                };

	                var doesNotMatch = function() {
	                    return token.indexOf(delimiter) === -1;
	                };

	                return {
	                    add: add,
	                    doesNotMatch: doesNotMatch
	                };
	            }

	            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety
	                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
	                    return '';
	                }
	                var input_char = '';
	                var content = '';
	                var space = true;

	                var delimiterMatcher = tokenMatcher(delimiter);

	                do {

	                    if (this.pos >= this.input.length) {
	                        return content;
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (!space) {
	                            this.line_char_count--;
	                            continue;
	                        }
	                        if (input_char === '\n' || input_char === '\r') {
	                            content += '\n';
	                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
	                for (var i=0; i<this.indent_level; i++) {
	                  content += this.indent_string;
	                }
	                space = false; //...and make sure other indentation is erased
	                */
	                            this.line_char_count = 0;
	                            continue;
	                        }
	                    }
	                    content += input_char;
	                    delimiterMatcher.add(input_char);
	                    this.line_char_count++;
	                    space = true;

	                    if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
	                        // Handlebars expressions in strings should also be unformatted.
	                        content += this.get_unformatted('}}');
	                        // Don't consider when stopping for delimiters.
	                    }
	                } while (delimiterMatcher.doesNotMatch());

	                return content;
	            };

	            this.get_token = function() { //initial handler for token-retrieval
	                var token;

	                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
	                    var type = this.last_token.substr(7);
	                    token = this.get_contents_to(type);
	                    if (typeof token !== 'string') {
	                        return token;
	                    }
	                    return [token, 'TK_' + type];
	                }
	                if (this.current_mode === 'CONTENT') {
	                    token = this.get_content();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        return [token, 'TK_CONTENT'];
	                    }
	                }

	                if (this.current_mode === 'TAG') {
	                    token = this.get_tag();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        var tag_name_type = 'TK_TAG_' + this.tag_type;
	                        return [token, tag_name_type];
	                    }
	                }
	            };

	            this.get_full_indent = function(level) {
	                level = this.indent_level + level || 0;
	                if (level < 1) {
	                    return '';
	                }

	                return Array(level + 1).join(this.indent_string);
	            };

	            this.is_unformatted = function(tag_check, unformatted) {
	                //is this an HTML5 block-level link?
	                if (!this.Utils.in_array(tag_check, unformatted)) {
	                    return false;
	                }

	                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
	                    return true;
	                }

	                //at this point we have an  tag; is its first child something we want to remain
	                //unformatted?
	                var next_tag = this.get_tag(true /* peek. */ );

	                // test next_tag to see if it is just html tag (no external content)
	                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

	                // if next_tag comes back but is not an isolated tag, then
	                // let's treat the 'a' tag as having content
	                // and respect the unformatted option
	                if (!tag || this.Utils.in_array(tag[1], unformatted)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            };

	            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

	                this.input = js_source || ''; //gets the input for the Parser

	                // HACK: newline parsing inconsistent. This brute force normalizes the input.
	                this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n');

	                this.output = [];
	                this.indent_character = indent_character;
	                this.indent_string = '';
	                this.indent_size = indent_size;
	                this.brace_style = brace_style;
	                this.indent_level = 0;
	                this.wrap_line_length = wrap_line_length;
	                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

	                for (var i = 0; i < this.indent_size; i++) {
	                    this.indent_string += this.indent_character;
	                }

	                this.print_newline = function(force, arr) {
	                    this.line_char_count = 0;
	                    if (!arr || !arr.length) {
	                        return;
	                    }
	                    if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
	                        if ((arr[arr.length - 1] !== '\n')) {
	                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
	                        }
	                        arr.push('\n');
	                    }
	                };

	                this.print_indentation = function(arr) {
	                    for (var i = 0; i < this.indent_level; i++) {
	                        arr.push(this.indent_string);
	                        this.line_char_count += this.indent_string.length;
	                    }
	                };

	                this.print_token = function(text) {
	                    // Avoid printing initial whitespace.
	                    if (this.is_whitespace(text) && !this.output.length) {
	                        return;
	                    }
	                    if (text || text !== '') {
	                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
	                            this.print_indentation(this.output);
	                            text = ltrim(text);
	                        }
	                    }
	                    this.print_token_raw(text);
	                };

	                this.print_token_raw = function(text) {
	                    // If we are going to print newlines, truncate trailing
	                    // whitespace, as the newlines will represent the space.
	                    if (this.newlines > 0) {
	                        text = rtrim(text);
	                    }

	                    if (text && text !== '') {
	                        if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
	                            // unformatted tags can grab newlines as their last character
	                            this.output.push(text.slice(0, -1));
	                            this.print_newline(false, this.output);
	                        } else {
	                            this.output.push(text);
	                        }
	                    }

	                    for (var n = 0; n < this.newlines; n++) {
	                        this.print_newline(n > 0, this.output);
	                    }
	                    this.newlines = 0;
	                };

	                this.indent = function() {
	                    this.indent_level++;
	                };

	                this.unindent = function() {
	                    if (this.indent_level > 0) {
	                        this.indent_level--;
	                    }
	                };
	            };
	            return this;
	        }

	        /*_____________________--------------------_____________________*/

	        multi_parser = new Parser(); //wrapping functions Parser
	        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

	        while (true) {
	            var t = multi_parser.get_token();
	            multi_parser.token_text = t[0];
	            multi_parser.token_type = t[1];

	            if (multi_parser.token_type === 'TK_EOF') {
	                break;
	            }

	            switch (multi_parser.token_type) {
	                case 'TK_TAG_START':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) &&
	                            (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {

	                            multi_parser.indent();
	                        }

	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_STYLE':
	                case 'TK_TAG_SCRIPT':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_END':
	                    //Print new line only if the tag has no content and has child
	                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
	                        var tag_name = (multi_parser.token_text.match(/\w+/) || [])[0];
	                        var tag_extracted_from_last_output = null;
	                        if (multi_parser.output.length) {
	                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
	                        }
	                        if (tag_extracted_from_last_output === null ||
	                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_SINGLE':
	                    // Don't add a newline before elements that should remain unformatted.
	                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
	                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_ELSE':
	                    // Don't add a newline if opening {{#if}} tag is on the current line
	                    var foundIfOnCurrentLine = false;
	                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
	                        if (multi_parser.output[lastCheckedOutput] === '\n') {
	                            break;
	                        } else {
	                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {
	                                foundIfOnCurrentLine = true;
	                                break;
	                            }
	                        }
	                    }
	                    if (!foundIfOnCurrentLine) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_COMMENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_CONTENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_STYLE':
	                case 'TK_SCRIPT':
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_newline(false, multi_parser.output);
	                        var text = multi_parser.token_text,
	                            _beautifier,
	                            script_indent_level = 1;
	                        if (multi_parser.token_type === 'TK_SCRIPT') {
	                            _beautifier = typeof js_beautify === 'function' && js_beautify;
	                        } else if (multi_parser.token_type === 'TK_STYLE') {
	                            _beautifier = typeof css_beautify === 'function' && css_beautify;
	                        }

	                        if (options.indent_scripts === "keep") {
	                            script_indent_level = 0;
	                        } else if (options.indent_scripts === "separate") {
	                            script_indent_level = -multi_parser.indent_level;
	                        }

	                        var indentation = multi_parser.get_full_indent(script_indent_level);
	                        if (_beautifier) {

	                            // call the Beautifier if avaliable
	                            var Child_options = function() {
	                                this.eol = '\n';
	                            };
	                            Child_options.prototype = options;
	                            var child_options = new Child_options();
	                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
	                        } else {
	                            // simply indent the string otherwise
	                            var white = text.match(/^\s*/)[0];
	                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
	                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
	                            text = text.replace(/^\s*/, indentation)
	                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
	                                .replace(/\s+$/, '');
	                        }
	                        if (text) {
	                            multi_parser.print_token_raw(text);
	                            multi_parser.print_newline(true, multi_parser.output);
	                        }
	                    }
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                default:
	                    // We should not be getting here but we don't want to drop input on the floor
	                    // Just output the text and move on
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_token(multi_parser.token_text);
	                    }
	                    break;
	            }
	            multi_parser.last_token = multi_parser.token_type;
	            multi_parser.last_text = multi_parser.token_text;
	        }
	        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

	        // establish end_with_newline
	        if (end_with_newline) {
	            sweet_code += '\n';
	        }

	        if (eol !== '\n') {
	            sweet_code = sweet_code.replace(/[\n]/g, eol);
	        }

	        return sweet_code;
	    }

	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(33), __webpack_require__(34)], __WEBPACK_AMD_DEFINE_RESULT__ = function(requireamd) {
	            var js_beautify = __webpack_require__(33);
	            var css_beautify = __webpack_require__(34);

	            return {
	                html_beautify: function(html_source, options) {
	                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
	                }
	            };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
	        var js_beautify = require('./beautify.js');
	        var css_beautify = require('./beautify-css.js');

	        exports.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
	        };
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, window.js_beautify, window.css_beautify);
	        };
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, global.js_beautify, global.css_beautify);
	        };
	    }

	}());

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Toggle = function (_React$Component) {
	  _inherits(Toggle, _React$Component);

	  function Toggle(props) {
	    _classCallCheck(this, Toggle);

	    var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, props));

	    _this._handleChange = function () {
	      _this.setState({ checked: !_this.state.checked }, function () {
	        _this.props.onChange(_this.state.checked);
	      });
	    };

	    _this.state = {
	      checked: _this.props.defaultValue
	    };
	    return _this;
	  }

	  _createClass(Toggle, [{
	    key: 'render',
	    value: function render() {
	      var className = (0, _classnames2.default)('atellier-toggle', this.props.className, { 'atellier-toggle-checked': this.state.checked });
	      return _react2.default.createElement('div', { className: className, onClick: this._handleChange });
	    }
	  }]);

	  return Toggle;
	}(_react2.default.Component);

	Toggle.propTypes = {
	  defaultValue: _react.PropTypes.bool,
	  onChange: _react.PropTypes.func
	};
	Toggle.defaultProps = {
	  defaultValue: false,
	  onChange: _react.PropTypes.func
	};
	exports.default = Toggle;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

	var DocCommentHighlightRules = function() {
	    this.$rules = {
	        "start" : [ {
	            token : "comment.doc.tag",
	            regex : "@[\\w\\d_]+" // TODO: fix email addresses
	        }, 
	        DocCommentHighlightRules.getTagRule(),
	        {
	            defaultToken : "comment.doc",
	            caseInsensitive: true
	        }]
	    };
	};

	oop.inherits(DocCommentHighlightRules, TextHighlightRules);

	DocCommentHighlightRules.getTagRule = function(start) {
	    return {
	        token : "comment.doc.tag.storage.type",
	        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
	    };
	}

	DocCommentHighlightRules.getStartRule = function(start) {
	    return {
	        token : "comment.doc", // doc comment
	        regex : "\\/\\*(?=\\*)",
	        next  : start
	    };
	};

	DocCommentHighlightRules.getEndRule = function (start) {
	    return {
	        token : "comment.doc", // closing comment
	        regex : "\\*\\/",
	        next  : start
	    };
	};


	exports.DocCommentHighlightRules = DocCommentHighlightRules;

	});

	ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";

	var JavaScriptHighlightRules = function(options) {
	    var keywordMapper = this.createKeywordMapper({
	        "variable.language":
	            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
	            "Namespace|QName|XML|XMLList|"                                             + // E4X
	            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
	            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
	            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
	            "SyntaxError|TypeError|URIError|"                                          +
	            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
	            "isNaN|parseFloat|parseInt|"                                               +
	            "JSON|Math|"                                                               + // Other
	            "this|arguments|prototype|window|document"                                 , // Pseudo
	        "keyword":
	            "const|yield|import|get|set|" +
	            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
	            "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
	            "__parent__|__count__|escape|unescape|with|__proto__|" +
	            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
	        "storage.type":
	            "const|let|var|function",
	        "constant.language":
	            "null|Infinity|NaN|undefined",
	        "support.function":
	            "alert",
	        "constant.language.boolean": "true|false"
	    }, "identifier");
	    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

	    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
	        "u[0-9a-fA-F]{4}|" + // unicode
	        "[0-2][0-7]{0,2}|" + // oct
	        "3[0-6][0-7]?|" + // oct
	        "37[0-7]?|" + // oct
	        "[4-7][0-7]?|" + //oct
	        ".)";

	    this.$rules = {
	        "no_regex" : [
	            {
	                token : "comment",
	                regex : "\\/\\/",
	                next : "line_comment"
	            },
	            DocCommentHighlightRules.getStartRule("doc-start"),
	            {
	                token : "comment", // multi line comment
	                regex : /\/\*/,
	                next : "comment"
	            }, {
	                token : "string",
	                regex : "'(?=.)",
	                next  : "qstring"
	            }, {
	                token : "string",
	                regex : '"(?=.)',
	                next  : "qqstring"
	            }, {
	                token : "constant.numeric", // hex
	                regex : /0[xX][0-9a-fA-F]+\b/
	            }, {
	                token : "constant.numeric", // float
	                regex : /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "support.function",
	                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
	                    "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text",
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "entity.name.function", "text", "punctuation.operator",
	                    "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : [
	                    "text", "text", "storage.type", "text", "paren.lparen"
	                ],
	                regex : "(:)(\\s*)(function)(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : "keyword",
	                regex : "(?:" + kwBeforeRe + ")\\b",
	                next : "start"
	            }, {
	                token : ["support.constant"],
	                regex : /that\b/
	            }, {
	                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
	                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
	            }, {
	                token : keywordMapper,
	                regex : identifierRe
	            }, {
	                token : "punctuation.operator",
	                regex : /[.](?![.])/,
	                next  : "property"
	            }, {
	                token : "keyword.operator",
	                regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
	                next  : "start"
	            }, {
	                token : "punctuation.operator",
	                regex : /[?:,;.]/,
	                next  : "start"
	            }, {
	                token : "paren.lparen",
	                regex : /[\[({]/,
	                next  : "start"
	            }, {
	                token : "paren.rparen",
	                regex : /[\])}]/
	            }, {
	                token: "comment",
	                regex: /^#!.*$/
	            }
	        ],
	        property: [{
	                token : "text",
	                regex : "\\s+"
	            }, {
	                token : [
	                    "storage.type", "punctuation.operator", "entity.name.function", "text",
	                    "keyword.operator", "text",
	                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
	                ],
	                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
	                next: "function_arguments"
	            }, {
	                token : "punctuation.operator",
	                regex : /[.](?![.])/
	            }, {
	                token : "support.function",
	                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
	            }, {
	                token : "support.function.dom",
	                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
	            }, {
	                token :  "support.constant",
	                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
	            }, {
	                token : "identifier",
	                regex : identifierRe
	            }, {
	                regex: "",
	                token: "empty",
	                next: "no_regex"
	            }
	        ],
	        "start": [
	            DocCommentHighlightRules.getStartRule("doc-start"),
	            {
	                token : "comment", // multi line comment
	                regex : "\\/\\*",
	                next : "comment_regex_allowed"
	            }, {
	                token : "comment",
	                regex : "\\/\\/",
	                next : "line_comment_regex_allowed"
	            }, {
	                token: "string.regexp",
	                regex: "\\/",
	                next: "regex"
	            }, {
	                token : "text",
	                regex : "\\s+|^$",
	                next : "start"
	            }, {
	                token: "empty",
	                regex: "",
	                next: "no_regex"
	            }
	        ],
	        "regex": [
	            {
	                token: "regexp.keyword.operator",
	                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
	            }, {
	                token: "string.regexp",
	                regex: "/[sxngimy]*",
	                next: "no_regex"
	            }, {
	                token : "invalid",
	                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
	            }, {
	                token : "constant.language.escape",
	                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
	            }, {
	                token : "constant.language.delimiter",
	                regex: /\|/
	            }, {
	                token: "constant.language.escape",
	                regex: /\[\^?/,
	                next: "regex_character_class"
	            }, {
	                token: "empty",
	                regex: "$",
	                next: "no_regex"
	            }, {
	                defaultToken: "string.regexp"
	            }
	        ],
	        "regex_character_class": [
	            {
	                token: "regexp.charclass.keyword.operator",
	                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
	            }, {
	                token: "constant.language.escape",
	                regex: "]",
	                next: "regex"
	            }, {
	                token: "constant.language.escape",
	                regex: "-"
	            }, {
	                token: "empty",
	                regex: "$",
	                next: "no_regex"
	            }, {
	                defaultToken: "string.regexp.charachterclass"
	            }
	        ],
	        "function_arguments": [
	            {
	                token: "variable.parameter",
	                regex: identifierRe
	            }, {
	                token: "punctuation.operator",
	                regex: "[, ]+"
	            }, {
	                token: "punctuation.operator",
	                regex: "$"
	            }, {
	                token: "empty",
	                regex: "",
	                next: "no_regex"
	            }
	        ],
	        "comment_regex_allowed" : [
	            DocCommentHighlightRules.getTagRule(),
	            {token : "comment", regex : "\\*\\/", next : "start"},
	            {defaultToken : "comment", caseInsensitive: true}
	        ],
	        "comment" : [
	            DocCommentHighlightRules.getTagRule(),
	            {token : "comment", regex : "\\*\\/", next : "no_regex"},
	            {defaultToken : "comment", caseInsensitive: true}
	        ],
	        "line_comment_regex_allowed" : [
	            DocCommentHighlightRules.getTagRule(),
	            {token : "comment", regex : "$|^", next : "start"},
	            {defaultToken : "comment", caseInsensitive: true}
	        ],
	        "line_comment" : [
	            DocCommentHighlightRules.getTagRule(),
	            {token : "comment", regex : "$|^", next : "no_regex"},
	            {defaultToken : "comment", caseInsensitive: true}
	        ],
	        "qqstring" : [
	            {
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "string",
	                regex : "\\\\$",
	                next  : "qqstring"
	            }, {
	                token : "string",
	                regex : '"|$',
	                next  : "no_regex"
	            }, {
	                defaultToken: "string"
	            }
	        ],
	        "qstring" : [
	            {
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "string",
	                regex : "\\\\$",
	                next  : "qstring"
	            }, {
	                token : "string",
	                regex : "'|$",
	                next  : "no_regex"
	            }, {
	                defaultToken: "string"
	            }
	        ]
	    };
	    
	    
	    if (!options || !options.noES6) {
	        this.$rules.no_regex.unshift({
	            regex: "[{}]", onMatch: function(val, state, stack) {
	                this.next = val == "{" ? this.nextState : "";
	                if (val == "{" && stack.length) {
	                    stack.unshift("start", state);
	                    return "paren";
	                }
	                if (val == "}" && stack.length) {
	                    stack.shift();
	                    this.next = stack.shift();
	                    if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
	                        return "paren.quasi.end";
	                }
	                return val == "{" ? "paren.lparen" : "paren.rparen";
	            },
	            nextState: "start"
	        }, {
	            token : "string.quasi.start",
	            regex : /`/,
	            push  : [{
	                token : "constant.language.escape",
	                regex : escapedRe
	            }, {
	                token : "paren.quasi.start",
	                regex : /\${/,
	                push  : "start"
	            }, {
	                token : "string.quasi.end",
	                regex : /`/,
	                next  : "pop"
	            }, {
	                defaultToken: "string.quasi"
	            }]
	        });
	        
	        if (!options || !options.noJSX)
	            JSX.call(this);
	    }
	    
	    this.embedRules(DocCommentHighlightRules, "doc-",
	        [ DocCommentHighlightRules.getEndRule("no_regex") ]);
	    
	    this.normalizeRules();
	};

	oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

	function JSX() {
	    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
	    var jsxTag = {
	        onMatch : function(val, state, stack) {
	            var offset = val.charAt(1) == "/" ? 2 : 1;
	            if (offset == 1) {
	                if (state != this.nextState)
	                    stack.unshift(this.next, this.nextState, 0);
	                else
	                    stack.unshift(this.next);
	                stack[2]++;
	            } else if (offset == 2) {
	                if (state == this.nextState) {
	                    stack[1]--;
	                    if (!stack[1] || stack[1] < 0) {
	                        stack.shift();
	                        stack.shift();
	                    }
	                }
	            }
	            return [{
	                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
	                value: val.slice(0, offset)
	            }, {
	                type: "meta.tag.tag-name.xml",
	                value: val.substr(offset)
	            }];
	        },
	        regex : "</?" + tagRegex + "",
	        next: "jsxAttributes",
	        nextState: "jsx"
	    };
	    this.$rules.start.unshift(jsxTag);
	    var jsxJsRule = {
	        regex: "{",
	        token: "paren.quasi.start",
	        push: "start"
	    };
	    this.$rules.jsx = [
	        jsxJsRule,
	        jsxTag,
	        {include : "reference"},
	        {defaultToken: "string"}
	    ];
	    this.$rules.jsxAttributes = [{
	        token : "meta.tag.punctuation.tag-close.xml", 
	        regex : "/?>", 
	        onMatch : function(value, currentState, stack) {
	            if (currentState == stack[0])
	                stack.shift();
	            if (value.length == 2) {
	                if (stack[0] == this.nextState)
	                    stack[1]--;
	                if (!stack[1] || stack[1] < 0) {
	                    stack.splice(0, 2);
	                }
	            }
	            this.next = stack[0] || "start";
	            return [{type: this.token, value: value}];
	        },
	        nextState: "jsx"
	    }, 
	    jsxJsRule,
	    {
	        token : "entity.other.attribute-name.xml",
	        regex : tagRegex
	    }, {
	        token : "keyword.operator.attribute-equals.xml",
	        regex : "="
	    }, {
	        token : "text.tag-whitespace.xml",
	        regex : "\\s+"
	    }, {
	        token : "string.attribute-value.xml",
	        regex : "'",
	        stateName : "jsx_attr_q",
	        push : [
	            {token : "string.attribute-value.xml", regex: "'", next: "pop"},
	            jsxJsRule,
	            {include : "reference"},
	            {defaultToken : "string.attribute-value.xml"}
	        ]
	    }, {
	        token : "string.attribute-value.xml",
	        regex : '"',
	        stateName : "jsx_attr_qq",
	        push : [
	            jsxJsRule,
	            {token : "string.attribute-value.xml", regex: '"', next: "pop"},
	            {include : "reference"},
	            {defaultToken : "string.attribute-value.xml"}
	        ]
	    }];
	    this.$rules.reference = [{
	        token : "constant.language.escape.reference.xml",
	        regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
	    }];
	}

	exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
	});

	ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;

	var MatchingBraceOutdent = function() {};

	(function() {

	    this.checkOutdent = function(line, input) {
	        if (! /^\s+$/.test(line))
	            return false;

	        return /^\s*\}/.test(input);
	    };

	    this.autoOutdent = function(doc, row) {
	        var line = doc.getLine(row);
	        var match = line.match(/^(\s*\})/);

	        if (!match) return 0;

	        var column = match[1].length;
	        var openBracePos = doc.findMatchingBracket({row: row, column: column});

	        if (!openBracePos || openBracePos.row == row) return 0;

	        var indent = this.$getIndent(doc.getLine(openBracePos.row));
	        doc.replace(new Range(row, 0, row, column-1), indent);
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	}).call(MatchingBraceOutdent.prototype);

	exports.MatchingBraceOutdent = MatchingBraceOutdent;
	});

	ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;
	var lang = acequire("../../lib/lang");

	var SAFE_INSERT_IN_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator"];
	var SAFE_INSERT_BEFORE_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator", "comment"];

	var context;
	var contextCache = {};
	var initContext = function(editor) {
	    var id = -1;
	    if (editor.multiSelect) {
	        id = editor.selection.index;
	        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
	            contextCache = {rangeCount: editor.multiSelect.rangeCount};
	    }
	    if (contextCache[id])
	        return context = contextCache[id];
	    context = contextCache[id] = {
	        autoInsertedBrackets: 0,
	        autoInsertedRow: -1,
	        autoInsertedLineEnd: "",
	        maybeInsertedBrackets: 0,
	        maybeInsertedRow: -1,
	        maybeInsertedLineStart: "",
	        maybeInsertedLineEnd: ""
	    };
	};

	var getWrapped = function(selection, selected, opening, closing) {
	    var rowDiff = selection.end.row - selection.start.row;
	    return {
	        text: opening + selected + closing,
	        selection: [
	                0,
	                selection.start.column + 1,
	                rowDiff,
	                selection.end.column + (rowDiff ? 0 : 1)
	            ]
	    };
	};

	var CstyleBehaviour = function() {
	    this.add("braces", "insertion", function(state, action, editor, session, text) {
	        var cursor = editor.getCursorPosition();
	        var line = session.doc.getLine(cursor.row);
	        if (text == '{') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '{', '}');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
	                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                    return {
	                        text: '{}',
	                        selection: [1, 1]
	                    };
	                } else {
	                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
	                    return {
	                        text: '{',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == '}') {
	            initContext(editor);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == '}') {
	                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == "\n" || text == "\r\n") {
	            initContext(editor);
	            var closing = "";
	            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
	                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
	                CstyleBehaviour.clearMaybeInsertedClosing();
	            }
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === '}') {
	                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
	                if (!openBracePos)
	                     return null;
	                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
	            } else if (closing) {
	                var next_indent = this.$getIndent(line);
	            } else {
	                CstyleBehaviour.clearMaybeInsertedClosing();
	                return;
	            }
	            var indent = next_indent + session.getTabString();

	            return {
	                text: '\n' + indent + '\n' + next_indent + closing,
	                selection: [1, indent.length, 1, indent.length]
	            };
	        } else {
	            CstyleBehaviour.clearMaybeInsertedClosing();
	        }
	    });

	    this.add("braces", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '{') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.end.column, range.end.column + 1);
	            if (rightChar == '}') {
	                range.end.column++;
	                return range;
	            } else {
	                context.maybeInsertedBrackets--;
	            }
	        }
	    });

	    this.add("parens", "insertion", function(state, action, editor, session, text) {
	        if (text == '(') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '(', ')');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, ")");
	                return {
	                    text: '()',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ')') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ')') {
	                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("parens", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '(') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ')') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("brackets", "insertion", function(state, action, editor, session, text) {
	        if (text == '[') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '[', ']');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, "]");
	                return {
	                    text: '[]',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ']') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ']') {
	                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("brackets", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '[') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ']') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
	        if (text == '"' || text == "'") {
	            initContext(editor);
	            var quote = text;
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, quote, quote);
	            } else if (!selected) {
	                var cursor = editor.getCursorPosition();
	                var line = session.doc.getLine(cursor.row);
	                var leftChar = line.substring(cursor.column-1, cursor.column);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);
	                
	                var token = session.getTokenAt(cursor.row, cursor.column);
	                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
	                if (leftChar == "\\" && token && /escape/.test(token.type))
	                    return null;
	                
	                var stringBefore = token && /string|escape/.test(token.type);
	                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
	                
	                var pair;
	                if (rightChar == quote) {
	                    pair = stringBefore !== stringAfter;
	                } else {
	                    if (stringBefore && !stringAfter)
	                        return null; // wrap string with different quote
	                    if (stringBefore && stringAfter)
	                        return null; // do not pair quotes inside strings
	                    var wordRe = session.$mode.tokenRe;
	                    wordRe.lastIndex = 0;
	                    var isWordBefore = wordRe.test(leftChar);
	                    wordRe.lastIndex = 0;
	                    var isWordAfter = wordRe.test(leftChar);
	                    if (isWordBefore || isWordAfter)
	                        return null; // before or after alphanumeric
	                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
	                        return null; // there is rightChar and it isn't closing
	                    pair = true;
	                }
	                return {
	                    text: pair ? quote + quote : "",
	                    selection: [1,1]
	                };
	            }
	        }
	    });

	    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	};

	    
	CstyleBehaviour.isSaneInsertion = function(editor, session) {
	    var cursor = editor.getCursorPosition();
	    var iterator = new TokenIterator(session, cursor.row, cursor.column);
	    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
	        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
	        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
	            return false;
	    }
	    iterator.stepForward();
	    return iterator.getCurrentTokenRow() !== cursor.row ||
	        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
	};

	CstyleBehaviour.$matchTokenType = function(token, types) {
	    return types.indexOf(token.type || token) > -1;
	};

	CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
	        context.autoInsertedBrackets = 0;
	    context.autoInsertedRow = cursor.row;
	    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
	    context.autoInsertedBrackets++;
	};

	CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isMaybeInsertedClosing(cursor, line))
	        context.maybeInsertedBrackets = 0;
	    context.maybeInsertedRow = cursor.row;
	    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
	    context.maybeInsertedLineEnd = line.substr(cursor.column);
	    context.maybeInsertedBrackets++;
	};

	CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
	    return context.autoInsertedBrackets > 0 &&
	        cursor.row === context.autoInsertedRow &&
	        bracket === context.autoInsertedLineEnd[0] &&
	        line.substr(cursor.column) === context.autoInsertedLineEnd;
	};

	CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
	    return context.maybeInsertedBrackets > 0 &&
	        cursor.row === context.maybeInsertedRow &&
	        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
	        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
	};

	CstyleBehaviour.popAutoInsertedClosing = function() {
	    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
	    context.autoInsertedBrackets--;
	};

	CstyleBehaviour.clearMaybeInsertedClosing = function() {
	    if (context) {
	        context.maybeInsertedBrackets = 0;
	        context.maybeInsertedRow = -1;
	    }
	};



	oop.inherits(CstyleBehaviour, Behaviour);

	exports.CstyleBehaviour = CstyleBehaviour;
	});

	ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Range = acequire("../../range").Range;
	var BaseFoldMode = acequire("./fold_mode").FoldMode;

	var FoldMode = exports.FoldMode = function(commentRegex) {
	    if (commentRegex) {
	        this.foldingStartMarker = new RegExp(
	            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
	        );
	        this.foldingStopMarker = new RegExp(
	            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
	        );
	    }
	};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {
	    
	    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
	    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
	    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
	    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
	    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
	    this._getFoldWidgetBase = this.getFoldWidget;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	    
	        if (this.singleLineBlockCommentRe.test(line)) {
	            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
	                return "";
	        }
	    
	        var fw = this._getFoldWidgetBase(session, foldStyle, row);
	    
	        if (!fw && this.startRegionRe.test(line))
	            return "start"; // lineCommentRegionStart
	    
	        return fw;
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
	        var line = session.getLine(row);
	        
	        if (this.startRegionRe.test(line))
	            return this.getCommentRegionBlock(session, line, row);
	        
	        var match = line.match(this.foldingStartMarker);
	        if (match) {
	            var i = match.index;

	            if (match[1])
	                return this.openingBracketBlock(session, match[1], row, i);
	                
	            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
	            
	            if (range && !range.isMultiLine()) {
	                if (forceMultiline) {
	                    range = this.getSectionRange(session, row);
	                } else if (foldStyle != "all")
	                    range = null;
	            }
	            
	            return range;
	        }

	        if (foldStyle === "markbegin")
	            return;

	        var match = line.match(this.foldingStopMarker);
	        if (match) {
	            var i = match.index + match[0].length;

	            if (match[1])
	                return this.closingBracketBlock(session, match[1], row, i);

	            return session.getCommentFoldRange(row, i, -1);
	        }
	    };
	    
	    this.getSectionRange = function(session, row) {
	        var line = session.getLine(row);
	        var startIndent = line.search(/\S/);
	        var startRow = row;
	        var startColumn = line.length;
	        row = row + 1;
	        var endRow = row;
	        var maxRow = session.getLength();
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var indent = line.search(/\S/);
	            if (indent === -1)
	                continue;
	            if  (startIndent > indent)
	                break;
	            var subRange = this.getFoldWidgetRange(session, "all", row);
	            
	            if (subRange) {
	                if (subRange.start.row <= startRow) {
	                    break;
	                } else if (subRange.isMultiLine()) {
	                    row = subRange.end.row;
	                } else if (startIndent == indent) {
	                    break;
	                }
	            }
	            endRow = row;
	        }
	        
	        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
	    };
	    this.getCommentRegionBlock = function(session, line, row) {
	        var startColumn = line.search(/\s*$/);
	        var maxRow = session.getLength();
	        var startRow = row;
	        
	        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
	        var depth = 1;
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var m = re.exec(line);
	            if (!m) continue;
	            if (m[1]) depth--;
	            else depth++;

	            if (!depth) break;
	        }

	        var endRow = row;
	        if (endRow > startRow) {
	            return new Range(startRow, startColumn, endRow, line.length);
	        }
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
	var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
	var Range = acequire("../range").Range;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;
	var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
	var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;

	var Mode = function() {
	    this.HighlightRules = JavaScriptHighlightRules;
	    
	    this.$outdent = new MatchingBraceOutdent();
	    this.$behaviour = new CstyleBehaviour();
	    this.foldingRules = new CStyleFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.lineCommentStart = "//";
	    this.blockComment = {start: "/*", end: "*/"};

	    this.getNextLineIndent = function(state, line, tab) {
	        var indent = this.$getIndent(line);

	        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
	        var tokens = tokenizedLine.tokens;
	        var endState = tokenizedLine.state;

	        if (tokens.length && tokens[tokens.length-1].type == "comment") {
	            return indent;
	        }

	        if (state == "start" || state == "no_regex") {
	            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
	            if (match) {
	                indent += tab;
	            }
	        } else if (state == "doc-start") {
	            if (endState == "start" || endState == "no_regex") {
	                return "";
	            }
	            var match = line.match(/^\s*(\/?)\*/);
	            if (match) {
	                if (match[1]) {
	                    indent += " ";
	                }
	                indent += "* ";
	            }
	        }

	        return indent;
	    };

	    this.checkOutdent = function(state, line, input) {
	        return this.$outdent.checkOutdent(line, input);
	    };

	    this.autoOutdent = function(state, doc, row) {
	        this.$outdent.autoOutdent(doc, row);
	    };

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(38), "JavaScriptWorker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("annotate", function(results) {
	            session.setAnnotations(results.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };

	    this.$id = "ace/mode/javascript";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	module.exports.id = 'ace/mode/javascript_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/javascript/jshint\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){module.exports=function outer(modules,cache,entry){function newRequire(name,jumped){if(!cache[name]){if(!modules[name]){var currentRequire=\"function\"==typeof acequire&&acequire;if(!jumped&&currentRequire)return currentRequire(name,!0);if(previousRequire)return previousRequire(name,!0);var err=Error(\"Cannot find module '\"+name+\"'\");throw err.code=\"MODULE_NOT_FOUND\",err}var m=cache[name]={exports:{}};modules[name][0].call(m.exports,function(x){var id=modules[name][1][x];return newRequire(id?id:x)},m,m.exports,outer,modules,cache,entry)}return cache[name].exports}for(var previousRequire=\"function\"==typeof acequire&&acequire,i=0;entry.length>i;i++)newRequire(entry[i]);return newRequire(entry[0])}({\"/node_modules/browserify/node_modules/events/events.js\":[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return\"function\"==typeof arg}function isNumber(arg){return\"number\"==typeof arg}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError(\"n must be a positive number\");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),\"error\"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length)){if(er=arguments[1],er instanceof Error)throw er;throw TypeError('Uncaught, unspecified \"error\" event.')}if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(this._events||(this._events={}),this._events.newListener&&this.emit(\"newListener\",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[type].length),\"function\"==typeof console.trace&&console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError(\"listener must be a function\");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit(\"removeListener\",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit(\"removeListener\",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)\"removeListener\"!==key&&this.removeAllListeners(key);return this.removeAllListeners(\"removeListener\"),this._events={},this\n}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}],\"/node_modules/jshint/data/ascii-identifier-data.js\":[function(_dereq_,module){for(var identifierStartTable=[],i=0;128>i;i++)identifierStartTable[i]=36===i||i>=65&&90>=i||95===i||i>=97&&122>=i;for(var identifierPartTable=[],i=0;128>i;i++)identifierPartTable[i]=identifierStartTable[i]||i>=48&&57>=i;module.exports={asciiIdentifierStartTable:identifierStartTable,asciiIdentifierPartTable:identifierPartTable}},{}],\"/node_modules/jshint/lodash.js\":[function(_dereq_,module,exports){(function(global){(function(){function baseFindIndex(array,predicate,fromRight){for(var length=array.length,index=fromRight?length:-1;fromRight?index--:length>++index;)if(predicate(array[index],index,array))return index;return-1}function baseIndexOf(array,value,fromIndex){if(value!==value)return indexOfNaN(array,fromIndex);for(var index=fromIndex-1,length=array.length;length>++index;)if(array[index]===value)return index;return-1}function baseIsFunction(value){return\"function\"==typeof value||!1}function baseToString(value){return\"string\"==typeof value?value:null==value?\"\":value+\"\"}function indexOfNaN(array,fromIndex,fromRight){for(var length=array.length,index=fromIndex+(fromRight?0:-1);fromRight?index--:length>++index;){var other=array[index];if(other!==other)return index}return-1}function isObjectLike(value){return!!value&&\"object\"==typeof value}function lodash(){}function arrayCopy(source,array){var index=-1,length=source.length;for(array||(array=Array(length));length>++index;)array[index]=source[index];return array}function arrayEach(array,iteratee){for(var index=-1,length=array.length;length>++index&&iteratee(array[index],index,array)!==!1;);return array}function arrayFilter(array,predicate){for(var index=-1,length=array.length,resIndex=-1,result=[];length>++index;){var value=array[index];predicate(value,index,array)&&(result[++resIndex]=value)}return result}function arrayMap(array,iteratee){for(var index=-1,length=array.length,result=Array(length);length>++index;)result[index]=iteratee(array[index],index,array);return result}function arrayMax(array){for(var index=-1,length=array.length,result=NEGATIVE_INFINITY;length>++index;){var value=array[index];value>result&&(result=value)}return result}function arraySome(array,predicate){for(var index=-1,length=array.length;length>++index;)if(predicate(array[index],index,array))return!0;return!1}function assignWith(object,source,customizer){var props=keys(source);push.apply(props,getSymbols(source));for(var index=-1,length=props.length;length>++index;){var key=props[index],value=object[key],result=customizer(value,source[key],key,object,source);(result===result?result===value:value!==value)&&(value!==undefined||key in object)||(object[key]=result)}return object}function baseCopy(source,props,object){object||(object={});for(var index=-1,length=props.length;length>++index;){var key=props[index];object[key]=source[key]}return object}function baseCallback(func,thisArg,argCount){var type=typeof func;return\"function\"==type?thisArg===undefined?func:bindCallback(func,thisArg,argCount):null==func?identity:\"object\"==type?baseMatches(func):thisArg===undefined?property(func):baseMatchesProperty(func,thisArg)}function baseClone(value,isDeep,customizer,key,object,stackA,stackB){var result;if(customizer&&(result=object?customizer(value,key,object):customizer(value)),result!==undefined)return result;if(!isObject(value))return value;var isArr=isArray(value);if(isArr){if(result=initCloneArray(value),!isDeep)return arrayCopy(value,result)}else{var tag=objToString.call(value),isFunc=tag==funcTag;if(tag!=objectTag&&tag!=argsTag&&(!isFunc||object))return cloneableTags[tag]?initCloneByTag(value,tag,isDeep):object?value:{};if(result=initCloneObject(isFunc?{}:value),!isDeep)return baseAssign(result,value)}stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==value)return stackB[length];return stackA.push(value),stackB.push(result),(isArr?arrayEach:baseForOwn)(value,function(subValue,key){result[key]=baseClone(subValue,isDeep,customizer,key,value,stackA,stackB)}),result}function baseFilter(collection,predicate){var result=[];return baseEach(collection,function(value,index,collection){predicate(value,index,collection)&&result.push(value)}),result}function baseForIn(object,iteratee){return baseFor(object,iteratee,keysIn)}function baseForOwn(object,iteratee){return baseFor(object,iteratee,keys)}function baseGet(object,path,pathKey){if(null!=object){pathKey!==undefined&&pathKey in toObject(object)&&(path=[pathKey]);for(var index=-1,length=path.length;null!=object&&length>++index;)var result=object=object[path[index]];return result}}function baseIsEqual(value,other,customizer,isLoose,stackA,stackB){if(value===other)return 0!==value||1/value==1/other;var valType=typeof value,othType=typeof other;return\"function\"!=valType&&\"object\"!=valType&&\"function\"!=othType&&\"object\"!=othType||null==value||null==other?value!==value&&other!==other:baseIsEqualDeep(value,other,baseIsEqual,customizer,isLoose,stackA,stackB)}function baseIsEqualDeep(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;objIsArr||(objTag=objToString.call(object),objTag==argsTag?objTag=objectTag:objTag!=objectTag&&(objIsArr=isTypedArray(object))),othIsArr||(othTag=objToString.call(other),othTag==argsTag?othTag=objectTag:othTag!=objectTag&&(othIsArr=isTypedArray(other)));var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&!objIsArr&&!objIsObj)return equalByTag(object,other,objTag);if(!isLoose){var valWrapped=objIsObj&&hasOwnProperty.call(object,\"__wrapped__\"),othWrapped=othIsObj&&hasOwnProperty.call(other,\"__wrapped__\");if(valWrapped||othWrapped)return equalFunc(valWrapped?object.value():object,othWrapped?other.value():other,customizer,isLoose,stackA,stackB)}if(!isSameTag)return!1;stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==object)return stackB[length]==other;stackA.push(object),stackB.push(other);var result=(objIsArr?equalArrays:equalObjects)(object,other,equalFunc,customizer,isLoose,stackA,stackB);return stackA.pop(),stackB.pop(),result}function baseIsMatch(object,props,values,strictCompareFlags,customizer){for(var index=-1,length=props.length,noCustomizer=!customizer;length>++index;)if(noCustomizer&&strictCompareFlags[index]?values[index]!==object[props[index]]:!(props[index]in object))return!1;for(index=-1;length>++index;){var key=props[index],objValue=object[key],srcValue=values[index];if(noCustomizer&&strictCompareFlags[index])var result=objValue!==undefined||key in object;else result=customizer?customizer(objValue,srcValue,key):undefined,result===undefined&&(result=baseIsEqual(srcValue,objValue,customizer,!0));if(!result)return!1}return!0}function baseMatches(source){var props=keys(source),length=props.length;if(!length)return constant(!0);if(1==length){var key=props[0],value=source[key];if(isStrictComparable(value))return function(object){return null==object?!1:object[key]===value&&(value!==undefined||key in toObject(object))}}for(var values=Array(length),strictCompareFlags=Array(length);length--;)value=source[props[length]],values[length]=value,strictCompareFlags[length]=isStrictComparable(value);return function(object){return null!=object&&baseIsMatch(toObject(object),props,values,strictCompareFlags)}}function baseMatchesProperty(path,value){var isArr=isArray(path),isCommon=isKey(path)&&isStrictComparable(value),pathKey=path+\"\";return path=toPath(path),function(object){if(null==object)return!1;var key=pathKey;if(object=toObject(object),!(!isArr&&isCommon||key in object)){if(object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),null==object)return!1;key=last(path),object=toObject(object)}return object[key]===value?value!==undefined||key in object:baseIsEqual(value,object[key],null,!0)}}function baseMerge(object,source,customizer,stackA,stackB){if(!isObject(object))return object;var isSrcArr=isLength(source.length)&&(isArray(source)||isTypedArray(source));if(!isSrcArr){var props=keys(source);push.apply(props,getSymbols(source))}return arrayEach(props||source,function(srcValue,key){if(props&&(key=srcValue,srcValue=source[key]),isObjectLike(srcValue))stackA||(stackA=[]),stackB||(stackB=[]),baseMergeDeep(object,source,key,baseMerge,customizer,stackA,stackB);else{var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue),!isSrcArr&&result===undefined||!isCommon&&(result===result?result===value:value!==value)||(object[key]=result)}}),object}function baseMergeDeep(object,source,key,mergeFunc,customizer,stackA,stackB){for(var length=stackA.length,srcValue=source[key];length--;)if(stackA[length]==srcValue)return object[key]=stackB[length],undefined;var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue,isLength(srcValue.length)&&(isArray(srcValue)||isTypedArray(srcValue))?result=isArray(value)?value:getLength(value)?arrayCopy(value):[]:isPlainObject(srcValue)||isArguments(srcValue)?result=isArguments(value)?toPlainObject(value):isPlainObject(value)?value:{}:isCommon=!1),stackA.push(srcValue),stackB.push(result),isCommon?object[key]=mergeFunc(result,srcValue,customizer,stackA,stackB):(result===result?result!==value:value===value)&&(object[key]=result)}function baseProperty(key){return function(object){return null==object?undefined:object[key]}}function basePropertyDeep(path){var pathKey=path+\"\";return path=toPath(path),function(object){return baseGet(object,path,pathKey)}}function baseSlice(array,start,end){var index=-1,length=array.length;start=null==start?0:+start||0,0>start&&(start=-start>length?0:length+start),end=end===undefined||end>length?length:+end||0,0>end&&(end+=length),length=start>end?0:end-start>>>0,start>>>=0;for(var result=Array(length);length>++index;)result[index]=array[index+start];return result}function baseSome(collection,predicate){var result;return baseEach(collection,function(value,index,collection){return result=predicate(value,index,collection),!result}),!!result}function baseValues(object,props){for(var index=-1,length=props.length,result=Array(length);length>++index;)result[index]=object[props[index]];return result}function binaryIndex(array,value,retHighest){var low=0,high=array?array.length:low;if(\"number\"==typeof value&&value===value&&HALF_MAX_ARRAY_LENGTH>=high){for(;high>low;){var mid=low+high>>>1,computed=array[mid];(retHighest?value>=computed:value>computed)?low=mid+1:high=mid}return high}return binaryIndexBy(array,value,identity,retHighest)}function binaryIndexBy(array,value,iteratee,retHighest){value=iteratee(value);for(var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsUndef=value===undefined;high>low;){var mid=floor((low+high)/2),computed=iteratee(array[mid]),isReflexive=computed===computed;if(valIsNaN)var setLow=isReflexive||retHighest;else setLow=valIsUndef?isReflexive&&(retHighest||computed!==undefined):retHighest?value>=computed:value>computed;setLow?low=mid+1:high=mid}return nativeMin(high,MAX_ARRAY_INDEX)}function bindCallback(func,thisArg,argCount){if(\"function\"!=typeof func)return identity;if(thisArg===undefined)return func;switch(argCount){case 1:return function(value){return func.call(thisArg,value)};case 3:return function(value,index,collection){return func.call(thisArg,value,index,collection)};case 4:return function(accumulator,value,index,collection){return func.call(thisArg,accumulator,value,index,collection)};case 5:return function(value,other,key,object,source){return func.call(thisArg,value,other,key,object,source)}}return function(){return func.apply(thisArg,arguments)}}function bufferClone(buffer){return bufferSlice.call(buffer,0)}function createAssigner(assigner){return restParam(function(object,sources){var index=-1,length=null==object?0:sources.length,customizer=length>2&&sources[length-2],guard=length>2&&sources[2],thisArg=length>1&&sources[length-1];for(\"function\"==typeof customizer?(customizer=bindCallback(customizer,thisArg,5),length-=2):(customizer=\"function\"==typeof thisArg?thisArg:null,length-=customizer?1:0),guard&&isIterateeCall(sources[0],sources[1],guard)&&(customizer=3>length?null:customizer,length=1);length>++index;){var source=sources[index];source&&assigner(object,source,customizer)}return object})}function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){var length=collection?getLength(collection):0;if(!isLength(length))return eachFunc(collection,iteratee);for(var index=fromRight?length:-1,iterable=toObject(collection);(fromRight?index--:length>++index)&&iteratee(iterable[index],index,iterable)!==!1;);return collection}}function createBaseFor(fromRight){return function(object,iteratee,keysFunc){for(var iterable=toObject(object),props=keysFunc(object),length=props.length,index=fromRight?length:-1;fromRight?index--:length>++index;){var key=props[index];if(iteratee(iterable[key],key,iterable)===!1)break}return object}}function createFindIndex(fromRight){return function(array,predicate,thisArg){return array&&array.length?(predicate=getCallback(predicate,thisArg,3),baseFindIndex(array,predicate,fromRight)):-1}}function createForEach(arrayFunc,eachFunc){return function(collection,iteratee,thisArg){return\"function\"==typeof iteratee&&thisArg===undefined&&isArray(collection)?arrayFunc(collection,iteratee):eachFunc(collection,bindCallback(iteratee,thisArg,3))}}function equalArrays(array,other,equalFunc,customizer,isLoose,stackA,stackB){var index=-1,arrLength=array.length,othLength=other.length,result=!0;if(arrLength!=othLength&&!(isLoose&&othLength>arrLength))return!1;for(;result&&arrLength>++index;){var arrValue=array[index],othValue=other[index];if(result=undefined,customizer&&(result=isLoose?customizer(othValue,arrValue,index):customizer(arrValue,othValue,index)),result===undefined)if(isLoose)for(var othIndex=othLength;othIndex--&&(othValue=other[othIndex],!(result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB))););else result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB)}return!!result}function equalByTag(object,other,tag){switch(tag){case boolTag:case dateTag:return+object==+other;case errorTag:return object.name==other.name&&object.message==other.message;case numberTag:return object!=+object?other!=+other:0==object?1/object==1/other:object==+other;case regexpTag:case stringTag:return object==other+\"\"}return!1}function equalObjects(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isLoose)return!1;for(var skipCtor=isLoose,index=-1;objLength>++index;){var key=objProps[index],result=isLoose?key in other:hasOwnProperty.call(other,key);if(result){var objValue=object[key],othValue=other[key];result=undefined,customizer&&(result=isLoose?customizer(othValue,objValue,key):customizer(objValue,othValue,key)),result===undefined&&(result=objValue&&objValue===othValue||equalFunc(objValue,othValue,customizer,isLoose,stackA,stackB))}if(!result)return!1;skipCtor||(skipCtor=\"constructor\"==key)}if(!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&\"constructor\"in object&&\"constructor\"in other&&!(\"function\"==typeof objCtor&&objCtor instanceof objCtor&&\"function\"==typeof othCtor&&othCtor instanceof othCtor))return!1}return!0}function getCallback(func,thisArg,argCount){var result=lodash.callback||callback;return result=result===callback?baseCallback:result,argCount?result(func,thisArg,argCount):result}function getIndexOf(collection,target,fromIndex){var result=lodash.indexOf||indexOf;return result=result===indexOf?baseIndexOf:result,collection?result(collection,target,fromIndex):result}function initCloneArray(array){var length=array.length,result=new array.constructor(length);return length&&\"string\"==typeof array[0]&&hasOwnProperty.call(array,\"index\")&&(result.index=array.index,result.input=array.input),result}function initCloneObject(object){var Ctor=object.constructor;return\"function\"==typeof Ctor&&Ctor instanceof Ctor||(Ctor=Object),new Ctor}function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return bufferClone(object);case boolTag:case dateTag:return new Ctor(+object);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:var buffer=object.buffer;return new Ctor(isDeep?bufferClone(buffer):buffer,object.byteOffset,object.length);case numberTag:case stringTag:return new Ctor(object);case regexpTag:var result=new Ctor(object.source,reFlags.exec(object));result.lastIndex=object.lastIndex}return result}function isIndex(value,length){return value=+value,length=null==length?MAX_SAFE_INTEGER:length,value>-1&&0==value%1&&length>value}function isIterateeCall(value,index,object){if(!isObject(object))return!1;var type=typeof index;if(\"number\"==type)var length=getLength(object),prereq=isLength(length)&&isIndex(index,length);else prereq=\"string\"==type&&index in object;if(prereq){var other=object[index];return value===value?value===other:other!==other}return!1}function isKey(value,object){var type=typeof value;if(\"string\"==type&&reIsPlainProp.test(value)||\"number\"==type)return!0;if(isArray(value))return!1;var result=!reIsDeepProp.test(value);return result||null!=object&&value in toObject(object)}function isLength(value){return\"number\"==typeof value&&value>-1&&0==value%1&&MAX_SAFE_INTEGER>=value}function isStrictComparable(value){return value===value&&(0===value?1/value>0:!isObject(value))}function shimIsPlainObject(value){var Ctor;if(lodash.support,!isObjectLike(value)||objToString.call(value)!=objectTag||!hasOwnProperty.call(value,\"constructor\")&&(Ctor=value.constructor,\"function\"==typeof Ctor&&!(Ctor instanceof Ctor)))return!1;var result;return baseForIn(value,function(subValue,key){result=key}),result===undefined||hasOwnProperty.call(value,result)}function shimKeys(object){for(var props=keysIn(object),propsLength=props.length,length=propsLength&&object.length,support=lodash.support,allowIndexes=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object)),index=-1,result=[];propsLength>++index;){var key=props[index];(allowIndexes&&isIndex(key,length)||hasOwnProperty.call(object,key))&&result.push(key)}return result}function toObject(value){return isObject(value)?value:Object(value)}function toPath(value){if(isArray(value))return value;var result=[];return baseToString(value).replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,\"$1\"):number||match)}),result}function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length)return-1;if(\"number\"==typeof fromIndex)fromIndex=0>fromIndex?nativeMax(length+fromIndex,0):fromIndex;else if(fromIndex){var index=binaryIndex(array,value),other=array[index];return(value===value?value===other:other!==other)?index:-1}return baseIndexOf(array,value,fromIndex||0)}function last(array){var length=array?array.length:0;return length?array[length-1]:undefined}function slice(array,start,end){var length=array?array.length:0;return length?(end&&\"number\"!=typeof end&&isIterateeCall(array,start,end)&&(start=0,end=length),baseSlice(array,start,end)):[]}function unzip(array){for(var index=-1,length=(array&&array.length&&arrayMax(arrayMap(array,getLength)))>>>0,result=Array(length);length>++index;)result[index]=arrayMap(array,baseProperty(index));return result}function includes(collection,target,fromIndex,guard){var length=collection?getLength(collection):0;return isLength(length)||(collection=values(collection),length=collection.length),length?(fromIndex=\"number\"!=typeof fromIndex||guard&&isIterateeCall(target,fromIndex,guard)?0:0>fromIndex?nativeMax(length+fromIndex,0):fromIndex||0,\"string\"==typeof collection||!isArray(collection)&&isString(collection)?length>fromIndex&&collection.indexOf(target,fromIndex)>-1:getIndexOf(collection,target,fromIndex)>-1):!1}function reject(collection,predicate,thisArg){var func=isArray(collection)?arrayFilter:baseFilter;return predicate=getCallback(predicate,thisArg,3),func(collection,function(value,index,collection){return!predicate(value,index,collection)})}function some(collection,predicate,thisArg){var func=isArray(collection)?arraySome:baseSome;return thisArg&&isIterateeCall(collection,predicate,thisArg)&&(predicate=null),(\"function\"!=typeof predicate||thisArg!==undefined)&&(predicate=getCallback(predicate,thisArg,3)),func(collection,predicate)}function restParam(func,start){if(\"function\"!=typeof func)throw new TypeError(FUNC_ERROR_TEXT);return start=nativeMax(start===undefined?func.length-1:+start||0,0),function(){for(var args=arguments,index=-1,length=nativeMax(args.length-start,0),rest=Array(length);length>++index;)rest[index]=args[start+index];switch(start){case 0:return func.call(this,rest);case 1:return func.call(this,args[0],rest);case 2:return func.call(this,args[0],args[1],rest)}var otherArgs=Array(start+1);for(index=-1;start>++index;)otherArgs[index]=args[index];return otherArgs[start]=rest,func.apply(this,otherArgs)}}function clone(value,isDeep,customizer,thisArg){return isDeep&&\"boolean\"!=typeof isDeep&&isIterateeCall(value,isDeep,customizer)?isDeep=!1:\"function\"==typeof isDeep&&(thisArg=customizer,customizer=isDeep,isDeep=!1),customizer=\"function\"==typeof customizer&&bindCallback(customizer,thisArg,1),baseClone(value,isDeep,customizer)}function isArguments(value){var length=isObjectLike(value)?value.length:undefined;return isLength(length)&&objToString.call(value)==argsTag}function isEmpty(value){if(null==value)return!0;var length=getLength(value);return isLength(length)&&(isArray(value)||isString(value)||isArguments(value)||isObjectLike(value)&&isFunction(value.splice))?!length:!keys(value).length}function isObject(value){var type=typeof value;return\"function\"==type||!!value&&\"object\"==type}function isNative(value){return null==value?!1:objToString.call(value)==funcTag?reIsNative.test(fnToString.call(value)):isObjectLike(value)&&reIsHostCtor.test(value)}function isNumber(value){return\"number\"==typeof value||isObjectLike(value)&&objToString.call(value)==numberTag}function isString(value){return\"string\"==typeof value||isObjectLike(value)&&objToString.call(value)==stringTag}function isTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objToString.call(value)]}function toPlainObject(value){return baseCopy(value,keysIn(value))}function has(object,path){if(null==object)return!1;var result=hasOwnProperty.call(object,path);return result||isKey(path)||(path=toPath(path),object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),path=last(path),result=null!=object&&hasOwnProperty.call(object,path)),result}function keysIn(object){if(null==object)return[];isObject(object)||(object=Object(object));var length=object.length;length=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object))&&length||0;for(var Ctor=object.constructor,index=-1,isProto=\"function\"==typeof Ctor&&Ctor.prototype===object,result=Array(length),skipIndexes=length>0;length>++index;)result[index]=index+\"\";for(var key in object)skipIndexes&&isIndex(key,length)||\"constructor\"==key&&(isProto||!hasOwnProperty.call(object,key))||result.push(key);return result}function values(object){return baseValues(object,keys(object))}function escapeRegExp(string){return string=baseToString(string),string&&reHasRegExpChars.test(string)?string.replace(reRegExpChars,\"\\\\$&\"):string}function callback(func,thisArg,guard){return guard&&isIterateeCall(func,thisArg,guard)&&(thisArg=null),baseCallback(func,thisArg)}function constant(value){return function(){return value}}function identity(value){return value}function property(path){return isKey(path)?baseProperty(path):basePropertyDeep(path)}var undefined,VERSION=\"3.7.0\",FUNC_ERROR_TEXT=\"Expected a function\",argsTag=\"[object Arguments]\",arrayTag=\"[object Array]\",boolTag=\"[object Boolean]\",dateTag=\"[object Date]\",errorTag=\"[object Error]\",funcTag=\"[object Function]\",mapTag=\"[object Map]\",numberTag=\"[object Number]\",objectTag=\"[object Object]\",regexpTag=\"[object RegExp]\",setTag=\"[object Set]\",stringTag=\"[object String]\",weakMapTag=\"[object WeakMap]\",arrayBufferTag=\"[object ArrayBuffer]\",float32Tag=\"[object Float32Array]\",float64Tag=\"[object Float64Array]\",int8Tag=\"[object Int8Array]\",int16Tag=\"[object Int16Array]\",int32Tag=\"[object Int32Array]\",uint8Tag=\"[object Uint8Array]\",uint8ClampedTag=\"[object Uint8ClampedArray]\",uint16Tag=\"[object Uint16Array]\",uint32Tag=\"[object Uint32Array]\",reIsDeepProp=/\\.|\\[(?:[^[\\]]+|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?)\\1\\]/,reIsPlainProp=/^\\w*$/,rePropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g,reRegExpChars=/[.*+?^${}()|[\\]\\/\\\\]/g,reHasRegExpChars=RegExp(reRegExpChars.source),reEscapeChar=/\\\\(\\\\)?/g,reFlags=/\\w*$/,reIsHostCtor=/^\\[object .+?Constructor\\]$/,typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[stringTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=!0,cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[mapTag]=cloneableTags[setTag]=cloneableTags[weakMapTag]=!1;var objectTypes={\"function\":!0,object:!0},freeExports=objectTypes[typeof exports]&&exports&&!exports.nodeType&&exports,freeModule=objectTypes[typeof module]&&module&&!module.nodeType&&module,freeGlobal=freeExports&&freeModule&&\"object\"==typeof global&&global&&global.Object&&global,freeSelf=objectTypes[typeof self]&&self&&self.Object&&self,freeWindow=objectTypes[typeof window]&&window&&window.Object&&window,moduleExports=freeModule&&freeModule.exports===freeExports&&freeExports,root=freeGlobal||freeWindow!==(this&&this.window)&&freeWindow||freeSelf||this,arrayProto=Array.prototype,objectProto=Object.prototype,fnToString=Function.prototype.toString,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString,reIsNative=RegExp(\"^\"+escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),ArrayBuffer=isNative(ArrayBuffer=root.ArrayBuffer)&&ArrayBuffer,bufferSlice=isNative(bufferSlice=ArrayBuffer&&new ArrayBuffer(0).slice)&&bufferSlice,floor=Math.floor,getOwnPropertySymbols=isNative(getOwnPropertySymbols=Object.getOwnPropertySymbols)&&getOwnPropertySymbols,getPrototypeOf=isNative(getPrototypeOf=Object.getPrototypeOf)&&getPrototypeOf,push=arrayProto.push,preventExtensions=isNative(Object.preventExtensions=Object.preventExtensions)&&preventExtensions,propertyIsEnumerable=objectProto.propertyIsEnumerable,Uint8Array=isNative(Uint8Array=root.Uint8Array)&&Uint8Array,Float64Array=function(){try{var func=isNative(func=root.Float64Array)&&func,result=new func(new ArrayBuffer(10),0,1)&&func}catch(e){}return result}(),nativeAssign=function(){var object={1:0},func=preventExtensions&&isNative(func=Object.assign)&&func;try{func(preventExtensions(object),\"xo\")}catch(e){}return!object[1]&&func}(),nativeIsArray=isNative(nativeIsArray=Array.isArray)&&nativeIsArray,nativeKeys=isNative(nativeKeys=Object.keys)&&nativeKeys,nativeMax=Math.max,nativeMin=Math.min,NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,MAX_ARRAY_LENGTH=Math.pow(2,32)-1,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1,FLOAT64_BYTES_PER_ELEMENT=Float64Array?Float64Array.BYTES_PER_ELEMENT:0,MAX_SAFE_INTEGER=Math.pow(2,53)-1,support=lodash.support={};(function(x){var Ctor=function(){this.x=x},props=[];Ctor.prototype={valueOf:x,y:x};for(var key in new Ctor)props.push(key);support.funcDecomp=/\\bthis\\b/.test(function(){return this}),support.funcNames=\"string\"==typeof Function.name;try{support.nonEnumArgs=!propertyIsEnumerable.call(arguments,1)}catch(e){support.nonEnumArgs=!0}})(1,0);var baseAssign=nativeAssign||function(object,source){return null==source?object:baseCopy(source,getSymbols(source),baseCopy(source,keys(source),object))},baseEach=createBaseEach(baseForOwn),baseFor=createBaseFor();bufferSlice||(bufferClone=ArrayBuffer&&Uint8Array?function(buffer){var byteLength=buffer.byteLength,floatLength=Float64Array?floor(byteLength/FLOAT64_BYTES_PER_ELEMENT):0,offset=floatLength*FLOAT64_BYTES_PER_ELEMENT,result=new ArrayBuffer(byteLength);if(floatLength){var view=new Float64Array(result,0,floatLength);view.set(new Float64Array(buffer,0,floatLength))}return byteLength!=offset&&(view=new Uint8Array(result,offset),view.set(new Uint8Array(buffer,offset))),result}:constant(null));var getLength=baseProperty(\"length\"),getSymbols=getOwnPropertySymbols?function(object){return getOwnPropertySymbols(toObject(object))}:constant([]),findLastIndex=createFindIndex(!0),zip=restParam(unzip),forEach=createForEach(arrayEach,baseEach),isArray=nativeIsArray||function(value){return isObjectLike(value)&&isLength(value.length)&&objToString.call(value)==arrayTag},isFunction=baseIsFunction(/x/)||Uint8Array&&!baseIsFunction(Uint8Array)?function(value){return objToString.call(value)==funcTag}:baseIsFunction,isPlainObject=getPrototypeOf?function(value){if(!value||objToString.call(value)!=objectTag)return!1;var valueOf=value.valueOf,objProto=isNative(valueOf)&&(objProto=getPrototypeOf(valueOf))&&getPrototypeOf(objProto);return objProto?value==objProto||getPrototypeOf(value)==objProto:shimIsPlainObject(value)}:shimIsPlainObject,assign=createAssigner(function(object,source,customizer){return customizer?assignWith(object,source,customizer):baseAssign(object,source)}),keys=nativeKeys?function(object){if(object)var Ctor=object.constructor,length=object.length;return\"function\"==typeof Ctor&&Ctor.prototype===object||\"function\"!=typeof object&&isLength(length)?shimKeys(object):isObject(object)?nativeKeys(object):[]}:shimKeys,merge=createAssigner(baseMerge);lodash.assign=assign,lodash.callback=callback,lodash.constant=constant,lodash.forEach=forEach,lodash.keys=keys,lodash.keysIn=keysIn,lodash.merge=merge,lodash.property=property,lodash.reject=reject,lodash.restParam=restParam,lodash.slice=slice,lodash.toPlainObject=toPlainObject,lodash.unzip=unzip,lodash.values=values,lodash.zip=zip,lodash.each=forEach,lodash.extend=assign,lodash.iteratee=callback,lodash.clone=clone,lodash.escapeRegExp=escapeRegExp,lodash.findLastIndex=findLastIndex,lodash.has=has,lodash.identity=identity,lodash.includes=includes,lodash.indexOf=indexOf,lodash.isArguments=isArguments,lodash.isArray=isArray,lodash.isEmpty=isEmpty,lodash.isFunction=isFunction,lodash.isNative=isNative,lodash.isNumber=isNumber,lodash.isObject=isObject,lodash.isPlainObject=isPlainObject,lodash.isString=isString,lodash.isTypedArray=isTypedArray,lodash.last=last,lodash.some=some,lodash.any=some,lodash.contains=includes,lodash.include=includes,lodash.VERSION=VERSION,freeExports&&freeModule?moduleExports?(freeModule.exports=lodash)._=lodash:freeExports._=lodash:root._=lodash\n}).call(this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],\"/node_modules/jshint/src/jshint.js\":[function(_dereq_,module,exports){var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),vars=_dereq_(\"./vars.js\"),messages=_dereq_(\"./messages.js\"),Lexer=_dereq_(\"./lex.js\").Lexer,reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,style=_dereq_(\"./style.js\"),options=_dereq_(\"./options.js\"),scopeManager=_dereq_(\"./scope-manager.js\"),JSHINT=function(){\"use strict\";function checkOption(name,t){return name=name.trim(),/^[+-]W\\d{3}$/g.test(name)?!0:-1!==options.validNames.indexOf(name)||\"jslint\"===t.type||_.has(options.removed,name)?!0:(error(\"E001\",t,name),!1)}function isString(obj){return\"[object String]\"===Object.prototype.toString.call(obj)}function isIdentifier(tkn,value){return tkn?tkn.identifier&&tkn.value===value?!0:!1:!1}function isReserved(token){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(token.isProperty)return!1}return!0}function supplant(str,data){return str.replace(/\\{([^{}]*)\\}/g,function(a,b){var r=data[b];return\"string\"==typeof r||\"number\"==typeof r?r:a})}function combine(dest,src){Object.keys(src).forEach(function(name){_.has(JSHINT.blacklist,name)||(dest[name]=src[name])})}function processenforceall(){if(state.option.enforceall){for(var enforceopt in options.bool.enforcing)void 0!==state.option[enforceopt]||options.noenforceall[enforceopt]||(state.option[enforceopt]=!0);for(var relaxopt in options.bool.relaxing)void 0===state.option[relaxopt]&&(state.option[relaxopt]=!1)}}function assume(){processenforceall(),state.option.esversion||state.option.moz||(state.option.esversion=state.option.es3?3:state.option.esnext?6:5),state.inES5()&&combine(predefined,vars.ecmaIdentifiers[5]),state.inES6()&&combine(predefined,vars.ecmaIdentifiers[6]),state.option.module&&(state.option.strict===!0&&(state.option.strict=\"global\"),state.inES6()||warning(\"W134\",state.tokens.next,\"module\",6)),state.option.couch&&combine(predefined,vars.couch),state.option.qunit&&combine(predefined,vars.qunit),state.option.rhino&&combine(predefined,vars.rhino),state.option.shelljs&&(combine(predefined,vars.shelljs),combine(predefined,vars.node)),state.option.typed&&combine(predefined,vars.typed),state.option.phantom&&(combine(predefined,vars.phantom),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.prototypejs&&combine(predefined,vars.prototypejs),state.option.node&&(combine(predefined,vars.node),combine(predefined,vars.typed),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.devel&&combine(predefined,vars.devel),state.option.dojo&&combine(predefined,vars.dojo),state.option.browser&&(combine(predefined,vars.browser),combine(predefined,vars.typed)),state.option.browserify&&(combine(predefined,vars.browser),combine(predefined,vars.typed),combine(predefined,vars.browserify),state.option.strict===!0&&(state.option.strict=\"global\")),state.option.nonstandard&&combine(predefined,vars.nonstandard),state.option.jasmine&&combine(predefined,vars.jasmine),state.option.jquery&&combine(predefined,vars.jquery),state.option.mootools&&combine(predefined,vars.mootools),state.option.worker&&combine(predefined,vars.worker),state.option.wsh&&combine(predefined,vars.wsh),state.option.globalstrict&&state.option.strict!==!1&&(state.option.strict=\"global\"),state.option.yui&&combine(predefined,vars.yui),state.option.mocha&&combine(predefined,vars.mocha)}function quit(code,line,chr){var percentage=Math.floor(100*(line/state.lines.length)),message=messages.errors[code].desc;throw{name:\"JSHintError\",line:line,character:chr,message:message+\" (\"+percentage+\"% scanned).\",raw:message,code:code}}function removeIgnoredMessages(){var ignored=state.ignoredLines;_.isEmpty(ignored)||(JSHINT.errors=_.reject(JSHINT.errors,function(err){return ignored[err.line]}))}function warning(code,t,a,b,c,d){var ch,l,w,msg;if(/^W\\d{3}$/.test(code)){if(state.ignored[code])return;msg=messages.warnings[code]}else/E\\d{3}/.test(code)?msg=messages.errors[code]:/I\\d{3}/.test(code)&&(msg=messages.info[code]);return t=t||state.tokens.next||{},\"(end)\"===t.id&&(t=state.tokens.curr),l=t.line||0,ch=t.from||0,w={id:\"(error)\",raw:msg.desc,code:msg.code,evidence:state.lines[l-1]||\"\",line:l,character:ch,scope:JSHINT.scope,a:a,b:b,c:c,d:d},w.reason=supplant(msg.desc,w),JSHINT.errors.push(w),removeIgnoredMessages(),JSHINT.errors.length>=state.option.maxerr&&quit(\"E043\",l,ch),w}function warningAt(m,l,ch,a,b,c,d){return warning(m,{line:l,from:ch},a,b,c,d)}function error(m,t,a,b,c,d){warning(m,t,a,b,c,d)}function errorAt(m,l,ch,a,b,c,d){return error(m,{line:l,from:ch},a,b,c,d)}function addInternalSrc(elem,src){var i;return i={id:\"(internal)\",elem:elem,value:src},JSHINT.internals.push(i),i}function doOption(){var nt=state.tokens.next,body=nt.body.match(/(-\\s+)?[^\\s,:]+(?:\\s*:\\s*(-\\s+)?[^\\s,]+)?/g)||[],predef={};if(\"globals\"===nt.type){body.forEach(function(g,idx){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(\"-\"===key||!key.length){if(idx>0&&idx===body.length-1)return;return error(\"E002\",nt),void 0}\"-\"===key.charAt(0)?(key=key.slice(1),val=!1,JSHINT.blacklist[key]=key,delete predefined[key]):predef[key]=\"true\"===val}),combine(predefined,predef);for(var key in predef)_.has(predef,key)&&(declared[key]=nt)}\"exported\"===nt.type&&body.forEach(function(e,idx){if(!e.length){if(idx>0&&idx===body.length-1)return;return error(\"E002\",nt),void 0}state.funct[\"(scope)\"].addExported(e)}),\"members\"===nt.type&&(membersOnly=membersOnly||{},body.forEach(function(m){var ch1=m.charAt(0),ch2=m.charAt(m.length-1);ch1!==ch2||'\"'!==ch1&&\"'\"!==ch1||(m=m.substr(1,m.length-2).replace('\\\\\"','\"')),membersOnly[m]=!1}));var numvals=[\"maxstatements\",\"maxparams\",\"maxdepth\",\"maxcomplexity\",\"maxerr\",\"maxlen\",\"indent\"];(\"jshint\"===nt.type||\"jslint\"===nt.type)&&(body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(checkOption(key,nt))if(numvals.indexOf(key)>=0)if(\"false\"!==val){if(val=+val,\"number\"!=typeof val||!isFinite(val)||0>=val||Math.floor(val)!==val)return error(\"E032\",nt,g[1].trim()),void 0;state.option[key]=val}else state.option[key]=\"indent\"===key?4:!1;else{if(\"validthis\"===key)return state.funct[\"(global)\"]?void error(\"E009\"):\"true\"!==val&&\"false\"!==val?void error(\"E002\",nt):(state.option.validthis=\"true\"===val,void 0);if(\"quotmark\"!==key)if(\"shadow\"!==key)if(\"unused\"!==key)if(\"latedef\"!==key)if(\"ignore\"!==key)if(\"strict\"!==key){\"module\"===key&&(hasParsedCode(state.funct)||error(\"E055\",state.tokens.next,\"module\"));var esversions={es3:3,es5:5,esnext:6};if(!_.has(esversions,key)){if(\"esversion\"===key){switch(val){case\"5\":state.inES5(!0)&&warning(\"I003\");case\"3\":case\"6\":state.option.moz=!1,state.option.esversion=+val;break;case\"2015\":state.option.moz=!1,state.option.esversion=6;break;default:error(\"E002\",nt)}return hasParsedCode(state.funct)||error(\"E055\",state.tokens.next,\"esversion\"),void 0}var match=/^([+-])(W\\d{3})$/g.exec(key);if(match)return state.ignored[match[2]]=\"-\"===match[1],void 0;var tn;return\"true\"===val||\"false\"===val?(\"jslint\"===nt.type?(tn=options.renamed[key]||key,state.option[tn]=\"true\"===val,void 0!==options.inverted[tn]&&(state.option[tn]=!state.option[tn])):state.option[key]=\"true\"===val,\"newcap\"===key&&(state.option[\"(explicitNewcap)\"]=!0),void 0):(error(\"E002\",nt),void 0)}switch(val){case\"true\":state.option.moz=!1,state.option.esversion=esversions[key];break;case\"false\":state.option.moz||(state.option.esversion=5);break;default:error(\"E002\",nt)}}else switch(val){case\"true\":state.option.strict=!0;break;case\"false\":state.option.strict=!1;break;case\"func\":case\"global\":case\"implied\":state.option.strict=val;break;default:error(\"E002\",nt)}else switch(val){case\"line\":state.ignoredLines[nt.line]=!0,removeIgnoredMessages();break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.latedef=!0;break;case\"false\":state.option.latedef=!1;break;case\"nofunc\":state.option.latedef=\"nofunc\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.unused=!0;break;case\"false\":state.option.unused=!1;break;case\"vars\":case\"strict\":state.option.unused=val;break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.shadow=!0;break;case\"outer\":state.option.shadow=\"outer\";break;case\"false\":case\"inner\":state.option.shadow=\"inner\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":case\"false\":state.option.quotmark=\"true\"===val;break;case\"double\":case\"single\":state.option.quotmark=val;break;default:error(\"E002\",nt)}}}),assume())}function peek(p){var t,i=p||0,j=lookahead.length;if(j>i)return lookahead[i];for(;i>=j;)t=lookahead[j],t||(t=lookahead[j]=lex.token()),j+=1;return t||\"(end)\"!==state.tokens.next.id?t:state.tokens.next}function peekIgnoreEOL(){var t,i=0;do t=peek(i++);while(\"(endline)\"===t.id);return t}function advance(id,t){switch(state.tokens.curr.id){case\"(number)\":\".\"===state.tokens.next.id&&warning(\"W005\",state.tokens.curr);break;case\"-\":(\"-\"===state.tokens.next.id||\"--\"===state.tokens.next.id)&&warning(\"W006\");break;case\"+\":(\"+\"===state.tokens.next.id||\"++\"===state.tokens.next.id)&&warning(\"W007\")}for(id&&state.tokens.next.id!==id&&(t?\"(end)\"===state.tokens.next.id?error(\"E019\",t,t.id):error(\"E020\",state.tokens.next,id,t.id,t.line,state.tokens.next.value):(\"(identifier)\"!==state.tokens.next.type||state.tokens.next.value!==id)&&warning(\"W116\",state.tokens.next,id,state.tokens.next.value)),state.tokens.prev=state.tokens.curr,state.tokens.curr=state.tokens.next;;){if(state.tokens.next=lookahead.shift()||lex.token(),state.tokens.next||quit(\"E041\",state.tokens.curr.line),\"(end)\"===state.tokens.next.id||\"(error)\"===state.tokens.next.id)return;if(state.tokens.next.check&&state.tokens.next.check(),state.tokens.next.isSpecial)\"falls through\"===state.tokens.next.type?state.tokens.curr.caseFallsThrough=!0:doOption();else if(\"(endline)\"!==state.tokens.next.id)break}}function isInfix(token){return token.infix||!token.identifier&&!token.template&&!!token.led}function isEndOfExpr(){var curr=state.tokens.curr,next=state.tokens.next;return\";\"===next.id||\"}\"===next.id||\":\"===next.id?!0:isInfix(next)===isInfix(curr)||\"yield\"===curr.id&&state.inMoz()?curr.line!==startLine(next):!1}function isBeginOfExpr(prev){return!prev.left&&\"unary\"!==prev.arity}function expression(rbp,initial){var left,isArray=!1,isObject=!1,isLetExpr=!1;state.nameStack.push(),initial||\"let\"!==state.tokens.next.value||\"(\"!==peek(0).value||(state.inMoz()||warning(\"W118\",state.tokens.next,\"let expressions\"),isLetExpr=!0,state.funct[\"(scope)\"].stack(),advance(\"let\"),advance(\"(\"),state.tokens.prev.fud(),advance(\")\")),\"(end)\"===state.tokens.next.id&&error(\"E006\",state.tokens.curr);var isDangerous=state.option.asi&&state.tokens.prev.line!==startLine(state.tokens.curr)&&_.contains([\"]\",\")\"],state.tokens.prev.id)&&_.contains([\"[\",\"(\"],state.tokens.curr.id);if(isDangerous&&warning(\"W014\",state.tokens.curr,state.tokens.curr.id),advance(),initial&&(state.funct[\"(verb)\"]=state.tokens.curr.value,state.tokens.curr.beginsStmt=!0),initial===!0&&state.tokens.curr.fud)left=state.tokens.curr.fud();else for(state.tokens.curr.nud?left=state.tokens.curr.nud():error(\"E030\",state.tokens.curr,state.tokens.curr.id);(state.tokens.next.lbp>rbp||\"(template)\"===state.tokens.next.type)&&!isEndOfExpr();)isArray=\"Array\"===state.tokens.curr.value,isObject=\"Object\"===state.tokens.curr.value,left&&(left.value||left.first&&left.first.value)&&(\"new\"!==left.value||left.first&&left.first.value&&\".\"===left.first.value)&&(isArray=!1,left.value!==state.tokens.curr.value&&(isObject=!1)),advance(),isArray&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W009\",state.tokens.curr),isObject&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W010\",state.tokens.curr),left&&state.tokens.curr.led?left=state.tokens.curr.led(left):error(\"E033\",state.tokens.curr,state.tokens.curr.id);return isLetExpr&&state.funct[\"(scope)\"].unstack(),state.nameStack.pop(),left}function startLine(token){return token.startLine||token.line}function nobreaknonadjacent(left,right){left=left||state.tokens.curr,right=right||state.tokens.next,state.option.laxbreak||left.line===startLine(right)||warning(\"W014\",right,right.value)}function nolinebreak(t){t=t||state.tokens.curr,t.line!==startLine(state.tokens.next)&&warning(\"E022\",t,t.value)}function nobreakcomma(left,right){left.line!==startLine(right)&&(state.option.laxcomma||(comma.first&&(warning(\"I001\"),comma.first=!1),warning(\"W014\",left,right.value)))}function comma(opts){if(opts=opts||{},opts.peek?nobreakcomma(state.tokens.prev,state.tokens.curr):(nobreakcomma(state.tokens.curr,state.tokens.next),advance(\",\")),state.tokens.next.identifier&&(!opts.property||!state.inES5()))switch(state.tokens.next.value){case\"break\":case\"case\":case\"catch\":case\"continue\":case\"default\":case\"do\":case\"else\":case\"finally\":case\"for\":case\"if\":case\"in\":case\"instanceof\":case\"return\":case\"switch\":case\"throw\":case\"try\":case\"var\":case\"let\":case\"while\":case\"with\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}if(\"(punctuator)\"===state.tokens.next.type)switch(state.tokens.next.value){case\"}\":case\"]\":case\",\":if(opts.allowTrailing)return!0;case\")\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}return!0}function symbol(s,p){var x=state.syntax[s];return x&&\"object\"==typeof x||(state.syntax[s]=x={id:s,lbp:p,value:s}),x}function delim(s){var x=symbol(s,0);return x.delim=!0,x}function stmt(s,f){var x=delim(s);return x.identifier=x.reserved=!0,x.fud=f,x}function blockstmt(s,f){var x=stmt(s,f);return x.block=!0,x}function reserveName(x){var c=x.id.charAt(0);return(c>=\"a\"&&\"z\">=c||c>=\"A\"&&\"Z\">=c)&&(x.identifier=x.reserved=!0),x}function prefix(s,f){var x=symbol(s,150);return reserveName(x),x.nud=\"function\"==typeof f?f:function(){return this.arity=\"unary\",this.right=expression(150),(\"++\"===this.id||\"--\"===this.id)&&(state.option.plusplus?warning(\"W016\",this,this.id):!this.right||this.right.identifier&&!isReserved(this.right)||\".\"===this.right.id||\"[\"===this.right.id||warning(\"W017\",this),this.right&&this.right.isMetaProperty?error(\"E031\",this):this.right&&this.right.identifier&&state.funct[\"(scope)\"].block.modify(this.right.value,this)),this},x}function type(s,f){var x=delim(s);return x.type=s,x.nud=f,x}function reserve(name,func){var x=type(name,func);return x.identifier=!0,x.reserved=!0,x}function FutureReservedWord(name,meta){var x=type(name,meta&&meta.nud||function(){return this});return meta=meta||{},meta.isFutureReservedWord=!0,x.value=name,x.identifier=!0,x.reserved=!0,x.meta=meta,x}function reservevar(s,v){return reserve(s,function(){return\"function\"==typeof v&&v(this),this})}function infix(s,f,p,w){var x=symbol(s,p);return reserveName(x),x.infix=!0,x.led=function(left){return w||nobreaknonadjacent(state.tokens.prev,state.tokens.curr),\"in\"!==s&&\"instanceof\"!==s||\"!\"!==left.id||warning(\"W018\",left,\"!\"),\"function\"==typeof f?f(left,this):(this.left=left,this.right=expression(p),this)},x}function application(s){var x=symbol(s,42);return x.led=function(left){return nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left,this.right=doFunction({type:\"arrow\",loneArg:left}),this},x}function relation(s,f){var x=symbol(s,100);return x.led=function(left){nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left;var right=this.right=expression(100);return isIdentifier(left,\"NaN\")||isIdentifier(right,\"NaN\")?warning(\"W019\",this):f&&f.apply(this,[left,right]),left&&right||quit(\"E041\",state.tokens.curr.line),\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"!\"===right.id&&warning(\"W018\",right,\"!\"),this},x}function isPoorRelation(node){return node&&(\"(number)\"===node.type&&0===+node.value||\"(string)\"===node.type&&\"\"===node.value||\"null\"===node.type&&!state.option.eqnull||\"true\"===node.type||\"false\"===node.type||\"undefined\"===node.type)}function isTypoTypeof(left,right,state){var values;return state.option.notypeof?!1:left&&right?(values=state.inES6()?typeofValues.es6:typeofValues.es3,\"(identifier)\"===right.type&&\"typeof\"===right.value&&\"(string)\"===left.type?!_.contains(values,left.value):!1):!1}function isGlobalEval(left,state){var isGlobal=!1;return\"this\"===left.type&&null===state.funct[\"(context)\"]?isGlobal=!0:\"(identifier)\"===left.type&&(state.option.node&&\"global\"===left.value?isGlobal=!0:!state.option.browser||\"window\"!==left.value&&\"document\"!==left.value||(isGlobal=!0)),isGlobal}function findNativePrototype(left){function walkPrototype(obj){return\"object\"==typeof obj?\"prototype\"===obj.right?obj:walkPrototype(obj.left):void 0}function walkNative(obj){for(;!obj.identifier&&\"object\"==typeof obj.left;)obj=obj.left;return obj.identifier&&natives.indexOf(obj.value)>=0?obj.value:void 0}var natives=[\"Array\",\"ArrayBuffer\",\"Boolean\",\"Collator\",\"DataView\",\"Date\",\"DateTimeFormat\",\"Error\",\"EvalError\",\"Float32Array\",\"Float64Array\",\"Function\",\"Infinity\",\"Intl\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Iterator\",\"Number\",\"NumberFormat\",\"Object\",\"RangeError\",\"ReferenceError\",\"RegExp\",\"StopIteration\",\"String\",\"SyntaxError\",\"TypeError\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"URIError\"],prototype=walkPrototype(left);return prototype?walkNative(prototype):void 0}function checkLeftSideAssign(left,assignToken,options){var allowDestructuring=options&&options.allowDestructuring;if(assignToken=assignToken||left,state.option.freeze){var nativeObject=findNativePrototype(left);nativeObject&&warning(\"W121\",left,nativeObject)}return left.identifier&&!left.isMetaProperty&&state.funct[\"(scope)\"].block.reassign(left.value,left),\".\"===left.id?((!left.left||\"arguments\"===left.left.value&&!state.isStrict())&&warning(\"E031\",assignToken),state.nameStack.set(state.tokens.prev),!0):\"{\"===left.id||\"[\"===left.id?(allowDestructuring&&state.tokens.curr.left.destructAssign?state.tokens.curr.left.destructAssign.forEach(function(t){t.id&&state.funct[\"(scope)\"].block.modify(t.id,t.token)}):\"{\"!==left.id&&left.left?\"arguments\"!==left.left.value||state.isStrict()||warning(\"E031\",assignToken):warning(\"E031\",assignToken),\"[\"===left.id&&state.nameStack.set(left.right),!0):left.isMetaProperty?(error(\"E031\",assignToken),!0):left.identifier&&!isReserved(left)?(\"exception\"===state.funct[\"(scope)\"].labeltype(left.value)&&warning(\"W022\",left),state.nameStack.set(left),!0):(left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr),!1)}function assignop(s,f,p){var x=infix(s,\"function\"==typeof f?f:function(left,that){return that.left=left,left&&checkLeftSideAssign(left,that,{allowDestructuring:!0})?(that.right=expression(10),that):(error(\"E031\",that),void 0)},p);return x.exps=!0,x.assign=!0,x}function bitwise(s,f,p){var x=symbol(s,p);return reserveName(x),x.led=\"function\"==typeof f?f:function(left){return state.option.bitwise&&warning(\"W016\",this,this.id),this.left=left,this.right=expression(p),this},x}function bitwiseassignop(s){return assignop(s,function(left,that){return state.option.bitwise&&warning(\"W016\",that,that.id),left&&checkLeftSideAssign(left,that)?(that.right=expression(10),that):(error(\"E031\",that),void 0)},20)}function suffix(s){var x=symbol(s,150);return x.led=function(left){return state.option.plusplus?warning(\"W016\",this,this.id):left.identifier&&!isReserved(left)||\".\"===left.id||\"[\"===left.id||warning(\"W017\",this),left.isMetaProperty?error(\"E031\",this):left&&left.identifier&&state.funct[\"(scope)\"].block.modify(left.value,left),this.left=left,this},x}function optionalidentifier(fnparam,prop,preserve){if(state.tokens.next.identifier){preserve||advance();var curr=state.tokens.curr,val=state.tokens.curr.value;return isReserved(curr)?prop&&state.inES5()?val:fnparam&&\"undefined\"===val?val:(warning(\"W024\",state.tokens.curr,state.tokens.curr.id),val):val}}function identifier(fnparam,prop){var i=optionalidentifier(fnparam,prop,!1);if(i)return i;if(\"...\"===state.tokens.next.value){if(state.inES6(!0)||warning(\"W119\",state.tokens.next,\"spread/rest operator\",\"6\"),advance(),checkPunctuator(state.tokens.next,\"...\"))for(warning(\"E024\",state.tokens.next,\"...\");checkPunctuator(state.tokens.next,\"...\");)advance();return state.tokens.next.identifier?identifier(fnparam,prop):(warning(\"E024\",state.tokens.curr,\"...\"),void 0)}error(\"E030\",state.tokens.next,state.tokens.next.value),\";\"!==state.tokens.next.id&&advance()}function reachable(controlToken){var t,i=0;if(\";\"===state.tokens.next.id&&!controlToken.inBracelessBlock)for(;;){do t=peek(i),i+=1;while(\"(end)\"!==t.id&&\"(comment)\"===t.id);if(t.reach)return;if(\"(endline)\"!==t.id){if(\"function\"===t.id){state.option.latedef===!0&&warning(\"W026\",t);break}warning(\"W027\",t,t.value,controlToken.value);break}}}function parseFinalSemicolon(){if(\";\"!==state.tokens.next.id){if(state.tokens.next.isUnclosed)return advance();var sameLine=startLine(state.tokens.next)===state.tokens.curr.line&&\"(end)\"!==state.tokens.next.id,blockEnd=checkPunctuator(state.tokens.next,\"}\");sameLine&&!blockEnd?errorAt(\"E058\",state.tokens.curr.line,state.tokens.curr.character):state.option.asi||(blockEnd&&!state.option.lastsemic||!sameLine)&&warningAt(\"W033\",state.tokens.curr.line,state.tokens.curr.character)}else advance(\";\")}function statement(){var r,i=indent,t=state.tokens.next,hasOwnScope=!1;if(\";\"===t.id)return advance(\";\"),void 0;var res=isReserved(t);if(res&&t.meta&&t.meta.isFutureReservedWord&&\":\"===peek().id&&(warning(\"W024\",t,t.id),res=!1),t.identifier&&!res&&\":\"===peek().id&&(advance(),advance(\":\"),hasOwnScope=!0,state.funct[\"(scope)\"].stack(),state.funct[\"(scope)\"].block.addBreakLabel(t.value,{token:state.tokens.curr}),state.tokens.next.labelled||\"{\"===state.tokens.next.value||warning(\"W028\",state.tokens.next,t.value,state.tokens.next.value),state.tokens.next.label=t.value,t=state.tokens.next),\"{\"===t.id){var iscase=\"case\"===state.funct[\"(verb)\"]&&\":\"===state.tokens.curr.value;return block(!0,!0,!1,!1,iscase),void 0}return r=expression(0,!0),!r||r.identifier&&\"function\"===r.value||\"(punctuator)\"===r.type&&r.left&&r.left.identifier&&\"function\"===r.left.value||state.isStrict()||\"global\"!==state.option.strict||warning(\"E007\"),t.block||(state.option.expr||r&&r.exps?state.option.nonew&&r&&r.left&&\"(\"===r.id&&\"new\"===r.left.id&&warning(\"W031\",t):warning(\"W030\",state.tokens.curr),parseFinalSemicolon()),indent=i,hasOwnScope&&state.funct[\"(scope)\"].unstack(),r}function statements(){for(var p,a=[];!state.tokens.next.reach&&\"(end)\"!==state.tokens.next.id;)\";\"===state.tokens.next.id?(p=peek(),(!p||\"(\"!==p.id&&\"[\"!==p.id)&&warning(\"W032\"),advance(\";\")):a.push(statement());return a}function directives(){for(var i,p,pn;\"(string)\"===state.tokens.next.id;){if(p=peek(0),\"(endline)\"===p.id){i=1;do pn=peek(i++);while(\"(endline)\"===pn.id);if(\";\"===pn.id)p=pn;else{if(\"[\"===pn.value||\".\"===pn.value)break;state.option.asi&&\"(\"!==pn.value||warning(\"W033\",state.tokens.next)}}else{if(\".\"===p.id||\"[\"===p.id)break;\";\"!==p.id&&warning(\"W033\",p)}advance();var directive=state.tokens.curr.value;(state.directive[directive]||\"use strict\"===directive&&\"implied\"===state.option.strict)&&warning(\"W034\",state.tokens.curr,directive),state.directive[directive]=!0,\";\"===p.id&&advance(\";\")}state.isStrict()&&(state.option[\"(explicitNewcap)\"]||(state.option.newcap=!0),state.option.undef=!0)}function block(ordinary,stmt,isfunc,isfatarrow,iscase){var a,m,t,line,d,b=inblock,old_indent=indent;inblock=ordinary,t=state.tokens.next;var metrics=state.funct[\"(metrics)\"];if(metrics.nestedBlockDepth+=1,metrics.verifyMaxNestedBlockDepthPerFunction(),\"{\"===state.tokens.next.id){if(advance(\"{\"),state.funct[\"(scope)\"].stack(),line=state.tokens.curr.line,\"}\"!==state.tokens.next.id){for(indent+=state.option.indent;!ordinary&&state.tokens.next.from>indent;)indent+=state.option.indent;if(isfunc){m={};for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);directives(),state.option.strict&&state.funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.isStrict()||warning(\"E007\"))}a=statements(),metrics.statementCount+=a.length,indent-=state.option.indent}advance(\"}\",t),isfunc&&(state.funct[\"(scope)\"].validateParams(),m&&(state.directive=m)),state.funct[\"(scope)\"].unstack(),indent=old_indent}else if(ordinary)state.funct[\"(noblockscopedvar)\"]=\"for\"!==state.tokens.next.id,state.funct[\"(scope)\"].stack(),(!stmt||state.option.curly)&&warning(\"W116\",state.tokens.next,\"{\",state.tokens.next.value),state.tokens.next.inBracelessBlock=!0,indent+=state.option.indent,a=[statement()],indent-=state.option.indent,state.funct[\"(scope)\"].unstack(),delete state.funct[\"(noblockscopedvar)\"];else if(isfunc){if(state.funct[\"(scope)\"].stack(),m={},!stmt||isfatarrow||state.inMoz()||error(\"W118\",state.tokens.curr,\"function closure expressions\"),!stmt)for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);expression(10),state.option.strict&&state.funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.isStrict()||warning(\"E007\")),state.funct[\"(scope)\"].unstack()}else error(\"E021\",state.tokens.next,\"{\",state.tokens.next.value);switch(state.funct[\"(verb)\"]){case\"break\":case\"continue\":case\"return\":case\"throw\":if(iscase)break;default:state.funct[\"(verb)\"]=null}return inblock=b,!ordinary||!state.option.noempty||a&&0!==a.length||warning(\"W035\",state.tokens.prev),metrics.nestedBlockDepth-=1,a}function countMember(m){membersOnly&&\"boolean\"!=typeof membersOnly[m]&&warning(\"W036\",state.tokens.curr,m),\"number\"==typeof member[m]?member[m]+=1:member[m]=1}function comprehensiveArrayExpression(){var res={};res.exps=!0,state.funct[\"(comparray)\"].stack();var reversed=!1;return\"for\"!==state.tokens.next.value&&(reversed=!0,state.inMoz()||warning(\"W116\",state.tokens.next,\"for\",state.tokens.next.value),state.funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"for\"),\"each\"===state.tokens.next.value&&(advance(\"each\"),state.inMoz()||warning(\"W118\",state.tokens.curr,\"for each\")),advance(\"(\"),state.funct[\"(comparray)\"].setState(\"define\"),res.left=expression(130),_.contains([\"in\",\"of\"],state.tokens.next.value)?advance():error(\"E045\",state.tokens.curr),state.funct[\"(comparray)\"].setState(\"generate\"),expression(10),advance(\")\"),\"if\"===state.tokens.next.value&&(advance(\"if\"),advance(\"(\"),state.funct[\"(comparray)\"].setState(\"filter\"),res.filter=expression(10),advance(\")\")),reversed||(state.funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"]\"),state.funct[\"(comparray)\"].unstack(),res}function isMethod(){return state.funct[\"(statement)\"]&&\"class\"===state.funct[\"(statement)\"].type||state.funct[\"(context)\"]&&\"class\"===state.funct[\"(context)\"][\"(verb)\"]}function isPropertyName(token){return token.identifier||\"(string)\"===token.id||\"(number)\"===token.id}function propertyName(preserveOrToken){var id,preserve=!0;return\"object\"==typeof preserveOrToken?id=preserveOrToken:(preserve=preserveOrToken,id=optionalidentifier(!1,!0,preserve)),id?\"object\"==typeof id&&(\"(string)\"===id.id||\"(identifier)\"===id.id?id=id.value:\"(number)\"===id.id&&(id=\"\"+id.value)):\"(string)\"===state.tokens.next.id?(id=state.tokens.next.value,preserve||advance()):\"(number)\"===state.tokens.next.id&&(id=\"\"+state.tokens.next.value,preserve||advance()),\"hasOwnProperty\"===id&&warning(\"W001\"),id}function functionparams(options){function addParam(addParamArgs){state.funct[\"(scope)\"].addParam.apply(state.funct[\"(scope)\"],addParamArgs)}var next,ident,t,paramsIds=[],tokens=[],pastDefault=!1,pastRest=!1,arity=0,loneArg=options&&options.loneArg;if(loneArg&&loneArg.identifier===!0)return state.funct[\"(scope)\"].addParam(loneArg.value,loneArg),{arity:1,params:[loneArg.value]};if(next=state.tokens.next,options&&options.parsedOpening||advance(\"(\"),\")\"===state.tokens.next.id)return advance(\")\"),void 0;for(;;){arity++;var currentParams=[];if(_.contains([\"{\",\"[\"],state.tokens.next.id)){tokens=destructuringPattern();for(t in tokens)t=tokens[t],t.id&&(paramsIds.push(t.id),currentParams.push([t.id,t.token]))}else if(checkPunctuator(state.tokens.next,\"...\")&&(pastRest=!0),ident=identifier(!0))paramsIds.push(ident),currentParams.push([ident,state.tokens.curr]);else for(;!checkPunctuators(state.tokens.next,[\",\",\")\"]);)advance();if(pastDefault&&\"=\"!==state.tokens.next.id&&error(\"W138\",state.tokens.current),\"=\"===state.tokens.next.id&&(state.inES6()||warning(\"W119\",state.tokens.next,\"default parameters\",\"6\"),advance(\"=\"),pastDefault=!0,expression(10)),currentParams.forEach(addParam),\",\"!==state.tokens.next.id)return advance(\")\",next),{arity:arity,params:paramsIds};pastRest&&warning(\"W131\",state.tokens.next),comma()}}function functor(name,token,overwrites){var funct={\"(name)\":name,\"(breakage)\":0,\"(loopage)\":0,\"(tokens)\":{},\"(properties)\":{},\"(catch)\":!1,\"(global)\":!1,\"(line)\":null,\"(character)\":null,\"(metrics)\":null,\"(statement)\":null,\"(context)\":null,\"(scope)\":null,\"(comparray)\":null,\"(generator)\":null,\"(arrow)\":null,\"(params)\":null};return token&&_.extend(funct,{\"(line)\":token.line,\"(character)\":token.character,\"(metrics)\":createMetrics(token)}),_.extend(funct,overwrites),funct[\"(context)\"]&&(funct[\"(scope)\"]=funct[\"(context)\"][\"(scope)\"],funct[\"(comparray)\"]=funct[\"(context)\"][\"(comparray)\"]),funct}function isFunctor(token){return\"(scope)\"in token}function hasParsedCode(funct){return funct[\"(global)\"]&&!funct[\"(verb)\"]}function doTemplateLiteral(left){function end(){if(state.tokens.curr.template&&state.tokens.curr.tail&&state.tokens.curr.context===ctx)return!0;var complete=state.tokens.next.template&&state.tokens.next.tail&&state.tokens.next.context===ctx;return complete&&advance(),complete||state.tokens.next.isUnclosed}var ctx=this.context,noSubst=this.noSubst,depth=this.depth;if(!noSubst)for(;!end();)!state.tokens.next.template||state.tokens.next.depth>depth?expression(0):advance();return{id:\"(template)\",type:\"(template)\",tag:left}}function doFunction(options){var f,token,name,statement,classExprBinding,isGenerator,isArrow,ignoreLoopFunc,oldOption=state.option,oldIgnored=state.ignored;options&&(name=options.name,statement=options.statement,classExprBinding=options.classExprBinding,isGenerator=\"generator\"===options.type,isArrow=\"arrow\"===options.type,ignoreLoopFunc=options.ignoreLoopFunc),state.option=Object.create(state.option),state.ignored=Object.create(state.ignored),state.funct=functor(name||state.nameStack.infer(),state.tokens.next,{\"(statement)\":statement,\"(context)\":state.funct,\"(arrow)\":isArrow,\"(generator)\":isGenerator}),f=state.funct,token=state.tokens.curr,token.funct=state.funct,functions.push(state.funct),state.funct[\"(scope)\"].stack(\"functionouter\");var internallyAccessibleName=name||classExprBinding;internallyAccessibleName&&state.funct[\"(scope)\"].block.add(internallyAccessibleName,classExprBinding?\"class\":\"function\",state.tokens.curr,!1),state.funct[\"(scope)\"].stack(\"functionparams\");var paramsInfo=functionparams(options);return paramsInfo?(state.funct[\"(params)\"]=paramsInfo.params,state.funct[\"(metrics)\"].arity=paramsInfo.arity,state.funct[\"(metrics)\"].verifyMaxParametersPerFunction()):state.funct[\"(metrics)\"].arity=0,isArrow&&(state.inES6(!0)||warning(\"W119\",state.tokens.curr,\"arrow function syntax (=>)\",\"6\"),options.loneArg||advance(\"=>\")),block(!1,!0,!0,isArrow),!state.option.noyield&&isGenerator&&\"yielded\"!==state.funct[\"(generator)\"]&&warning(\"W124\",state.tokens.curr),state.funct[\"(metrics)\"].verifyMaxStatementsPerFunction(),state.funct[\"(metrics)\"].verifyMaxComplexityPerFunction(),state.funct[\"(unusedOption)\"]=state.option.unused,state.option=oldOption,state.ignored=oldIgnored,state.funct[\"(last)\"]=state.tokens.curr.line,state.funct[\"(lastcharacter)\"]=state.tokens.curr.character,state.funct[\"(scope)\"].unstack(),state.funct[\"(scope)\"].unstack(),state.funct=state.funct[\"(context)\"],ignoreLoopFunc||state.option.loopfunc||!state.funct[\"(loopage)\"]||f[\"(isCapturing)\"]&&warning(\"W083\",token),f}function createMetrics(functionStartToken){return{statementCount:0,nestedBlockDepth:-1,ComplexityCount:1,arity:0,verifyMaxStatementsPerFunction:function(){state.option.maxstatements&&this.statementCount>state.option.maxstatements&&warning(\"W071\",functionStartToken,this.statementCount)\n},verifyMaxParametersPerFunction:function(){_.isNumber(state.option.maxparams)&&this.arity>state.option.maxparams&&warning(\"W072\",functionStartToken,this.arity)},verifyMaxNestedBlockDepthPerFunction:function(){state.option.maxdepth&&this.nestedBlockDepth>0&&this.nestedBlockDepth===state.option.maxdepth+1&&warning(\"W073\",null,this.nestedBlockDepth)},verifyMaxComplexityPerFunction:function(){var max=state.option.maxcomplexity,cc=this.ComplexityCount;max&&cc>max&&warning(\"W074\",functionStartToken,cc)}}}function increaseComplexityCount(){state.funct[\"(metrics)\"].ComplexityCount+=1}function checkCondAssignment(expr){var id,paren;switch(expr&&(id=expr.id,paren=expr.paren,\",\"===id&&(expr=expr.exprs[expr.exprs.length-1])&&(id=expr.id,paren=paren||expr.paren)),id){case\"=\":case\"+=\":case\"-=\":case\"*=\":case\"%=\":case\"&=\":case\"|=\":case\"^=\":case\"/=\":paren||state.option.boss||warning(\"W084\")}}function checkProperties(props){if(state.inES5())for(var name in props)props[name]&&props[name].setterToken&&!props[name].getterToken&&warning(\"W078\",props[name].setterToken)}function metaProperty(name,c){if(checkPunctuator(state.tokens.next,\".\")){var left=state.tokens.curr.id;advance(\".\");var id=identifier();return state.tokens.curr.isMetaProperty=!0,name!==id?error(\"E057\",state.tokens.prev,left,id):c(),state.tokens.curr}}function destructuringPattern(options){var isAssignment=options&&options.assignment;return state.inES6()||warning(\"W104\",state.tokens.curr,isAssignment?\"destructuring assignment\":\"destructuring binding\",\"6\"),destructuringPatternRecursive(options)}function destructuringPatternRecursive(options){var ids,identifiers=[],openingParsed=options&&options.openingParsed,isAssignment=options&&options.assignment,recursiveOptions=isAssignment?{assignment:isAssignment}:null,firstToken=openingParsed?state.tokens.curr:state.tokens.next,nextInnerDE=function(){var ident;if(checkPunctuators(state.tokens.next,[\"[\",\"{\"])){ids=destructuringPatternRecursive(recursiveOptions);for(var id in ids)id=ids[id],identifiers.push({id:id.id,token:id.token})}else if(checkPunctuator(state.tokens.next,\",\"))identifiers.push({id:null,token:state.tokens.curr});else{if(!checkPunctuator(state.tokens.next,\"(\")){var is_rest=checkPunctuator(state.tokens.next,\"...\");if(isAssignment){var identifierToken=is_rest?peek(0):state.tokens.next;identifierToken.identifier||warning(\"E030\",identifierToken,identifierToken.value);var assignTarget=expression(155);assignTarget&&(checkLeftSideAssign(assignTarget),assignTarget.identifier&&(ident=assignTarget.value))}else ident=identifier();return ident&&identifiers.push({id:ident,token:state.tokens.curr}),is_rest}advance(\"(\"),nextInnerDE(),advance(\")\")}return!1},assignmentProperty=function(){var id;checkPunctuator(state.tokens.next,\"[\")?(advance(\"[\"),expression(10),advance(\"]\"),advance(\":\"),nextInnerDE()):\"(string)\"===state.tokens.next.id||\"(number)\"===state.tokens.next.id?(advance(),advance(\":\"),nextInnerDE()):(id=identifier(),checkPunctuator(state.tokens.next,\":\")?(advance(\":\"),nextInnerDE()):id&&(isAssignment&&checkLeftSideAssign(state.tokens.curr),identifiers.push({id:id,token:state.tokens.curr})))};if(checkPunctuator(firstToken,\"[\")){openingParsed||advance(\"[\"),checkPunctuator(state.tokens.next,\"]\")&&warning(\"W137\",state.tokens.curr);for(var element_after_rest=!1;!checkPunctuator(state.tokens.next,\"]\");)nextInnerDE()&&!element_after_rest&&checkPunctuator(state.tokens.next,\",\")&&(warning(\"W130\",state.tokens.next),element_after_rest=!0),checkPunctuator(state.tokens.next,\"=\")&&(checkPunctuator(state.tokens.prev,\"...\")?advance(\"]\"):advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,\"]\")||advance(\",\");advance(\"]\")}else if(checkPunctuator(firstToken,\"{\")){for(openingParsed||advance(\"{\"),checkPunctuator(state.tokens.next,\"}\")&&warning(\"W137\",state.tokens.curr);!checkPunctuator(state.tokens.next,\"}\")&&(assignmentProperty(),checkPunctuator(state.tokens.next,\"=\")&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,\"}\")||(advance(\",\"),!checkPunctuator(state.tokens.next,\"}\"))););advance(\"}\")}return identifiers}function destructuringPatternMatch(tokens,value){var first=value.first;first&&_.zip(tokens,Array.isArray(first)?first:[first]).forEach(function(val){var token=val[0],value=val[1];token&&value?token.first=value:token&&token.first&&!value&&warning(\"W080\",token.first,token.first.value)})}function blockVariableStatement(type,statement,context){var tokens,lone,value,letblock,prefix=context&&context.prefix,inexport=context&&context.inexport,isLet=\"let\"===type,isConst=\"const\"===type;for(state.inES6()||warning(\"W104\",state.tokens.curr,type,\"6\"),isLet&&\"(\"===state.tokens.next.value?(state.inMoz()||warning(\"W118\",state.tokens.next,\"let block\"),advance(\"(\"),state.funct[\"(scope)\"].stack(),letblock=!0):state.funct[\"(noblockscopedvar)\"]&&error(\"E048\",state.tokens.curr,isConst?\"Const\":\"Let\"),statement.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),!prefix&&isConst&&\"=\"!==state.tokens.next.id&&warning(\"E012\",state.tokens.curr,state.tokens.curr.value);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.funct[\"(scope)\"].block.isGlobal()&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&!state.funct[\"(noblockscopedvar)\"]&&(state.funct[\"(scope)\"].addlabel(t.id,{type:type,token:t.token}),names.push(t.token),lone&&inexport&&state.funct[\"(scope)\"].setExported(t.token.value,t.token)));if(\"=\"===state.tokens.next.id&&(advance(\"=\"),prefix||\"undefined\"!==state.tokens.next.id||warning(\"W080\",state.tokens.prev,state.tokens.prev.value),!prefix&&\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),statement.first=statement.first.concat(names),\",\"!==state.tokens.next.id)break;comma()}return letblock&&(advance(\")\"),block(!0,!0),statement.block=!0,state.funct[\"(scope)\"].unstack()),statement}function classdef(isStatement){return state.inES6()||warning(\"W104\",state.tokens.curr,\"class\",\"6\"),isStatement?(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"class\",token:state.tokens.curr})):state.tokens.next.identifier&&\"extends\"!==state.tokens.next.value?(this.name=identifier(),this.namedExpr=!0):this.name=state.nameStack.infer(),classtail(this),this}function classtail(c){var wasInClassBody=state.inClassBody;\"extends\"===state.tokens.next.value&&(advance(\"extends\"),c.heritage=expression(10)),state.inClassBody=!0,advance(\"{\"),c.body=classbody(c),advance(\"}\"),state.inClassBody=wasInClassBody}function classbody(c){for(var name,isStatic,isGenerator,getset,computed,props=Object.create(null),staticProps=Object.create(null),i=0;\"}\"!==state.tokens.next.id;++i)if(name=state.tokens.next,isStatic=!1,isGenerator=!1,getset=null,\";\"!==name.id){if(\"*\"===name.id&&(isGenerator=!0,advance(\"*\"),name=state.tokens.next),\"[\"===name.id)name=computedPropertyName(),computed=!0;else{if(!isPropertyName(name)){warning(\"W052\",state.tokens.next,state.tokens.next.value||state.tokens.next.type),advance();continue}advance(),computed=!1,name.identifier&&\"static\"===name.value&&(checkPunctuator(state.tokens.next,\"*\")&&(isGenerator=!0,advance(\"*\")),(isPropertyName(state.tokens.next)||\"[\"===state.tokens.next.id)&&(computed=\"[\"===state.tokens.next.id,isStatic=!0,name=state.tokens.next,\"[\"===state.tokens.next.id?name=computedPropertyName():advance())),!name.identifier||\"get\"!==name.value&&\"set\"!==name.value||(isPropertyName(state.tokens.next)||\"[\"===state.tokens.next.id)&&(computed=\"[\"===state.tokens.next.id,getset=name,name=state.tokens.next,\"[\"===state.tokens.next.id?name=computedPropertyName():advance())}if(!checkPunctuator(state.tokens.next,\"(\")){for(error(\"E054\",state.tokens.next,state.tokens.next.value);\"}\"!==state.tokens.next.id&&!checkPunctuator(state.tokens.next,\"(\");)advance();\"(\"!==state.tokens.next.value&&doFunction({statement:c})}if(computed||(getset?saveAccessor(getset.value,isStatic?staticProps:props,name.value,name,!0,isStatic):(\"constructor\"===name.value?state.nameStack.set(c):state.nameStack.set(name),saveProperty(isStatic?staticProps:props,name.value,name,!0,isStatic))),getset&&\"constructor\"===name.value){var propDesc=\"get\"===getset.value?\"class getter method\":\"class setter method\";error(\"E049\",name,propDesc,\"constructor\")}else\"prototype\"===name.value&&error(\"E049\",name,\"class method\",\"prototype\");propertyName(name),doFunction({statement:c,type:isGenerator?\"generator\":null,classExprBinding:c.namedExpr?c.name:null})}else warning(\"W032\"),advance(\";\");checkProperties(props)}function saveProperty(props,name,tkn,isClass,isStatic){var msg=[\"key\",\"class method\",\"static class method\"];msg=msg[(isClass||!1)+(isStatic||!1)],tkn.identifier&&(name=tkn.value),props[name]&&\"__proto__\"!==name?warning(\"W075\",state.tokens.next,msg,name):props[name]=Object.create(null),props[name].basic=!0,props[name].basictkn=tkn}function saveAccessor(accessorType,props,name,tkn,isClass,isStatic){var flagName=\"get\"===accessorType?\"getterToken\":\"setterToken\",msg=\"\";isClass?(isStatic&&(msg+=\"static \"),msg+=accessorType+\"ter method\"):msg=\"key\",state.tokens.curr.accessorType=accessorType,state.nameStack.set(tkn),props[name]?(props[name].basic||props[name][flagName])&&\"__proto__\"!==name&&warning(\"W075\",state.tokens.next,msg,name):props[name]=Object.create(null),props[name][flagName]=tkn}function computedPropertyName(){advance(\"[\"),state.inES6()||warning(\"W119\",state.tokens.curr,\"computed property names\",\"6\");var value=expression(10);return advance(\"]\"),value}function checkPunctuators(token,values){return\"(punctuator)\"===token.type?_.contains(values,token.value):!1}function checkPunctuator(token,value){return\"(punctuator)\"===token.type&&token.value===value}function destructuringAssignOrJsonValue(){var block=lookupBlockType();block.notJson?(!state.inES6()&&block.isDestAssign&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\",\"6\"),statements()):(state.option.laxbreak=!0,state.jsonMode=!0,jsonValue())}function jsonValue(){function jsonObject(){var o={},t=state.tokens.next;if(advance(\"{\"),\"}\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E026\",state.tokens.next,t.line);else{if(\"}\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id?error(\"E028\",state.tokens.next):\"(string)\"!==state.tokens.next.id&&warning(\"W095\",state.tokens.next,state.tokens.next.value)}if(o[state.tokens.next.value]===!0?warning(\"W075\",state.tokens.next,\"key\",state.tokens.next.value):\"__proto__\"===state.tokens.next.value&&!state.option.proto||\"__iterator__\"===state.tokens.next.value&&!state.option.iterator?warning(\"W096\",state.tokens.next,state.tokens.next.value):o[state.tokens.next.value]=!0,advance(),advance(\":\"),jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"}\")}function jsonArray(){var t=state.tokens.next;if(advance(\"[\"),\"]\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E027\",state.tokens.next,t.line);else{if(\"]\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id&&error(\"E028\",state.tokens.next)}if(jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"]\")}switch(state.tokens.next.id){case\"{\":jsonObject();break;case\"[\":jsonArray();break;case\"true\":case\"false\":case\"null\":case\"(number)\":case\"(string)\":advance();break;case\"-\":advance(\"-\"),advance(\"(number)\");break;default:error(\"E003\",state.tokens.next)}}var api,declared,functions,inblock,indent,lookahead,lex,member,membersOnly,predefined,stack,urls,bang={\"<\":!0,\"<=\":!0,\"==\":!0,\"===\":!0,\"!==\":!0,\"!=\":!0,\">\":!0,\">=\":!0,\"+\":!0,\"-\":!0,\"*\":!0,\"/\":!0,\"%\":!0},functionicity=[\"closure\",\"exception\",\"global\",\"label\",\"outer\",\"unused\",\"var\"],extraModules=[],emitter=new events.EventEmitter,typeofValues={};typeofValues.legacy=[\"xml\",\"unknown\"],typeofValues.es3=[\"undefined\",\"boolean\",\"number\",\"string\",\"function\",\"object\"],typeofValues.es3=typeofValues.es3.concat(typeofValues.legacy),typeofValues.es6=typeofValues.es3.concat(\"symbol\"),type(\"(number)\",function(){return this}),type(\"(string)\",function(){return this}),state.syntax[\"(identifier)\"]={type:\"(identifier)\",lbp:0,identifier:!0,nud:function(){var v=this.value;return\"=>\"===state.tokens.next.id?this:(state.funct[\"(comparray)\"].check(v)||state.funct[\"(scope)\"].block.use(v,state.tokens.curr),this)},led:function(){error(\"E033\",state.tokens.next,state.tokens.next.value)}};var baseTemplateSyntax={lbp:0,identifier:!1,template:!0};state.syntax[\"(template)\"]=_.extend({type:\"(template)\",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!1},baseTemplateSyntax),state.syntax[\"(template middle)\"]=_.extend({type:\"(template middle)\",middle:!0,noSubst:!1},baseTemplateSyntax),state.syntax[\"(template tail)\"]=_.extend({type:\"(template tail)\",tail:!0,noSubst:!1},baseTemplateSyntax),state.syntax[\"(no subst template)\"]=_.extend({type:\"(template)\",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!0,tail:!0},baseTemplateSyntax),type(\"(regexp)\",function(){return this}),delim(\"(endline)\"),delim(\"(begin)\"),delim(\"(end)\").reach=!0,delim(\"(error)\").reach=!0,delim(\"}\").reach=!0,delim(\")\"),delim(\"]\"),delim('\"').reach=!0,delim(\"'\").reach=!0,delim(\";\"),delim(\":\").reach=!0,delim(\"#\"),reserve(\"else\"),reserve(\"case\").reach=!0,reserve(\"catch\"),reserve(\"default\").reach=!0,reserve(\"finally\"),reservevar(\"arguments\",function(x){state.isStrict()&&state.funct[\"(global)\"]&&warning(\"E008\",x)}),reservevar(\"eval\"),reservevar(\"false\"),reservevar(\"Infinity\"),reservevar(\"null\"),reservevar(\"this\",function(x){state.isStrict()&&!isMethod()&&!state.option.validthis&&(state.funct[\"(statement)\"]&&state.funct[\"(name)\"].charAt(0)>\"Z\"||state.funct[\"(global)\"])&&warning(\"W040\",x)}),reservevar(\"true\"),reservevar(\"undefined\"),assignop(\"=\",\"assign\",20),assignop(\"+=\",\"assignadd\",20),assignop(\"-=\",\"assignsub\",20),assignop(\"*=\",\"assignmult\",20),assignop(\"/=\",\"assigndiv\",20).nud=function(){error(\"E014\")},assignop(\"%=\",\"assignmod\",20),bitwiseassignop(\"&=\"),bitwiseassignop(\"|=\"),bitwiseassignop(\"^=\"),bitwiseassignop(\"<<=\"),bitwiseassignop(\">>=\"),bitwiseassignop(\">>>=\"),infix(\",\",function(left,that){var expr;if(that.exprs=[left],state.option.nocomma&&warning(\"W127\"),!comma({peek:!0}))return that;for(;;){if(!(expr=expression(10)))break;if(that.exprs.push(expr),\",\"!==state.tokens.next.value||!comma())break}return that},10,!0),infix(\"?\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(10),advance(\":\"),that[\"else\"]=expression(10),that},30);var orPrecendence=40;infix(\"||\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(orPrecendence),that},orPrecendence),infix(\"&&\",\"and\",50),bitwise(\"|\",\"bitor\",70),bitwise(\"^\",\"bitxor\",80),bitwise(\"&\",\"bitand\",90),relation(\"==\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===(left&&left.value)||\"null\"===(right&&right.value));switch(!0){case!eqnull&&state.option.eqeqeq:this.from=this.character,warning(\"W116\",this,\"===\",\"==\");break;case isPoorRelation(left):warning(\"W041\",this,\"===\",left.value);break;case isPoorRelation(right):warning(\"W041\",this,\"===\",right.value);break;case isTypoTypeof(right,left,state):warning(\"W122\",this,right.value);break;case isTypoTypeof(left,right,state):warning(\"W122\",this,left.value)}return this}),relation(\"===\",function(left,right){return isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"!=\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===(left&&left.value)||\"null\"===(right&&right.value));return!eqnull&&state.option.eqeqeq?(this.from=this.character,warning(\"W116\",this,\"!==\",\"!=\")):isPoorRelation(left)?warning(\"W041\",this,\"!==\",left.value):isPoorRelation(right)?warning(\"W041\",this,\"!==\",right.value):isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"!==\",function(left,right){return isTypoTypeof(right,left,state)?warning(\"W122\",this,right.value):isTypoTypeof(left,right,state)&&warning(\"W122\",this,left.value),this}),relation(\"<\"),relation(\">\"),relation(\"<=\"),relation(\">=\"),bitwise(\"<<\",\"shiftleft\",120),bitwise(\">>\",\"shiftright\",120),bitwise(\">>>\",\"shiftrightunsigned\",120),infix(\"in\",\"in\",120),infix(\"instanceof\",\"instanceof\",120),infix(\"+\",function(left,that){var right;return that.left=left,that.right=right=expression(130),left&&right&&\"(string)\"===left.id&&\"(string)\"===right.id?(left.value+=right.value,left.character=right.character,!state.option.scripturl&&reg.javascriptURL.test(left.value)&&warning(\"W050\",left),left):that},130),prefix(\"+\",\"num\"),prefix(\"+++\",function(){return warning(\"W007\"),this.arity=\"unary\",this.right=expression(150),this}),infix(\"+++\",function(left){return warning(\"W007\"),this.left=left,this.right=expression(130),this},130),infix(\"-\",\"sub\",130),prefix(\"-\",\"neg\"),prefix(\"---\",function(){return warning(\"W006\"),this.arity=\"unary\",this.right=expression(150),this}),infix(\"---\",function(left){return warning(\"W006\"),this.left=left,this.right=expression(130),this},130),infix(\"*\",\"mult\",140),infix(\"/\",\"div\",140),infix(\"%\",\"mod\",140),suffix(\"++\"),prefix(\"++\",\"preinc\"),state.syntax[\"++\"].exps=!0,suffix(\"--\"),prefix(\"--\",\"predec\"),state.syntax[\"--\"].exps=!0,prefix(\"delete\",function(){var p=expression(10);return p?(\".\"!==p.id&&\"[\"!==p.id&&warning(\"W051\"),this.first=p,p.identifier&&!state.isStrict()&&(p.forgiveUndef=!0),this):this}).exps=!0,prefix(\"~\",function(){return state.option.bitwise&&warning(\"W016\",this,\"~\"),this.arity=\"unary\",this.right=expression(150),this}),prefix(\"...\",function(){return state.inES6(!0)||warning(\"W119\",this,\"spread/rest operator\",\"6\"),state.tokens.next.identifier||\"(string)\"===state.tokens.next.type||checkPunctuators(state.tokens.next,[\"[\",\"(\"])||error(\"E030\",state.tokens.next,state.tokens.next.value),expression(150),this}),prefix(\"!\",function(){return this.arity=\"unary\",this.right=expression(150),this.right||quit(\"E041\",this.line||0),bang[this.right.id]===!0&&warning(\"W018\",this,\"!\"),this}),prefix(\"typeof\",function(){var p=expression(150);return this.first=this.right=p,p||quit(\"E041\",this.line||0,this.character||0),p.identifier&&(p.forgiveUndef=!0),this}),prefix(\"new\",function(){var mp=metaProperty(\"target\",function(){state.inES6(!0)||warning(\"W119\",state.tokens.prev,\"new.target\",\"6\");for(var inFunction,c=state.funct;c&&(inFunction=!c[\"(global)\"],c[\"(arrow)\"]);)c=c[\"(context)\"];inFunction||warning(\"W136\",state.tokens.prev,\"new.target\")});if(mp)return mp;var i,c=expression(155);if(c&&\"function\"!==c.id)if(c.identifier)switch(c[\"new\"]=!0,c.value){case\"Number\":case\"String\":case\"Boolean\":case\"Math\":case\"JSON\":warning(\"W053\",state.tokens.prev,c.value);break;case\"Symbol\":state.inES6()&&warning(\"W053\",state.tokens.prev,c.value);break;case\"Function\":state.option.evil||warning(\"W054\");break;case\"Date\":case\"RegExp\":case\"this\":break;default:\"function\"!==c.id&&(i=c.value.substr(0,1),state.option.newcap&&(\"A\">i||i>\"Z\")&&!state.funct[\"(scope)\"].isPredefined(c.value)&&warning(\"W055\",state.tokens.curr))}else\".\"!==c.id&&\"[\"!==c.id&&\"(\"!==c.id&&warning(\"W056\",state.tokens.curr);else state.option.supernew||warning(\"W057\",this);return\"(\"===state.tokens.next.id||state.option.supernew||warning(\"W058\",state.tokens.curr,state.tokens.curr.value),this.first=this.right=c,this}),state.syntax[\"new\"].exps=!0,prefix(\"void\").exps=!0,infix(\".\",function(left,that){var m=identifier(!1,!0);return\"string\"==typeof m&&countMember(m),that.left=left,that.right=m,m&&\"hasOwnProperty\"===m&&\"=\"===state.tokens.next.value&&warning(\"W001\"),!left||\"arguments\"!==left.value||\"callee\"!==m&&\"caller\"!==m?state.option.evil||!left||\"document\"!==left.value||\"write\"!==m&&\"writeln\"!==m||warning(\"W060\",left):state.option.noarg?warning(\"W059\",left,m):state.isStrict()&&error(\"E008\"),state.option.evil||\"eval\"!==m&&\"execScript\"!==m||isGlobalEval(left,state)&&warning(\"W061\"),that},160,!0),infix(\"(\",function(left,that){state.option.immed&&left&&!left.immed&&\"function\"===left.id&&warning(\"W062\");var n=0,p=[];if(left&&\"(identifier)\"===left.type&&left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)&&-1===\"Array Number String Boolean Date Object Error Symbol\".indexOf(left.value)&&(\"Math\"===left.value?warning(\"W063\",left):state.option.newcap&&warning(\"W064\",left)),\")\"!==state.tokens.next.id)for(;p[p.length]=expression(10),n+=1,\",\"===state.tokens.next.id;)comma();return advance(\")\"),\"object\"==typeof left&&(state.inES5()||\"parseInt\"!==left.value||1!==n||warning(\"W065\",state.tokens.curr),state.option.evil||(\"eval\"===left.value||\"Function\"===left.value||\"execScript\"===left.value?(warning(\"W061\",left),p[0]&&\"(string)\"===[0].id&&addInternalSrc(left,p[0].value)):!p[0]||\"(string)\"!==p[0].id||\"setTimeout\"!==left.value&&\"setInterval\"!==left.value?!p[0]||\"(string)\"!==p[0].id||\".\"!==left.value||\"window\"!==left.left.value||\"setTimeout\"!==left.right&&\"setInterval\"!==left.right||(warning(\"W066\",left),addInternalSrc(left,p[0].value)):(warning(\"W066\",left),addInternalSrc(left,p[0].value))),left.identifier||\".\"===left.id||\"[\"===left.id||\"=>\"===left.id||\"(\"===left.id||\"&&\"===left.id||\"||\"===left.id||\"?\"===left.id||state.inES6()&&left[\"(name)\"]||warning(\"W067\",that)),that.left=left,that},155,!0).exps=!0,prefix(\"(\",function(){var pn1,ret,triggerFnExpr,first,last,pn=state.tokens.next,i=-1,parens=1,opening=state.tokens.curr,preceeding=state.tokens.prev,isNecessary=!state.option.singleGroups;do\"(\"===pn.value?parens+=1:\")\"===pn.value&&(parens-=1),i+=1,pn1=pn,pn=peek(i);while((0!==parens||\")\"!==pn1.value)&&\";\"!==pn.value&&\"(end)\"!==pn.type);if(\"function\"===state.tokens.next.id&&(triggerFnExpr=state.tokens.next.immed=!0),\"=>\"===pn.value)return doFunction({type:\"arrow\",parsedOpening:!0});var exprs=[];if(\")\"!==state.tokens.next.id)for(;exprs.push(expression(10)),\",\"===state.tokens.next.id;)state.option.nocomma&&warning(\"W127\"),comma();return advance(\")\",this),state.option.immed&&exprs[0]&&\"function\"===exprs[0].id&&\"(\"!==state.tokens.next.id&&\".\"!==state.tokens.next.id&&\"[\"!==state.tokens.next.id&&warning(\"W068\",this),exprs.length?(exprs.length>1?(ret=Object.create(state.syntax[\",\"]),ret.exprs=exprs,first=exprs[0],last=exprs[exprs.length-1],isNecessary||(isNecessary=preceeding.assign||preceeding.delim)):(ret=first=last=exprs[0],isNecessary||(isNecessary=opening.beginsStmt&&(\"{\"===ret.id||triggerFnExpr||isFunctor(ret))||triggerFnExpr&&(!isEndOfExpr()||\"}\"!==state.tokens.prev.id)||isFunctor(ret)&&!isEndOfExpr()||\"{\"===ret.id&&\"=>\"===preceeding.id||\"(number)\"===ret.type&&checkPunctuator(pn,\".\")&&/^\\d+$/.test(ret.value))),ret&&(!isNecessary&&(first.left||first.right||ret.exprs)&&(isNecessary=!isBeginOfExpr(preceeding)&&first.lbp<=preceeding.lbp||!isEndOfExpr()&&last.lbp<state.tokens.next.lbp),isNecessary||warning(\"W126\",opening),ret.paren=!0),ret):void 0}),application(\"=>\"),infix(\"[\",function(left,that){var s,e=expression(10);return e&&\"(string)\"===e.type&&(state.option.evil||\"eval\"!==e.value&&\"execScript\"!==e.value||isGlobalEval(left,state)&&warning(\"W061\"),countMember(e.value),!state.option.sub&&reg.identifier.test(e.value)&&(s=state.syntax[e.value],s&&isReserved(s)||warning(\"W069\",state.tokens.prev,e.value))),advance(\"]\",that),e&&\"hasOwnProperty\"===e.value&&\"=\"===state.tokens.next.value&&warning(\"W001\"),that.left=left,that.right=e,that},160,!0),prefix(\"[\",function(){var blocktype=lookupBlockType();if(blocktype.isCompArray)return state.option.esnext||state.inMoz()||warning(\"W118\",state.tokens.curr,\"array comprehension\"),comprehensiveArrayExpression();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;var b=state.tokens.curr.line!==startLine(state.tokens.next);for(this.first=[],b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"(end)\"!==state.tokens.next.id;){for(;\",\"===state.tokens.next.id;){if(!state.option.elision){if(state.inES5()){warning(\"W128\");do advance(\",\");while(\",\"===state.tokens.next.id);continue}warning(\"W070\")}advance(\",\")}if(\"]\"===state.tokens.next.id)break;if(this.first.push(expression(10)),\",\"!==state.tokens.next.id)break;if(comma({allowTrailing:!0}),\"]\"===state.tokens.next.id&&!state.inES5()){warning(\"W070\",state.tokens.curr);break}}return b&&(indent-=state.option.indent),advance(\"]\",this),this}),function(x){x.nud=function(){var b,f,i,p,t,nextVal,isGeneratorMethod=!1,props=Object.create(null);b=state.tokens.curr.line!==startLine(state.tokens.next),b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));var blocktype=lookupBlockType();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;for(;\"}\"!==state.tokens.next.id;){if(nextVal=state.tokens.next.value,!state.tokens.next.identifier||\",\"!==peekIgnoreEOL().id&&\"}\"!==peekIgnoreEOL().id)if(\":\"===peek().id||\"get\"!==nextVal&&\"set\"!==nextVal){if(\"*\"===state.tokens.next.value&&\"(punctuator)\"===state.tokens.next.type?(state.inES6()||warning(\"W104\",state.tokens.next,\"generator functions\",\"6\"),advance(\"*\"),isGeneratorMethod=!0):isGeneratorMethod=!1,\"[\"===state.tokens.next.id)i=computedPropertyName(),state.nameStack.set(i);else if(state.nameStack.set(state.tokens.next),i=propertyName(),saveProperty(props,i,state.tokens.next),\"string\"!=typeof i)break;\"(\"===state.tokens.next.value?(state.inES6()||warning(\"W104\",state.tokens.curr,\"concise methods\",\"6\"),doFunction({type:isGeneratorMethod?\"generator\":null})):(advance(\":\"),expression(10))}else advance(nextVal),state.inES5()||error(\"E034\"),i=propertyName(),i||state.inES6()||error(\"E035\"),i&&saveAccessor(nextVal,props,i,state.tokens.curr),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],\"get\"===nextVal&&i&&p?warning(\"W076\",t,p[0],i):\"set\"!==nextVal||!i||p&&1===p.length||warning(\"W077\",t,i);else state.inES6()||warning(\"W104\",state.tokens.next,\"object short notation\",\"6\"),i=propertyName(!0),saveProperty(props,i,state.tokens.next),expression(10);if(countMember(i),\",\"!==state.tokens.next.id)break;comma({allowTrailing:!0,property:!0}),\",\"===state.tokens.next.id?warning(\"W070\",state.tokens.curr):\"}\"!==state.tokens.next.id||state.inES5()||warning(\"W070\",state.tokens.curr)}return b&&(indent-=state.option.indent),advance(\"}\",this),checkProperties(props),this},x.fud=function(){error(\"E036\",state.tokens.curr)}}(delim(\"{\"));var conststatement=stmt(\"const\",function(context){return blockVariableStatement(\"const\",this,context)});conststatement.exps=!0;var letstatement=stmt(\"let\",function(context){return blockVariableStatement(\"let\",this,context)});letstatement.exps=!0;var varstatement=stmt(\"var\",function(context){var tokens,lone,value,prefix=context&&context.prefix,inexport=context&&context.inexport,implied=context&&context.implied,report=!(context&&context.ignore);for(this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),prefix&&implied||!report||!state.option.varstmt||warning(\"W132\",this),this.first=this.first.concat(names);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],!implied&&state.funct[\"(global)\"]&&(predefined[t.id]===!1?warning(\"W079\",t.token,t.id):state.option.futurehostile===!1&&(!state.inES5()&&vars.ecmaIdentifiers[5][t.id]===!1||!state.inES6()&&vars.ecmaIdentifiers[6][t.id]===!1)&&warning(\"W129\",t.token,t.id)),t.id&&(\"for\"===implied?(state.funct[\"(scope)\"].has(t.id)||report&&warning(\"W088\",t.token,t.id),state.funct[\"(scope)\"].block.use(t.id,t.token)):(state.funct[\"(scope)\"].addlabel(t.id,{type:\"var\",token:t.token}),lone&&inexport&&state.funct[\"(scope)\"].setExported(t.id,t.token)),names.push(t.token)));if(\"=\"===state.tokens.next.id&&(state.nameStack.set(state.tokens.curr),advance(\"=\"),prefix||!report||state.funct[\"(loopage)\"]||\"undefined\"!==state.tokens.next.id||warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&(!prefix&&report&&!state.funct[\"(params)\"]||-1===state.funct[\"(params)\"].indexOf(state.tokens.next.value))&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});varstatement.exps=!0,blockstmt(\"class\",function(){return classdef.call(this,!0)}),blockstmt(\"function\",function(context){var inexport=context&&context.inexport,generator=!1;\"*\"===state.tokens.next.value&&(advance(\"*\"),state.inES6({strict:!0})?generator=!0:warning(\"W119\",state.tokens.curr,\"function*\",\"6\")),inblock&&warning(\"W082\",state.tokens.curr);var i=optionalidentifier();return state.funct[\"(scope)\"].addlabel(i,{type:\"function\",token:state.tokens.curr}),void 0===i?warning(\"W025\"):inexport&&state.funct[\"(scope)\"].setExported(i,state.tokens.prev),doFunction({name:i,statement:this,type:generator?\"generator\":null,ignoreLoopFunc:inblock}),\"(\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line&&error(\"E039\"),this}),prefix(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(state.inES6()||warning(\"W119\",state.tokens.curr,\"function*\",\"6\"),advance(\"*\"),generator=!0);var i=optionalidentifier();return doFunction({name:i,type:generator?\"generator\":null}),this}),blockstmt(\"if\",function(){var t=state.tokens.next;increaseComplexityCount(),state.condition=!0,advance(\"(\");var expr=expression(0);checkCondAssignment(expr);var forinifcheck=null;state.option.forin&&state.forinifcheckneeded&&(state.forinifcheckneeded=!1,forinifcheck=state.forinifchecks[state.forinifchecks.length-1],forinifcheck.type=\"(punctuator)\"===expr.type&&\"!\"===expr.value?\"(negative)\":\"(positive)\"),advance(\")\",t),state.condition=!1;var s=block(!0,!0);return forinifcheck&&\"(negative)\"===forinifcheck.type&&s&&s[0]&&\"(identifier)\"===s[0].type&&\"continue\"===s[0].value&&(forinifcheck.type=\"(negative-with-continue)\"),\"else\"===state.tokens.next.id&&(advance(\"else\"),\"if\"===state.tokens.next.id||\"switch\"===state.tokens.next.id?statement():block(!0,!0)),this}),blockstmt(\"try\",function(){function doCatch(){if(advance(\"catch\"),advance(\"(\"),state.funct[\"(scope)\"].stack(\"catchparams\"),checkPunctuators(state.tokens.next,[\"[\",\"{\"])){var tokens=destructuringPattern();_.each(tokens,function(token){token.id&&state.funct[\"(scope)\"].addParam(token.id,token,\"exception\")})}else\"(identifier)\"!==state.tokens.next.type?warning(\"E030\",state.tokens.next,state.tokens.next.value):state.funct[\"(scope)\"].addParam(identifier(),state.tokens.curr,\"exception\");\"if\"===state.tokens.next.value&&(state.inMoz()||warning(\"W118\",state.tokens.curr,\"catch filter\"),advance(\"if\"),expression(0)),advance(\")\"),block(!1),state.funct[\"(scope)\"].unstack()}var b;for(block(!0);\"catch\"===state.tokens.next.id;)increaseComplexityCount(),b&&!state.inMoz()&&warning(\"W118\",state.tokens.next,\"multiple catch blocks\"),doCatch(),b=!0;return\"finally\"===state.tokens.next.id?(advance(\"finally\"),block(!0),void 0):(b||error(\"E021\",state.tokens.next,\"catch\",state.tokens.next.value),this)}),blockstmt(\"while\",function(){var t=state.tokens.next;return state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),block(!0,!0),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1,this}).labelled=!0,blockstmt(\"with\",function(){var t=state.tokens.next;return state.isStrict()?error(\"E010\",state.tokens.curr):state.option.withstmt||warning(\"W085\",state.tokens.curr),advance(\"(\"),expression(0),advance(\")\",t),block(!0,!0),this}),blockstmt(\"switch\",function(){var t=state.tokens.next,g=!1,noindent=!1;\nfor(state.funct[\"(breakage)\"]+=1,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),t=state.tokens.next,advance(\"{\"),state.tokens.next.from===indent&&(noindent=!0),noindent||(indent+=state.option.indent),this.cases=[];;)switch(state.tokens.next.id){case\"case\":switch(state.funct[\"(verb)\"]){case\"yield\":case\"break\":case\"case\":case\"continue\":case\"return\":case\"switch\":case\"throw\":break;default:state.tokens.curr.caseFallsThrough||warning(\"W086\",state.tokens.curr,\"case\")}advance(\"case\"),this.cases.push(expression(0)),increaseComplexityCount(),g=!0,advance(\":\"),state.funct[\"(verb)\"]=\"case\";break;case\"default\":switch(state.funct[\"(verb)\"]){case\"yield\":case\"break\":case\"continue\":case\"return\":case\"throw\":break;default:this.cases.length&&(state.tokens.curr.caseFallsThrough||warning(\"W086\",state.tokens.curr,\"default\"))}advance(\"default\"),g=!0,advance(\":\");break;case\"}\":return noindent||(indent-=state.option.indent),advance(\"}\",t),state.funct[\"(breakage)\"]-=1,state.funct[\"(verb)\"]=void 0,void 0;case\"(end)\":return error(\"E023\",state.tokens.next,\"}\"),void 0;default:if(indent+=state.option.indent,g)switch(state.tokens.curr.id){case\",\":return error(\"E040\"),void 0;case\":\":g=!1,statements();break;default:return error(\"E025\",state.tokens.curr),void 0}else{if(\":\"!==state.tokens.curr.id)return error(\"E021\",state.tokens.next,\"case\",state.tokens.next.value),void 0;advance(\":\"),error(\"E024\",state.tokens.curr,\":\"),statements()}indent-=state.option.indent}return this}).labelled=!0,stmt(\"debugger\",function(){return state.option.debug||warning(\"W087\",this),this}).exps=!0,function(){var x=stmt(\"do\",function(){state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,increaseComplexityCount(),this.first=block(!0,!0),advance(\"while\");var t=state.tokens.next;return advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1,this});x.labelled=!0,x.exps=!0}(),blockstmt(\"for\",function(){var s,t=state.tokens.next,letscope=!1,foreachtok=null;\"each\"===t.value&&(foreachtok=t,advance(\"each\"),state.inMoz()||warning(\"W118\",state.tokens.curr,\"for each\")),increaseComplexityCount(),advance(\"(\");var nextop,comma,initializer,i=0,inof=[\"in\",\"of\"],level=0;checkPunctuators(state.tokens.next,[\"{\",\"[\"])&&++level;do{if(nextop=peek(i),++i,checkPunctuators(nextop,[\"{\",\"[\"])?++level:checkPunctuators(nextop,[\"}\",\"]\"])&&--level,0>level)break;0===level&&(!comma&&checkPunctuator(nextop,\",\")?comma=nextop:!initializer&&checkPunctuator(nextop,\"=\")&&(initializer=nextop))}while(level>0||!_.contains(inof,nextop.value)&&\";\"!==nextop.value&&\"(end)\"!==nextop.type);if(_.contains(inof,nextop.value)){state.inES6()||\"of\"!==nextop.value||warning(\"W104\",nextop,\"for of\",\"6\");var ok=!(initializer||comma);if(initializer&&error(\"W133\",comma,nextop.value,\"initializer is forbidden\"),comma&&error(\"W133\",comma,nextop.value,\"more than one ForBinding\"),\"var\"===state.tokens.next.id?(advance(\"var\"),state.tokens.curr.fud({prefix:!0})):\"let\"===state.tokens.next.id||\"const\"===state.tokens.next.id?(advance(state.tokens.next.id),letscope=!0,state.funct[\"(scope)\"].stack(),state.tokens.curr.fud({prefix:!0})):Object.create(varstatement).fud({prefix:!0,implied:\"for\",ignore:!ok}),advance(nextop.value),expression(20),advance(\")\",t),\"in\"===nextop.value&&state.option.forin&&(state.forinifcheckneeded=!0,void 0===state.forinifchecks&&(state.forinifchecks=[]),state.forinifchecks.push({type:\"(none)\"})),state.funct[\"(breakage)\"]+=1,state.funct[\"(loopage)\"]+=1,s=block(!0,!0),\"in\"===nextop.value&&state.option.forin){if(state.forinifchecks&&state.forinifchecks.length>0){var check=state.forinifchecks.pop();(s&&s.length>0&&(\"object\"!=typeof s[0]||\"if\"!==s[0].value)||\"(positive)\"===check.type&&s.length>1||\"(negative)\"===check.type)&&warning(\"W089\",this)}state.forinifcheckneeded=!1}state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1}else{if(foreachtok&&error(\"E045\",foreachtok),\";\"!==state.tokens.next.id)if(\"var\"===state.tokens.next.id)advance(\"var\"),state.tokens.curr.fud();else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,state.funct[\"(scope)\"].stack(),state.tokens.curr.fud();else for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();if(nolinebreak(state.tokens.curr),advance(\";\"),state.funct[\"(loopage)\"]+=1,\";\"!==state.tokens.next.id&&checkCondAssignment(expression(0)),nolinebreak(state.tokens.curr),advance(\";\"),\";\"===state.tokens.next.id&&error(\"E021\",state.tokens.next,\")\",\";\"),\")\"!==state.tokens.next.id)for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();advance(\")\",t),state.funct[\"(breakage)\"]+=1,block(!0,!0),state.funct[\"(breakage)\"]-=1,state.funct[\"(loopage)\"]-=1}return letscope&&state.funct[\"(scope)\"].unstack(),this}).labelled=!0,stmt(\"break\",function(){var v=state.tokens.next.value;return state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line!==startLine(state.tokens.next)?0===state.funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value):(state.funct[\"(scope)\"].funct.hasBreakLabel(v)||warning(\"W090\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt(\"continue\",function(){var v=state.tokens.next.value;return 0===state.funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.funct[\"(loopage)\"]||warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line===startLine(state.tokens.next)&&(state.funct[\"(scope)\"].funct.hasBreakLabel(v)||warning(\"W090\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt(\"return\",function(){return this.line===startLine(state.tokens.next)?\";\"===state.tokens.next.id||state.tokens.next.reach||(this.first=expression(0),!this.first||\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)):\"(punctuator)\"===state.tokens.next.type&&[\"[\",\"{\",\"+\",\"-\"].indexOf(state.tokens.next.value)>-1&&nolinebreak(this),reachable(this),this}).exps=!0,function(x){x.exps=!0,x.lbp=25}(prefix(\"yield\",function(){var prev=state.tokens.prev;state.inES6(!0)&&!state.funct[\"(generator)\"]?\"(catch)\"===state.funct[\"(name)\"]&&state.funct[\"(context)\"][\"(generator)\"]||error(\"E046\",state.tokens.curr,\"yield\"):state.inES6()||warning(\"W104\",state.tokens.curr,\"yield\",\"6\"),state.funct[\"(generator)\"]=\"yielded\";var delegatingYield=!1;return\"*\"===state.tokens.next.value&&(delegatingYield=!0,advance(\"*\")),this.line!==startLine(state.tokens.next)&&state.inMoz()?state.option.asi||nolinebreak(this):((delegatingYield||\";\"!==state.tokens.next.id&&!state.option.asi&&!state.tokens.next.reach&&state.tokens.next.nud)&&(nobreaknonadjacent(state.tokens.curr,state.tokens.next),this.first=expression(10),\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)),state.inMoz()&&\")\"!==state.tokens.next.id&&(prev.lbp>30||!prev.assign&&!isEndOfExpr()||\"yield\"===prev.id)&&error(\"E050\",this)),this})),stmt(\"throw\",function(){return nolinebreak(this),this.first=expression(20),reachable(this),this}).exps=!0,stmt(\"import\",function(){if(state.inES6()||warning(\"W119\",state.tokens.curr,\"import\",\"6\"),\"(string)\"===state.tokens.next.type)return advance(\"(string)\"),this;if(state.tokens.next.identifier){if(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"const\",token:state.tokens.curr}),\",\"!==state.tokens.next.value)return advance(\"from\"),advance(\"(string)\"),this;advance(\",\")}if(\"*\"===state.tokens.next.id)advance(\"*\"),advance(\"as\"),state.tokens.next.identifier&&(this.name=identifier(),state.funct[\"(scope)\"].addlabel(this.name,{type:\"const\",token:state.tokens.curr}));else for(advance(\"{\");;){if(\"}\"===state.tokens.next.value){advance(\"}\");break}var importName;if(\"default\"===state.tokens.next.type?(importName=\"default\",advance(\"default\")):importName=identifier(),\"as\"===state.tokens.next.value&&(advance(\"as\"),importName=identifier()),state.funct[\"(scope)\"].addlabel(importName,{type:\"const\",token:state.tokens.curr}),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return advance(\"from\"),advance(\"(string)\"),this}).exps=!0,stmt(\"export\",function(){var token,identifier,ok=!0;if(state.inES6()||(warning(\"W119\",state.tokens.curr,\"export\",\"6\"),ok=!1),state.funct[\"(scope)\"].block.isGlobal()||(error(\"E053\",state.tokens.curr),ok=!1),\"*\"===state.tokens.next.value)return advance(\"*\"),advance(\"from\"),advance(\"(string)\"),this;if(\"default\"===state.tokens.next.type){state.nameStack.set(state.tokens.next),advance(\"default\");var exportType=state.tokens.next.id;return(\"function\"===exportType||\"class\"===exportType)&&(this.block=!0),token=peek(),expression(10),identifier=token.value,this.block&&(state.funct[\"(scope)\"].addlabel(identifier,{type:exportType,token:token}),state.funct[\"(scope)\"].setExported(identifier,token)),this}if(\"{\"===state.tokens.next.value){advance(\"{\");for(var exportedTokens=[];;){if(state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),advance(),exportedTokens.push(state.tokens.curr),\"as\"===state.tokens.next.value&&(advance(\"as\"),state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),advance()),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return\"from\"===state.tokens.next.value?(advance(\"from\"),advance(\"(string)\")):ok&&exportedTokens.forEach(function(token){state.funct[\"(scope)\"].setExported(token.value,token)}),this}if(\"var\"===state.tokens.next.id)advance(\"var\"),state.tokens.curr.fud({inexport:!0});else if(\"let\"===state.tokens.next.id)advance(\"let\"),state.tokens.curr.fud({inexport:!0});else if(\"const\"===state.tokens.next.id)advance(\"const\"),state.tokens.curr.fud({inexport:!0});else if(\"function\"===state.tokens.next.id)this.block=!0,advance(\"function\"),state.syntax[\"function\"].fud({inexport:!0});else if(\"class\"===state.tokens.next.id){this.block=!0,advance(\"class\");var classNameToken=state.tokens.next;state.syntax[\"class\"].fud(),state.funct[\"(scope)\"].setExported(classNameToken.value,classNameToken)}else error(\"E024\",state.tokens.next,state.tokens.next.value);return this}).exps=!0,FutureReservedWord(\"abstract\"),FutureReservedWord(\"boolean\"),FutureReservedWord(\"byte\"),FutureReservedWord(\"char\"),FutureReservedWord(\"class\",{es5:!0,nud:classdef}),FutureReservedWord(\"double\"),FutureReservedWord(\"enum\",{es5:!0}),FutureReservedWord(\"export\",{es5:!0}),FutureReservedWord(\"extends\",{es5:!0}),FutureReservedWord(\"final\"),FutureReservedWord(\"float\"),FutureReservedWord(\"goto\"),FutureReservedWord(\"implements\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"import\",{es5:!0}),FutureReservedWord(\"int\"),FutureReservedWord(\"interface\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"long\"),FutureReservedWord(\"native\"),FutureReservedWord(\"package\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"private\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"protected\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"public\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"short\"),FutureReservedWord(\"static\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"super\",{es5:!0}),FutureReservedWord(\"synchronized\"),FutureReservedWord(\"transient\"),FutureReservedWord(\"volatile\");var lookupBlockType=function(){var pn,pn1,prev,i=-1,bracketStack=0,ret={};checkPunctuators(state.tokens.curr,[\"[\",\"{\"])&&(bracketStack+=1);do{if(prev=-1===i?state.tokens.curr:pn,pn=-1===i?state.tokens.next:peek(i),pn1=peek(i+1),i+=1,checkPunctuators(pn,[\"[\",\"{\"])?bracketStack+=1:checkPunctuators(pn,[\"]\",\"}\"])&&(bracketStack-=1),1===bracketStack&&pn.identifier&&\"for\"===pn.value&&!checkPunctuator(prev,\".\")){ret.isCompArray=!0,ret.notJson=!0;break}if(0===bracketStack&&checkPunctuators(pn,[\"}\",\"]\"])){if(\"=\"===pn1.value){ret.isDestAssign=!0,ret.notJson=!0;break}if(\".\"===pn1.value){ret.notJson=!0;break}}checkPunctuator(pn,\";\")&&(ret.isBlock=!0,ret.notJson=!0)}while(bracketStack>0&&\"(end)\"!==pn.id);return ret},arrayComprehension=function(){function declare(v){var l=_current.variables.filter(function(elt){return elt.value===v?(elt.undef=!1,v):void 0}).length;return 0!==l}function use(v){var l=_current.variables.filter(function(elt){return elt.value!==v||elt.undef?void 0:(elt.unused===!0&&(elt.unused=!1),v)}).length;return 0===l}var _current,CompArray=function(){this.mode=\"use\",this.variables=[]},_carrays=[];return{stack:function(){_current=new CompArray,_carrays.push(_current)},unstack:function(){_current.variables.filter(function(v){v.unused&&warning(\"W098\",v.token,v.raw_text||v.value),v.undef&&state.funct[\"(scope)\"].block.use(v.value,v.token)}),_carrays.splice(-1,1),_current=_carrays[_carrays.length-1]},setState:function(s){_.contains([\"use\",\"define\",\"generate\",\"filter\"],s)&&(_current.mode=s)},check:function(v){return _current?_current&&\"use\"===_current.mode?(use(v)&&_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!0,unused:!1}),!0):_current&&\"define\"===_current.mode?(declare(v)||_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!1,unused:!0}),!0):_current&&\"generate\"===_current.mode?(state.funct[\"(scope)\"].block.use(v,state.tokens.curr),!0):_current&&\"filter\"===_current.mode?(use(v)&&state.funct[\"(scope)\"].block.use(v,state.tokens.curr),!0):!1:void 0}}},escapeRegex=function(str){return str.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\")},itself=function(s,o,g){function each(obj,cb){obj&&(Array.isArray(obj)||\"object\"!=typeof obj||(obj=Object.keys(obj)),obj.forEach(cb))}var i,k,x,reIgnoreStr,reIgnore,optionKeys,newOptionObj={},newIgnoredObj={};o=_.clone(o),state.reset(),o&&o.scope?JSHINT.scope=o.scope:(JSHINT.errors=[],JSHINT.undefs=[],JSHINT.internals=[],JSHINT.blacklist={},JSHINT.scope=\"(main)\"),predefined=Object.create(null),combine(predefined,vars.ecmaIdentifiers[3]),combine(predefined,vars.reservedVars),combine(predefined,g||{}),declared=Object.create(null);var exported=Object.create(null);if(o)for(each(o.predef||null,function(item){var slice,prop;\"-\"===item[0]?(slice=item.slice(1),JSHINT.blacklist[slice]=slice,delete predefined[slice]):(prop=Object.getOwnPropertyDescriptor(o.predef,item),predefined[item]=prop?prop.value:!1)}),each(o.exported||null,function(item){exported[item]=!0}),delete o.predef,delete o.exported,optionKeys=Object.keys(o),x=0;optionKeys.length>x;x++)if(/^-W\\d{3}$/g.test(optionKeys[x]))newIgnoredObj[optionKeys[x].slice(1)]=!0;else{var optionKey=optionKeys[x];newOptionObj[optionKey]=o[optionKey],(\"esversion\"===optionKey&&5===o[optionKey]||\"es5\"===optionKey&&o[optionKey])&&warning(\"I003\"),\"newcap\"===optionKeys[x]&&o[optionKey]===!1&&(newOptionObj[\"(explicitNewcap)\"]=!0)}state.option=newOptionObj,state.ignored=newIgnoredObj,state.option.indent=state.option.indent||4,state.option.maxerr=state.option.maxerr||50,indent=1;var scopeManagerInst=scopeManager(state,predefined,exported,declared);if(scopeManagerInst.on(\"warning\",function(ev){warning.apply(null,[ev.code,ev.token].concat(ev.data))}),scopeManagerInst.on(\"error\",function(ev){error.apply(null,[ev.code,ev.token].concat(ev.data))}),state.funct=functor(\"(global)\",null,{\"(global)\":!0,\"(scope)\":scopeManagerInst,\"(comparray)\":arrayComprehension(),\"(metrics)\":createMetrics(state.tokens.next)}),functions=[state.funct],urls=[],stack=null,member={},membersOnly=null,inblock=!1,lookahead=[],!isString(s)&&!Array.isArray(s))return errorAt(\"E004\",0),!1;api={get isJSON(){return state.jsonMode},getOption:function(name){return state.option[name]||null},getCache:function(name){return state.cache[name]},setCache:function(name,value){state.cache[name]=value},warn:function(code,data){warningAt.apply(null,[code,data.line,data.char].concat(data.data))},on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)}.bind(this))}},emitter.removeAllListeners(),(extraModules||[]).forEach(function(func){func(api)}),state.tokens.prev=state.tokens.curr=state.tokens.next=state.syntax[\"(begin)\"],o&&o.ignoreDelimiters&&(Array.isArray(o.ignoreDelimiters)||(o.ignoreDelimiters=[o.ignoreDelimiters]),o.ignoreDelimiters.forEach(function(delimiterPair){delimiterPair.start&&delimiterPair.end&&(reIgnoreStr=escapeRegex(delimiterPair.start)+\"[\\\\s\\\\S]*?\"+escapeRegex(delimiterPair.end),reIgnore=RegExp(reIgnoreStr,\"ig\"),s=s.replace(reIgnore,function(match){return match.replace(/./g,\" \")}))})),lex=new Lexer(s),lex.on(\"warning\",function(ev){warningAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"error\",function(ev){errorAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"fatal\",function(ev){quit(\"E041\",ev.line,ev.from)}),lex.on(\"Identifier\",function(ev){emitter.emit(\"Identifier\",ev)}),lex.on(\"String\",function(ev){emitter.emit(\"String\",ev)}),lex.on(\"Number\",function(ev){emitter.emit(\"Number\",ev)}),lex.start();for(var name in o)_.has(o,name)&&checkOption(name,state.tokens.curr);assume(),combine(predefined,g||{}),comma.first=!0;try{switch(advance(),state.tokens.next.id){case\"{\":case\"[\":destructuringAssignOrJsonValue();break;default:directives(),state.directive[\"use strict\"]&&\"global\"!==state.option.strict&&warning(\"W097\",state.tokens.prev),statements()}\"(end)\"!==state.tokens.next.id&&quit(\"E041\",state.tokens.curr.line),state.funct[\"(scope)\"].unstack()}catch(err){if(!err||\"JSHintError\"!==err.name)throw err;var nt=state.tokens.next||{};JSHINT.errors.push({scope:\"(main)\",raw:err.raw,code:err.code,reason:err.message,line:err.line||nt.line,character:err.character||nt.from},null)}if(\"(main)\"===JSHINT.scope)for(o=o||{},i=0;JSHINT.internals.length>i;i+=1)k=JSHINT.internals[i],o.scope=k.elem,itself(k.value,o,g);return 0===JSHINT.errors.length};return itself.addModule=function(func){extraModules.push(func)},itself.addModule(style.register),itself.data=function(){var fu,f,i,j,n,globals,data={functions:[],options:state.option};itself.errors.length&&(data.errors=itself.errors),state.jsonMode&&(data.json=!0);var impliedGlobals=state.funct[\"(scope)\"].getImpliedGlobals();for(impliedGlobals.length>0&&(data.implieds=impliedGlobals),urls.length>0&&(data.urls=urls),globals=state.funct[\"(scope)\"].getUsedOrDefinedGlobals(),globals.length>0&&(data.globals=globals),i=1;functions.length>i;i+=1){for(f=functions[i],fu={},j=0;functionicity.length>j;j+=1)fu[functionicity[j]]=[];for(j=0;functionicity.length>j;j+=1)0===fu[functionicity[j]].length&&delete fu[functionicity[j]];fu.name=f[\"(name)\"],fu.param=f[\"(params)\"],fu.line=f[\"(line)\"],fu.character=f[\"(character)\"],fu.last=f[\"(last)\"],fu.lastcharacter=f[\"(lastcharacter)\"],fu.metrics={complexity:f[\"(metrics)\"].ComplexityCount,parameters:f[\"(metrics)\"].arity,statements:f[\"(metrics)\"].statementCount},data.functions.push(fu)}var unuseds=state.funct[\"(scope)\"].getUnuseds();unuseds.length>0&&(data.unused=unuseds);for(n in member)if(\"number\"==typeof member[n]){data.member=member;break}return data},itself.jshint=itself,itself}();\"object\"==typeof exports&&exports&&(exports.JSHINT=JSHINT)},{\"../lodash\":\"/node_modules/jshint/lodash.js\",\"./lex.js\":\"/node_modules/jshint/src/lex.js\",\"./messages.js\":\"/node_modules/jshint/src/messages.js\",\"./options.js\":\"/node_modules/jshint/src/options.js\",\"./reg.js\":\"/node_modules/jshint/src/reg.js\",\"./scope-manager.js\":\"/node_modules/jshint/src/scope-manager.js\",\"./state.js\":\"/node_modules/jshint/src/state.js\",\"./style.js\":\"/node_modules/jshint/src/style.js\",\"./vars.js\":\"/node_modules/jshint/src/vars.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/lex.js\":[function(_dereq_,module,exports){\"use strict\";function asyncTrigger(){var _checks=[];return{push:function(fn){_checks.push(fn)},check:function(){for(var check=0;_checks.length>check;++check)_checks[check]();_checks.splice(0,_checks.length)}}}function Lexer(source){var lines=source;\"string\"==typeof lines&&(lines=lines.replace(/\\r\\n/g,\"\\n\").replace(/\\r/g,\"\\n\").split(\"\\n\")),lines[0]&&\"#!\"===lines[0].substr(0,2)&&(-1!==lines[0].indexOf(\"node\")&&(state.option.node=!0),lines[0]=\"\"),this.emitter=new events.EventEmitter,this.source=source,this.setLines(lines),this.prereg=!0,this.line=0,this.char=1,this.from=1,this.input=\"\",this.inComment=!1,this.context=[],this.templateStarts=[];for(var i=0;state.option.indent>i;i+=1)state.tab+=\" \";this.ignoreLinterErrors=!1}var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,unicodeData=_dereq_(\"../data/ascii-identifier-data.js\"),asciiIdentifierStartTable=unicodeData.asciiIdentifierStartTable,asciiIdentifierPartTable=unicodeData.asciiIdentifierPartTable,Token={Identifier:1,Punctuator:2,NumericLiteral:3,StringLiteral:4,Comment:5,Keyword:6,NullLiteral:7,BooleanLiteral:8,RegExp:9,TemplateHead:10,TemplateMiddle:11,TemplateTail:12,NoSubstTemplate:13},Context={Block:1,Template:2};Lexer.prototype={_lines:[],inContext:function(ctxType){return this.context.length>0&&this.context[this.context.length-1].type===ctxType},pushContext:function(ctxType){this.context.push({type:ctxType})},popContext:function(){return this.context.pop()},isContext:function(context){return this.context.length>0&&this.context[this.context.length-1]===context},currentContext:function(){return this.context.length>0&&this.context[this.context.length-1]},getLines:function(){return this._lines=state.lines,this._lines},setLines:function(val){this._lines=val,state.lines=this._lines},peek:function(i){return this.input.charAt(i||0)},skip:function(i){i=i||1,this.char+=i,this.input=this.input.slice(i)},on:function(names,listener){names.split(\" \").forEach(function(name){this.emitter.on(name,listener)}.bind(this))},trigger:function(){this.emitter.emit.apply(this.emitter,Array.prototype.slice.call(arguments))},triggerAsync:function(type,args,checks,fn){checks.push(function(){fn()&&this.trigger(type,args)}.bind(this))},scanPunctuator:function(){var ch2,ch3,ch4,ch1=this.peek();switch(ch1){case\".\":if(/^[0-9]$/.test(this.peek(1)))return null;if(\".\"===this.peek(1)&&\".\"===this.peek(2))return{type:Token.Punctuator,value:\"...\"};case\"(\":case\")\":case\";\":case\",\":case\"[\":case\"]\":case\":\":case\"~\":case\"?\":return{type:Token.Punctuator,value:ch1};case\"{\":return this.pushContext(Context.Block),{type:Token.Punctuator,value:ch1};case\"}\":return this.inContext(Context.Block)&&this.popContext(),{type:Token.Punctuator,value:ch1};case\"#\":return{type:Token.Punctuator,value:ch1};case\"\":return null}return ch2=this.peek(1),ch3=this.peek(2),ch4=this.peek(3),\">\"===ch1&&\">\"===ch2&&\">\"===ch3&&\"=\"===ch4?{type:Token.Punctuator,value:\">>>=\"}:\"=\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"===\"}:\"!\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"!==\"}:\">\"===ch1&&\">\"===ch2&&\">\"===ch3?{type:Token.Punctuator,value:\">>>\"}:\"<\"===ch1&&\"<\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"<<=\"}:\">\"===ch1&&\">\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\">>=\"}:\"=\"===ch1&&\">\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:ch1===ch2&&\"+-<>&|\".indexOf(ch1)>=0?{type:Token.Punctuator,value:ch1+ch2}:\"<>=!+-*%&|^\".indexOf(ch1)>=0?\"=\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:{type:Token.Punctuator,value:ch1}:\"/\"===ch1?\"=\"===ch2?{type:Token.Punctuator,value:\"/=\"}:{type:Token.Punctuator,value:\"/\"}:null},scanComments:function(){function commentToken(label,body,opt){var special=[\"jshint\",\"jslint\",\"members\",\"member\",\"globals\",\"global\",\"exported\"],isSpecial=!1,value=label+body,commentType=\"plain\";return opt=opt||{},opt.isMultiline&&(value+=\"*/\"),body=body.replace(/\\n/g,\" \"),\"/*\"===label&&reg.fallsThrough.test(body)&&(isSpecial=!0,commentType=\"falls through\"),special.forEach(function(str){if(!isSpecial&&(\"//\"!==label||\"jshint\"===str)&&(\" \"===body.charAt(str.length)&&body.substr(0,str.length)===str&&(isSpecial=!0,label+=str,body=body.substr(str.length)),isSpecial||\" \"!==body.charAt(0)||\" \"!==body.charAt(str.length+1)||body.substr(1,str.length)!==str||(isSpecial=!0,label=label+\" \"+str,body=body.substr(str.length+1)),isSpecial))switch(str){case\"member\":commentType=\"members\";break;case\"global\":commentType=\"globals\";break;default:var options=body.split(\":\").map(function(v){return v.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")});if(2===options.length)switch(options[0]){case\"ignore\":switch(options[1]){case\"start\":self.ignoringLinterErrors=!0,isSpecial=!1;break;case\"end\":self.ignoringLinterErrors=!1,isSpecial=!1}}commentType=str}}),{type:Token.Comment,commentType:commentType,value:value,body:body,isSpecial:isSpecial,isMultiline:opt.isMultiline||!1,isMalformed:opt.isMalformed||!1}}var ch1=this.peek(),ch2=this.peek(1),rest=this.input.substr(2),startLine=this.line,startChar=this.char,self=this;if(\"*\"===ch1&&\"/\"===ch2)return this.trigger(\"error\",{code:\"E018\",line:startLine,character:startChar}),this.skip(2),null;if(\"/\"!==ch1||\"*\"!==ch2&&\"/\"!==ch2)return null;if(\"/\"===ch2)return this.skip(this.input.length),commentToken(\"//\",rest);var body=\"\";if(\"*\"===ch2){for(this.inComment=!0,this.skip(2);\"*\"!==this.peek()||\"/\"!==this.peek(1);)if(\"\"===this.peek()){if(body+=\"\\n\",!this.nextLine())return this.trigger(\"error\",{code:\"E017\",line:startLine,character:startChar}),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0,isMalformed:!0})}else body+=this.peek(),this.skip();return this.skip(2),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0})}},scanKeyword:function(){var result=/^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input),keywords=[\"if\",\"in\",\"do\",\"var\",\"for\",\"new\",\"try\",\"let\",\"this\",\"else\",\"case\",\"void\",\"with\",\"enum\",\"while\",\"break\",\"catch\",\"throw\",\"const\",\"yield\",\"class\",\"super\",\"return\",\"typeof\",\"delete\",\"switch\",\"export\",\"import\",\"default\",\"finally\",\"extends\",\"function\",\"continue\",\"debugger\",\"instanceof\"];return result&&keywords.indexOf(result[0])>=0?{type:Token.Keyword,value:result[0]}:null},scanIdentifier:function(){function isNonAsciiIdentifierStart(code){return code>256}function isNonAsciiIdentifierPart(code){return code>256}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function removeEscapeSequences(id){return id.replace(/\\\\u([0-9a-fA-F]{4})/g,function(m0,codepoint){return String.fromCharCode(parseInt(codepoint,16))})}var type,char,id=\"\",index=0,readUnicodeEscapeSequence=function(){if(index+=1,\"u\"!==this.peek(index))return null;var code,ch1=this.peek(index+1),ch2=this.peek(index+2),ch3=this.peek(index+3),ch4=this.peek(index+4);return isHexDigit(ch1)&&isHexDigit(ch2)&&isHexDigit(ch3)&&isHexDigit(ch4)?(code=parseInt(ch1+ch2+ch3+ch4,16),asciiIdentifierPartTable[code]||isNonAsciiIdentifierPart(code)?(index+=5,\"\\\\u\"+ch1+ch2+ch3+ch4):null):null}.bind(this),getIdentifierStart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierStartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierStart(code)?(index+=1,chr):null}.bind(this),getIdentifierPart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierPartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierPart(code)?(index+=1,chr):null}.bind(this);if(char=getIdentifierStart(),null===char)return null;for(id=char;char=getIdentifierPart(),null!==char;)id+=char;switch(id){case\"true\":case\"false\":type=Token.BooleanLiteral;break;case\"null\":type=Token.NullLiteral;break;default:type=Token.Identifier}return{type:type,value:removeEscapeSequences(id),text:id,tokenLength:id.length}},scanNumericLiteral:function(){function isDecimalDigit(str){return/^[0-9]$/.test(str)}function isOctalDigit(str){return/^[0-7]$/.test(str)}function isBinaryDigit(str){return/^[01]$/.test(str)}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function isIdentifierStart(ch){return\"$\"===ch||\"_\"===ch||\"\\\\\"===ch||ch>=\"a\"&&\"z\">=ch||ch>=\"A\"&&\"Z\">=ch}var bad,index=0,value=\"\",length=this.input.length,char=this.peek(index),isAllowedDigit=isDecimalDigit,base=10,isLegacy=!1;if(\".\"!==char&&!isDecimalDigit(char))return null;if(\".\"!==char){for(value=this.peek(index),index+=1,char=this.peek(index),\"0\"===value&&((\"x\"===char||\"X\"===char)&&(isAllowedDigit=isHexDigit,base=16,index+=1,value+=char),(\"o\"===char||\"O\"===char)&&(isAllowedDigit=isOctalDigit,base=8,state.inES6(!0)||this.trigger(\"warning\",{code:\"W119\",line:this.line,character:this.char,data:[\"Octal integer literal\",\"6\"]}),index+=1,value+=char),(\"b\"===char||\"B\"===char)&&(isAllowedDigit=isBinaryDigit,base=2,state.inES6(!0)||this.trigger(\"warning\",{code:\"W119\",line:this.line,character:this.char,data:[\"Binary integer literal\",\"6\"]}),index+=1,value+=char),isOctalDigit(char)&&(isAllowedDigit=isOctalDigit,base=8,isLegacy=!0,bad=!1,index+=1,value+=char),!isOctalDigit(char)&&isDecimalDigit(char)&&(index+=1,value+=char));length>index;){if(char=this.peek(index),isLegacy&&isDecimalDigit(char))bad=!0;else if(!isAllowedDigit(char))break;value+=char,index+=1}if(isAllowedDigit!==isDecimalDigit)return!isLegacy&&2>=value.length?{type:Token.NumericLiteral,value:value,isMalformed:!0}:length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isLegacy:isLegacy,isMalformed:!1}}if(\".\"===char)for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1;if(\"e\"===char||\"E\"===char){if(value+=char,index+=1,char=this.peek(index),(\"+\"===char||\"-\"===char)&&(value+=this.peek(index),index+=1),char=this.peek(index),!isDecimalDigit(char))return null;for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isMalformed:!isFinite(value)}},scanEscapeSequence:function(checks){var allowNewLine=!1,jump=1;this.skip();var char=this.peek();switch(char){case\"'\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\'\"]},checks,function(){return state.jsonMode});break;case\"b\":char=\"\\\\b\";break;case\"f\":char=\"\\\\f\";break;case\"n\":char=\"\\\\n\";break;case\"r\":char=\"\\\\r\";break;case\"t\":char=\"\\\\t\";break;case\"0\":char=\"\\\\0\";var n=parseInt(this.peek(1),10);this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return n>=0&&7>=n&&state.isStrict()});break;case\"u\":var hexCode=this.input.substr(1,4),code=parseInt(hexCode,16);isNaN(code)&&this.trigger(\"warning\",{code:\"W052\",line:this.line,character:this.char,data:[\"u\"+hexCode]}),char=String.fromCharCode(code),jump=5;break;case\"v\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\v\"]},checks,function(){return state.jsonMode}),char=\"\u000b\";break;case\"x\":var x=parseInt(this.input.substr(1,2),16);this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\x-\"]},checks,function(){return state.jsonMode}),char=String.fromCharCode(x),jump=3;break;case\"\\\\\":char=\"\\\\\\\\\";break;case'\"':char='\\\\\"';break;case\"/\":break;case\"\":allowNewLine=!0,char=\"\"}return{\"char\":char,jump:jump,allowNewLine:allowNewLine}},scanTemplateLiteral:function(checks){var tokenType,ch,value=\"\",startLine=this.line,startChar=this.char,depth=this.templateStarts.length;if(!state.inES6(!0))return null;if(\"`\"===this.peek())tokenType=Token.TemplateHead,this.templateStarts.push({line:this.line,\"char\":this.char}),depth=this.templateStarts.length,this.skip(1),this.pushContext(Context.Template);else{if(!this.inContext(Context.Template)||\"}\"!==this.peek())return null;tokenType=Token.TemplateMiddle}for(;\"`\"!==this.peek();){for(;\"\"===(ch=this.peek());)if(value+=\"\\n\",!this.nextLine()){var startPos=this.templateStarts.pop();return this.trigger(\"error\",{code:\"E052\",line:startPos.line,character:startPos.char}),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,depth:depth,context:this.popContext()}}if(\"$\"===ch&&\"{\"===this.peek(1))return value+=\"${\",this.skip(2),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.currentContext()};\nif(\"\\\\\"===ch){var escape=this.scanEscapeSequence(checks);value+=escape.char,this.skip(escape.jump)}else\"`\"!==ch&&(value+=ch,this.skip(1))}return tokenType=tokenType===Token.TemplateHead?Token.NoSubstTemplate:Token.TemplateTail,this.skip(1),this.templateStarts.pop(),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.popContext()}},scanStringLiteral:function(checks){var quote=this.peek();if('\"'!==quote&&\"'\"!==quote)return null;this.triggerAsync(\"warning\",{code:\"W108\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&'\"'!==quote});var value=\"\",startLine=this.line,startChar=this.char,allowNewLine=!1;for(this.skip();this.peek()!==quote;)if(\"\"===this.peek()){if(allowNewLine?(allowNewLine=!1,this.triggerAsync(\"warning\",{code:\"W043\",line:this.line,character:this.char},checks,function(){return!state.option.multistr}),this.triggerAsync(\"warning\",{code:\"W042\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&state.option.multistr})):this.trigger(\"warning\",{code:\"W112\",line:this.line,character:this.char}),!this.nextLine())return this.trigger(\"error\",{code:\"E029\",line:startLine,character:startChar}),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,quote:quote}}else{allowNewLine=!1;var char=this.peek(),jump=1;if(\" \">char&&this.trigger(\"warning\",{code:\"W113\",line:this.line,character:this.char,data:[\"<non-printable>\"]}),\"\\\\\"===char){var parsed=this.scanEscapeSequence(checks);char=parsed.char,jump=parsed.jump,allowNewLine=parsed.allowNewLine}value+=char,this.skip(jump)}return this.skip(),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,quote:quote}},scanRegExp:function(){var terminated,index=0,length=this.input.length,char=this.peek(),value=char,body=\"\",flags=[],malformed=!1,isCharSet=!1,scanUnexpectedChars=function(){\" \">char&&(malformed=!0,this.trigger(\"warning\",{code:\"W048\",line:this.line,character:this.char})),\"<\"===char&&(malformed=!0,this.trigger(\"warning\",{code:\"W049\",line:this.line,character:this.char,data:[char]}))}.bind(this);if(!this.prereg||\"/\"!==char)return null;for(index+=1,terminated=!1;length>index;)if(char=this.peek(index),value+=char,body+=char,isCharSet)\"]\"===char&&(\"\\\\\"!==this.peek(index-1)||\"\\\\\"===this.peek(index-2))&&(isCharSet=!1),\"\\\\\"===char&&(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars()),index+=1;else{if(\"\\\\\"===char){if(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars(),\"/\"===char){index+=1;continue}if(\"[\"===char){index+=1;continue}}if(\"[\"!==char){if(\"/\"===char){body=body.substr(0,body.length-1),terminated=!0,index+=1;break}index+=1}else isCharSet=!0,index+=1}if(!terminated)return this.trigger(\"error\",{code:\"E015\",line:this.line,character:this.from}),void this.trigger(\"fatal\",{line:this.line,from:this.from});for(;length>index&&(char=this.peek(index),/[gim]/.test(char));)flags.push(char),value+=char,index+=1;try{RegExp(body,flags.join(\"\"))}catch(err){malformed=!0,this.trigger(\"error\",{code:\"E016\",line:this.line,character:this.char,data:[err.message]})}return{type:Token.RegExp,value:value,flags:flags,isMalformed:malformed}},scanNonBreakingSpaces:function(){return state.option.nonbsp?this.input.search(/(\\u00A0)/):-1},scanUnsafeChars:function(){return this.input.search(reg.unsafeChars)},next:function(checks){this.from=this.char;var start;if(/\\s/.test(this.peek()))for(start=this.char;/\\s/.test(this.peek());)this.from+=1,this.skip();var match=this.scanComments()||this.scanStringLiteral(checks)||this.scanTemplateLiteral(checks);return match?match:(match=this.scanRegExp()||this.scanPunctuator()||this.scanKeyword()||this.scanIdentifier()||this.scanNumericLiteral(),match?(this.skip(match.tokenLength||match.value.length),match):null)},nextLine:function(){var char;if(this.line>=this.getLines().length)return!1;this.input=this.getLines()[this.line],this.line+=1,this.char=1,this.from=1;var inputTrimmed=this.input.trim(),startsWith=function(){return _.some(arguments,function(prefix){return 0===inputTrimmed.indexOf(prefix)})},endsWith=function(){return _.some(arguments,function(suffix){return-1!==inputTrimmed.indexOf(suffix,inputTrimmed.length-suffix.length)})};if(this.ignoringLinterErrors===!0&&(startsWith(\"/*\",\"//\")||this.inComment&&endsWith(\"*/\")||(this.input=\"\")),char=this.scanNonBreakingSpaces(),char>=0&&this.trigger(\"warning\",{code:\"W125\",line:this.line,character:char+1}),this.input=this.input.replace(/\\t/g,state.tab),char=this.scanUnsafeChars(),char>=0&&this.trigger(\"warning\",{code:\"W100\",line:this.line,character:char}),!this.ignoringLinterErrors&&state.option.maxlen&&state.option.maxlen<this.input.length){var inComment=this.inComment||startsWith.call(inputTrimmed,\"//\")||startsWith.call(inputTrimmed,\"/*\"),shouldTriggerError=!inComment||!reg.maxlenException.test(inputTrimmed);shouldTriggerError&&this.trigger(\"warning\",{code:\"W101\",line:this.line,character:this.input.length})}return!0},start:function(){this.nextLine()},token:function(){function isReserved(token,isProperty){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(isProperty)return!1}return!0}for(var token,checks=asyncTrigger(),create=function(type,value,isProperty,token){var obj;if(\"(endline)\"!==type&&\"(end)\"!==type&&(this.prereg=!1),\"(punctuator)\"===type){switch(value){case\".\":case\")\":case\"~\":case\"#\":case\"]\":case\"++\":case\"--\":this.prereg=!1;break;default:this.prereg=!0}obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"])}return\"(identifier)\"===type&&((\"return\"===value||\"case\"===value||\"typeof\"===value)&&(this.prereg=!0),_.has(state.syntax,value)&&(obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"]),isReserved(obj,isProperty&&\"(identifier)\"===type)||(obj=null))),obj||(obj=Object.create(state.syntax[type])),obj.identifier=\"(identifier)\"===type,obj.type=obj.type||type,obj.value=value,obj.line=this.line,obj.character=this.char,obj.from=this.from,obj.identifier&&token&&(obj.raw_text=token.text||token.value),token&&token.startLine&&token.startLine!==this.line&&(obj.startLine=token.startLine),token&&token.context&&(obj.context=token.context),token&&token.depth&&(obj.depth=token.depth),token&&token.isUnclosed&&(obj.isUnclosed=token.isUnclosed),isProperty&&obj.identifier&&(obj.isProperty=isProperty),obj.check=checks.check,obj}.bind(this);;){if(!this.input.length)return this.nextLine()?create(\"(endline)\",\"\"):this.exhausted?null:(this.exhausted=!0,create(\"(end)\",\"\"));if(token=this.next(checks))switch(token.type){case Token.StringLiteral:return this.triggerAsync(\"String\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value,quote:token.quote},checks,function(){return!0}),create(\"(string)\",token.value,null,token);case Token.TemplateHead:return this.trigger(\"TemplateHead\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template)\",token.value,null,token);case Token.TemplateMiddle:return this.trigger(\"TemplateMiddle\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template middle)\",token.value,null,token);case Token.TemplateTail:return this.trigger(\"TemplateTail\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(template tail)\",token.value,null,token);case Token.NoSubstTemplate:return this.trigger(\"NoSubstTemplate\",{line:this.line,\"char\":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create(\"(no subst template)\",token.value,null,token);case Token.Identifier:this.triggerAsync(\"Identifier\",{line:this.line,\"char\":this.char,from:this.form,name:token.value,raw_name:token.text,isProperty:\".\"===state.tokens.curr.id},checks,function(){return!0});case Token.Keyword:case Token.NullLiteral:case Token.BooleanLiteral:return create(\"(identifier)\",token.value,\".\"===state.tokens.curr.id,token);case Token.NumericLiteral:return token.isMalformed&&this.trigger(\"warning\",{code:\"W045\",line:this.line,character:this.char,data:[token.value]}),this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"0x-\"]},checks,function(){return 16===token.base&&state.jsonMode}),this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return state.isStrict()&&8===token.base&&token.isLegacy}),this.trigger(\"Number\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,base:token.base,isMalformed:token.malformed}),create(\"(number)\",token.value);case Token.RegExp:return create(\"(regexp)\",token.value);case Token.Comment:if(state.tokens.curr.comment=!0,token.isSpecial)return{id:\"(comment)\",value:token.value,body:token.body,type:token.commentType,isSpecial:token.isSpecial,line:this.line,character:this.char,from:this.from};break;case\"\":break;default:return create(\"(punctuator)\",token.value)}else this.input.length&&(this.trigger(\"error\",{code:\"E024\",line:this.line,character:this.char,data:[this.peek()]}),this.input=\"\")}}},exports.Lexer=Lexer,exports.Context=Context},{\"../data/ascii-identifier-data.js\":\"/node_modules/jshint/data/ascii-identifier-data.js\",\"../lodash\":\"/node_modules/jshint/lodash.js\",\"./reg.js\":\"/node_modules/jshint/src/reg.js\",\"./state.js\":\"/node_modules/jshint/src/state.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/messages.js\":[function(_dereq_,module,exports){\"use strict\";var _=_dereq_(\"../lodash\"),errors={E001:\"Bad option: '{a}'.\",E002:\"Bad option value.\",E003:\"Expected a JSON value.\",E004:\"Input is neither a string nor an array of strings.\",E005:\"Input is empty.\",E006:\"Unexpected early end of program.\",E007:'Missing \"use strict\" statement.',E008:\"Strict violation.\",E009:\"Option 'validthis' can't be used in a global scope.\",E010:\"'with' is not allowed in strict mode.\",E011:\"'{a}' has already been declared.\",E012:\"const '{a}' is initialized to 'undefined'.\",E013:\"Attempting to override '{a}' which is a constant.\",E014:\"A regular expression literal can be confused with '/='.\",E015:\"Unclosed regular expression.\",E016:\"Invalid regular expression.\",E017:\"Unclosed comment.\",E018:\"Unbegun comment.\",E019:\"Unmatched '{a}'.\",E020:\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",E021:\"Expected '{a}' and instead saw '{b}'.\",E022:\"Line breaking error '{a}'.\",E023:\"Missing '{a}'.\",E024:\"Unexpected '{a}'.\",E025:\"Missing ':' on a case clause.\",E026:\"Missing '}' to match '{' from line {a}.\",E027:\"Missing ']' to match '[' from line {a}.\",E028:\"Illegal comma.\",E029:\"Unclosed string.\",E030:\"Expected an identifier and instead saw '{a}'.\",E031:\"Bad assignment.\",E032:\"Expected a small integer or 'false' and instead saw '{a}'.\",E033:\"Expected an operator and instead saw '{a}'.\",E034:\"get/set are ES5 features.\",E035:\"Missing property name.\",E036:\"Expected to see a statement and instead saw a block.\",E037:null,E038:null,E039:\"Function declarations are not invocable. Wrap the whole function invocation in parens.\",E040:\"Each value should have its own case label.\",E041:\"Unrecoverable syntax error.\",E042:\"Stopping.\",E043:\"Too many errors.\",E044:null,E045:\"Invalid for each loop.\",E046:\"A yield statement shall be within a generator function (with syntax: `function*`)\",E047:null,E048:\"{a} declaration not directly within block.\",E049:\"A {a} cannot be named '{b}'.\",E050:\"Mozilla acequires the yield expression to be parenthesized here.\",E051:null,E052:\"Unclosed template literal.\",E053:\"Export declaration must be in global scope.\",E054:\"Class properties must be methods. Expected '(' but instead saw '{a}'.\",E055:\"The '{a}' option cannot be set after any executable code.\",E056:\"'{a}' was used before it was declared, which is illegal for '{b}' variables.\",E057:\"Invalid meta property: '{a}.{b}'.\",E058:\"Missing semicolon.\"},warnings={W001:\"'hasOwnProperty' is a really bad name.\",W002:\"Value of '{a}' may be overwritten in IE 8 and earlier.\",W003:\"'{a}' was used before it was defined.\",W004:\"'{a}' is already defined.\",W005:\"A dot following a number can be confused with a decimal point.\",W006:\"Confusing minuses.\",W007:\"Confusing plusses.\",W008:\"A leading decimal point can be confused with a dot: '{a}'.\",W009:\"The array literal notation [] is preferable.\",W010:\"The object literal notation {} is preferable.\",W011:null,W012:null,W013:null,W014:\"Bad line breaking before '{a}'.\",W015:null,W016:\"Unexpected use of '{a}'.\",W017:\"Bad operand.\",W018:\"Confusing use of '{a}'.\",W019:\"Use the isNaN function to compare with NaN.\",W020:\"Read only.\",W021:\"Reassignment of '{a}', which is is a {b}. Use 'var' or 'let' to declare bindings that may change.\",W022:\"Do not assign to the exception parameter.\",W023:\"Expected an identifier in an assignment and instead saw a function invocation.\",W024:\"Expected an identifier and instead saw '{a}' (a reserved word).\",W025:\"Missing name in function declaration.\",W026:\"Inner functions should be listed at the top of the outer function.\",W027:\"Unreachable '{a}' after '{b}'.\",W028:\"Label '{a}' on {b} statement.\",W030:\"Expected an assignment or function call and instead saw an expression.\",W031:\"Do not use 'new' for side effects.\",W032:\"Unnecessary semicolon.\",W033:\"Missing semicolon.\",W034:'Unnecessary directive \"{a}\".',W035:\"Empty block.\",W036:\"Unexpected /*member '{a}'.\",W037:\"'{a}' is a statement label.\",W038:\"'{a}' used out of scope.\",W039:\"'{a}' is not allowed.\",W040:\"Possible strict violation.\",W041:\"Use '{a}' to compare with '{b}'.\",W042:\"Avoid EOL escaping.\",W043:\"Bad escaping of EOL. Use option multistr if needed.\",W044:\"Bad or unnecessary escaping.\",W045:\"Bad number '{a}'.\",W046:\"Don't use extra leading zeros '{a}'.\",W047:\"A trailing decimal point can be confused with a dot: '{a}'.\",W048:\"Unexpected control character in regular expression.\",W049:\"Unexpected escaped character '{a}' in regular expression.\",W050:\"JavaScript URL.\",W051:\"Variables should not be deleted.\",W052:\"Unexpected '{a}'.\",W053:\"Do not use {a} as a constructor.\",W054:\"The Function constructor is a form of eval.\",W055:\"A constructor name should start with an uppercase letter.\",W056:\"Bad constructor.\",W057:\"Weird construction. Is 'new' necessary?\",W058:\"Missing '()' invoking a constructor.\",W059:\"Avoid arguments.{a}.\",W060:\"document.write can be a form of eval.\",W061:\"eval can be harmful.\",W062:\"Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.\",W063:\"Math is not a function.\",W064:\"Missing 'new' prefix when invoking a constructor.\",W065:\"Missing radix parameter.\",W066:\"Implied eval. Consider passing a function instead of a string.\",W067:\"Bad invocation.\",W068:\"Wrapping non-IIFE function literals in parens is unnecessary.\",W069:\"['{a}'] is better written in dot notation.\",W070:\"Extra comma. (it breaks older versions of IE)\",W071:\"This function has too many statements. ({a})\",W072:\"This function has too many parameters. ({a})\",W073:\"Blocks are nested too deeply. ({a})\",W074:\"This function's cyclomatic complexity is too high. ({a})\",W075:\"Duplicate {a} '{b}'.\",W076:\"Unexpected parameter '{a}' in get {b} function.\",W077:\"Expected a single parameter in set {a} function.\",W078:\"Setter is defined without getter.\",W079:\"Redefinition of '{a}'.\",W080:\"It's not necessary to initialize '{a}' to 'undefined'.\",W081:null,W082:\"Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.\",W083:\"Don't make functions within a loop.\",W084:\"Assignment in conditional expression\",W085:\"Don't use 'with'.\",W086:\"Expected a 'break' statement before '{a}'.\",W087:\"Forgotten 'debugger' statement?\",W088:\"Creating global 'for' variable. Should be 'for (var {a} ...'.\",W089:\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\",W090:\"'{a}' is not a statement label.\",W091:null,W093:\"Did you mean to return a conditional instead of an assignment?\",W094:\"Unexpected comma.\",W095:\"Expected a string and instead saw {a}.\",W096:\"The '{a}' key may produce unexpected results.\",W097:'Use the function form of \"use strict\".',W098:\"'{a}' is defined but never used.\",W099:null,W100:\"This character may get silently deleted by one or more browsers.\",W101:\"Line is too long.\",W102:null,W103:\"The '{a}' property is deprecated.\",W104:\"'{a}' is available in ES{b} (use 'esversion: {b}') or Mozilla JS extensions (use moz).\",W105:\"Unexpected {a} in '{b}'.\",W106:\"Identifier '{a}' is not in camel case.\",W107:\"Script URL.\",W108:\"Strings must use doublequote.\",W109:\"Strings must use singlequote.\",W110:\"Mixed double and single quotes.\",W112:\"Unclosed string.\",W113:\"Control character in string: {a}.\",W114:\"Avoid {a}.\",W115:\"Octal literals are not allowed in strict mode.\",W116:\"Expected '{a}' and instead saw '{b}'.\",W117:\"'{a}' is not defined.\",W118:\"'{a}' is only available in Mozilla JavaScript extensions (use moz option).\",W119:\"'{a}' is only available in ES{b} (use 'esversion: {b}').\",W120:\"You might be leaking a variable ({a}) here.\",W121:\"Extending prototype of native object: '{a}'.\",W122:\"Invalid typeof value '{a}'\",W123:\"'{a}' is already defined in outer scope.\",W124:\"A generator function shall contain a yield statement.\",W125:\"This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp\",W126:\"Unnecessary grouping operator.\",W127:\"Unexpected use of a comma operator.\",W128:\"Empty array elements acequire elision=true.\",W129:\"'{a}' is defined in a future version of JavaScript. Use a different variable name to avoid migration issues.\",W130:\"Invalid element after rest element.\",W131:\"Invalid parameter after rest parameter.\",W132:\"`var` declarations are forbidden. Use `let` or `const` instead.\",W133:\"Invalid for-{a} loop left-hand-side: {b}.\",W134:\"The '{a}' option is only available when linting ECMAScript {b} code.\",W135:\"{a} may not be supported by non-browser environments.\",W136:\"'{a}' must be in function scope.\",W137:\"Empty destructuring.\",W138:\"Regular parameters should not come after default parameters.\"},info={I001:\"Comma warnings can be turned off with 'laxcomma'.\",I002:null,I003:\"ES5 option is now set per default\"};exports.errors={},exports.warnings={},exports.info={},_.each(errors,function(desc,code){exports.errors[code]={code:code,desc:desc}}),_.each(warnings,function(desc,code){exports.warnings[code]={code:code,desc:desc}}),_.each(info,function(desc,code){exports.info[code]={code:code,desc:desc}})},{\"../lodash\":\"/node_modules/jshint/lodash.js\"}],\"/node_modules/jshint/src/name-stack.js\":[function(_dereq_,module){\"use strict\";function NameStack(){this._stack=[]}Object.defineProperty(NameStack.prototype,\"length\",{get:function(){return this._stack.length}}),NameStack.prototype.push=function(){this._stack.push(null)},NameStack.prototype.pop=function(){this._stack.pop()},NameStack.prototype.set=function(token){this._stack[this.length-1]=token},NameStack.prototype.infer=function(){var type,nameToken=this._stack[this.length-1],prefix=\"\";return nameToken&&\"class\"!==nameToken.type||(nameToken=this._stack[this.length-2]),nameToken?(type=nameToken.type,\"(string)\"!==type&&\"(number)\"!==type&&\"(identifier)\"!==type&&\"default\"!==type?\"(expression)\":(nameToken.accessorType&&(prefix=nameToken.accessorType+\" \"),prefix+nameToken.value)):\"(empty)\"},module.exports=NameStack},{}],\"/node_modules/jshint/src/options.js\":[function(_dereq_,module,exports){\"use strict\";exports.bool={enforcing:{bitwise:!0,freeze:!0,camelcase:!0,curly:!0,eqeqeq:!0,futurehostile:!0,notypeof:!0,es3:!0,es5:!0,forin:!0,funcscope:!0,immed:!0,iterator:!0,newcap:!0,noarg:!0,nocomma:!0,noempty:!0,nonbsp:!0,nonew:!0,undef:!0,singleGroups:!1,varstmt:!1,enforceall:!1},relaxing:{asi:!0,multistr:!0,debug:!0,boss:!0,evil:!0,globalstrict:!0,plusplus:!0,proto:!0,scripturl:!0,sub:!0,supernew:!0,laxbreak:!0,laxcomma:!0,validthis:!0,withstmt:!0,moz:!0,noyield:!0,eqnull:!0,lastsemic:!0,loopfunc:!0,expr:!0,esnext:!0,elision:!0},environments:{mootools:!0,couch:!0,jasmine:!0,jquery:!0,node:!0,qunit:!0,rhino:!0,shelljs:!0,prototypejs:!0,yui:!0,mocha:!0,module:!0,wsh:!0,worker:!0,nonstandard:!0,browser:!0,browserify:!0,devel:!0,dojo:!0,typed:!0,phantom:!0},obsolete:{onecase:!0,regexp:!0,regexdash:!0}},exports.val={maxlen:!1,indent:!1,maxerr:!1,predef:!1,globals:!1,quotmark:!1,scope:!1,maxstatements:!1,maxdepth:!1,maxparams:!1,maxcomplexity:!1,shadow:!1,strict:!0,unused:!0,latedef:!1,ignore:!1,ignoreDelimiters:!1,esversion:5},exports.inverted={bitwise:!0,forin:!0,newcap:!0,plusplus:!0,regexp:!0,undef:!0,eqeqeq:!0,strict:!0},exports.validNames=Object.keys(exports.val).concat(Object.keys(exports.bool.relaxing)).concat(Object.keys(exports.bool.enforcing)).concat(Object.keys(exports.bool.obsolete)).concat(Object.keys(exports.bool.environments)),exports.renamed={eqeq:\"eqeqeq\",windows:\"wsh\",sloppy:\"strict\"},exports.removed={nomen:!0,onevar:!0,passfail:!0,white:!0,gcl:!0,smarttabs:!0,trailing:!0},exports.noenforceall={varstmt:!0,strict:!0}},{}],\"/node_modules/jshint/src/reg.js\":[function(_dereq_,module,exports){\"use strict\";exports.unsafeString=/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,exports.unsafeChars=/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEsc=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEscGlobal=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,exports.starSlash=/\\*\\//,exports.identifier=/^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,exports.javascriptURL=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i,exports.fallsThrough=/^\\s*falls?\\sthrough\\s*$/,exports.maxlenException=/^(?:(?:\\/\\/|\\/\\*|\\*) ?)?[^ ]+$/},{}],\"/node_modules/jshint/src/scope-manager.js\":[function(_dereq_,module){\"use strict\";var _=_dereq_(\"../lodash\"),events=_dereq_(\"events\"),marker={},scopeManager=function(state,predefined,exported,declared){function _newScope(type){_current={\"(labels)\":Object.create(null),\"(usages)\":Object.create(null),\"(breakLabels)\":Object.create(null),\"(parent)\":_current,\"(type)\":type,\"(params)\":\"functionparams\"===type||\"catchparams\"===type?[]:null},_scopeStack.push(_current)}function warning(code,token){emitter.emit(\"warning\",{code:code,token:token,data:_.slice(arguments,2)})}function error(code,token){emitter.emit(\"warning\",{code:code,token:token,data:_.slice(arguments,2)})}function _setupUsages(labelName){_current[\"(usages)\"][labelName]||(_current[\"(usages)\"][labelName]={\"(modified)\":[],\"(reassigned)\":[],\"(tokens)\":[]})}function _checkForUnused(){if(\"functionparams\"===_current[\"(type)\"])return _checkParams(),void 0;var curentLabels=_current[\"(labels)\"];for(var labelName in curentLabels)curentLabels[labelName]&&\"exception\"!==curentLabels[labelName][\"(type)\"]&&curentLabels[labelName][\"(unused)\"]&&_warnUnused(labelName,curentLabels[labelName][\"(token)\"],\"var\")}function _checkParams(){var params=_current[\"(params)\"];if(params)for(var unused_opt,param=params.pop();param;){var label=_current[\"(labels)\"][param];if(unused_opt=_getUnusedOption(state.funct[\"(unusedOption)\"]),\"undefined\"===param)return;if(label[\"(unused)\"])_warnUnused(param,label[\"(token)\"],\"param\",state.funct[\"(unusedOption)\"]);else if(\"last-param\"===unused_opt)return;param=params.pop()}}function _getLabel(labelName){for(var i=_scopeStack.length-1;i>=0;--i){var scopeLabels=_scopeStack[i][\"(labels)\"];if(scopeLabels[labelName])return scopeLabels}}function usedSoFarInCurrentFunction(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current[\"(usages)\"][labelName])return current[\"(usages)\"][labelName];if(current===_currentFunctBody)break}return!1}function _checkOuterShadow(labelName,token){if(\"outer\"===state.option.shadow)for(var isGlobal=\"global\"===_currentFunctBody[\"(type)\"],isNewFunction=\"functionparams\"===_current[\"(type)\"],outsideCurrentFunction=!isGlobal,i=0;_scopeStack.length>i;i++){var stackItem=_scopeStack[i];isNewFunction||_scopeStack[i+1]!==_currentFunctBody||(outsideCurrentFunction=!1),outsideCurrentFunction&&stackItem[\"(labels)\"][labelName]&&warning(\"W123\",token,labelName),stackItem[\"(breakLabels)\"][labelName]&&warning(\"W123\",token,labelName)}}function _latedefWarning(type,labelName,token){state.option.latedef&&(state.option.latedef===!0&&\"function\"===type||\"function\"!==type)&&warning(\"W003\",token,labelName)}var _current,_scopeStack=[];_newScope(\"global\"),_current[\"(predefined)\"]=predefined;var _currentFunctBody=_current,usedPredefinedAndGlobals=Object.create(null),impliedGlobals=Object.create(null),unuseds=[],emitter=new events.EventEmitter,_getUnusedOption=function(unused_opt){return void 0===unused_opt&&(unused_opt=state.option.unused),unused_opt===!0&&(unused_opt=\"last-param\"),unused_opt},_warnUnused=function(name,tkn,type,unused_opt){var line=tkn.line,chr=tkn.from,raw_name=tkn.raw_text||name;unused_opt=_getUnusedOption(unused_opt);var warnable_types={vars:[\"var\"],\"last-param\":[\"var\",\"param\"],strict:[\"var\",\"param\",\"last-param\"]};unused_opt&&warnable_types[unused_opt]&&-1!==warnable_types[unused_opt].indexOf(type)&&warning(\"W098\",{line:line,from:chr},raw_name),(unused_opt||\"var\"===type)&&unuseds.push({name:name,line:line,character:chr})},scopeManagerInst={on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)})},isPredefined:function(labelName){return!this.has(labelName)&&_.has(_scopeStack[0][\"(predefined)\"],labelName)},stack:function(type){var previousScope=_current;_newScope(type),type||\"functionparams\"!==previousScope[\"(type)\"]||(_current[\"(isFuncBody)\"]=!0,_current[\"(context)\"]=_currentFunctBody,_currentFunctBody=_current)},unstack:function(){var i,j,subScope=_scopeStack.length>1?_scopeStack[_scopeStack.length-2]:null,isUnstackingFunctionBody=_current===_currentFunctBody,isUnstackingFunctionParams=\"functionparams\"===_current[\"(type)\"],isUnstackingFunctionOuter=\"functionouter\"===_current[\"(type)\"],currentUsages=_current[\"(usages)\"],currentLabels=_current[\"(labels)\"],usedLabelNameList=Object.keys(currentUsages);for(currentUsages.__proto__&&-1===usedLabelNameList.indexOf(\"__proto__\")&&usedLabelNameList.push(\"__proto__\"),i=0;usedLabelNameList.length>i;i++){var usedLabelName=usedLabelNameList[i],usage=currentUsages[usedLabelName],usedLabel=currentLabels[usedLabelName];if(usedLabel){var usedLabelType=usedLabel[\"(type)\"];if(usedLabel[\"(useOutsideOfScope)\"]&&!state.option.funcscope){var usedTokens=usage[\"(tokens)\"];if(usedTokens)for(j=0;usedTokens.length>j;j++)usedLabel[\"(function)\"]===usedTokens[j][\"(function)\"]&&error(\"W038\",usedTokens[j],usedLabelName)}if(_current[\"(labels)\"][usedLabelName][\"(unused)\"]=!1,\"const\"===usedLabelType&&usage[\"(modified)\"])for(j=0;usage[\"(modified)\"].length>j;j++)error(\"E013\",usage[\"(modified)\"][j],usedLabelName);if((\"function\"===usedLabelType||\"class\"===usedLabelType)&&usage[\"(reassigned)\"])for(j=0;usage[\"(reassigned)\"].length>j;j++)error(\"W021\",usage[\"(reassigned)\"][j],usedLabelName,usedLabelType)}else if(isUnstackingFunctionOuter&&(state.funct[\"(isCapturing)\"]=!0),subScope)if(subScope[\"(usages)\"][usedLabelName]){var subScopeUsage=subScope[\"(usages)\"][usedLabelName];subScopeUsage[\"(modified)\"]=subScopeUsage[\"(modified)\"].concat(usage[\"(modified)\"]),subScopeUsage[\"(tokens)\"]=subScopeUsage[\"(tokens)\"].concat(usage[\"(tokens)\"]),subScopeUsage[\"(reassigned)\"]=subScopeUsage[\"(reassigned)\"].concat(usage[\"(reassigned)\"]),subScopeUsage[\"(onlyUsedSubFunction)\"]=!1}else subScope[\"(usages)\"][usedLabelName]=usage,isUnstackingFunctionBody&&(subScope[\"(usages)\"][usedLabelName][\"(onlyUsedSubFunction)\"]=!0);else if(\"boolean\"==typeof _current[\"(predefined)\"][usedLabelName]){if(delete declared[usedLabelName],usedPredefinedAndGlobals[usedLabelName]=marker,_current[\"(predefined)\"][usedLabelName]===!1&&usage[\"(reassigned)\"])for(j=0;usage[\"(reassigned)\"].length>j;j++)warning(\"W020\",usage[\"(reassigned)\"][j])}else if(usage[\"(tokens)\"])for(j=0;usage[\"(tokens)\"].length>j;j++){var undefinedToken=usage[\"(tokens)\"][j];undefinedToken.forgiveUndef||(state.option.undef&&!undefinedToken.ignoreUndef&&warning(\"W117\",undefinedToken,usedLabelName),impliedGlobals[usedLabelName]?impliedGlobals[usedLabelName].line.push(undefinedToken.line):impliedGlobals[usedLabelName]={name:usedLabelName,line:[undefinedToken.line]})}}if(subScope||Object.keys(declared).forEach(function(labelNotUsed){_warnUnused(labelNotUsed,declared[labelNotUsed],\"var\")}),subScope&&!isUnstackingFunctionBody&&!isUnstackingFunctionParams&&!isUnstackingFunctionOuter){var labelNames=Object.keys(currentLabels);for(i=0;labelNames.length>i;i++){var defLabelName=labelNames[i];currentLabels[defLabelName][\"(blockscoped)\"]||\"exception\"===currentLabels[defLabelName][\"(type)\"]||this.funct.has(defLabelName,{excludeCurrent:!0})||(subScope[\"(labels)\"][defLabelName]=currentLabels[defLabelName],\"global\"!==_currentFunctBody[\"(type)\"]&&(subScope[\"(labels)\"][defLabelName][\"(useOutsideOfScope)\"]=!0),delete currentLabels[defLabelName])}}_checkForUnused(),_scopeStack.pop(),isUnstackingFunctionBody&&(_currentFunctBody=_scopeStack[_.findLastIndex(_scopeStack,function(scope){return scope[\"(isFuncBody)\"]||\"global\"===scope[\"(type)\"]})]),_current=subScope},addParam:function(labelName,token,type){if(type=type||\"param\",\"exception\"===type){var previouslyDefinedLabelType=this.funct.labeltype(labelName);previouslyDefinedLabelType&&\"exception\"!==previouslyDefinedLabelType&&(state.option.node||warning(\"W002\",state.tokens.next,labelName))}if(_.has(_current[\"(labels)\"],labelName)?_current[\"(labels)\"][labelName].duplicated=!0:(_checkOuterShadow(labelName,token,type),_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":token,\"(unused)\":!0},_current[\"(params)\"].push(labelName)),_.has(_current[\"(usages)\"],labelName)){var usage=_current[\"(usages)\"][labelName];usage[\"(onlyUsedSubFunction)\"]?_latedefWarning(type,labelName,token):warning(\"E056\",token,labelName,type)}},validateParams:function(){if(\"global\"!==_currentFunctBody[\"(type)\"]){var isStrict=state.isStrict(),currentFunctParamScope=_currentFunctBody[\"(parent)\"];currentFunctParamScope[\"(params)\"]&&currentFunctParamScope[\"(params)\"].forEach(function(labelName){var label=currentFunctParamScope[\"(labels)\"][labelName];label&&label.duplicated&&(isStrict?warning(\"E011\",label[\"(token)\"],labelName):state.option.shadow!==!0&&warning(\"W004\",label[\"(token)\"],labelName))})}},getUsedOrDefinedGlobals:function(){var list=Object.keys(usedPredefinedAndGlobals);return usedPredefinedAndGlobals.__proto__===marker&&-1===list.indexOf(\"__proto__\")&&list.push(\"__proto__\"),list},getImpliedGlobals:function(){var values=_.values(impliedGlobals),hasProto=!1;return impliedGlobals.__proto__&&(hasProto=values.some(function(value){return\"__proto__\"===value.name}),hasProto||values.push(impliedGlobals.__proto__)),values},getUnuseds:function(){return unuseds},has:function(labelName){return Boolean(_getLabel(labelName))},labeltype:function(labelName){var scopeLabels=_getLabel(labelName);return scopeLabels?scopeLabels[labelName][\"(type)\"]:null},addExported:function(labelName){var globalLabels=_scopeStack[0][\"(labels)\"];if(_.has(declared,labelName))delete declared[labelName];else if(_.has(globalLabels,labelName))globalLabels[labelName][\"(unused)\"]=!1;else{for(var i=1;_scopeStack.length>i;i++){var scope=_scopeStack[i];if(scope[\"(type)\"])break;if(_.has(scope[\"(labels)\"],labelName)&&!scope[\"(labels)\"][labelName][\"(blockscoped)\"])return scope[\"(labels)\"][labelName][\"(unused)\"]=!1,void 0}exported[labelName]=!0}},setExported:function(labelName,token){this.block.use(labelName,token)\n},addlabel:function(labelName,opts){var type=opts.type,token=opts.token,isblockscoped=\"let\"===type||\"const\"===type||\"class\"===type,isexported=\"global\"===(isblockscoped?_current:_currentFunctBody)[\"(type)\"]&&_.has(exported,labelName);if(_checkOuterShadow(labelName,token,type),isblockscoped){var declaredInCurrentScope=_current[\"(labels)\"][labelName];if(declaredInCurrentScope||_current!==_currentFunctBody||\"global\"===_current[\"(type)\"]||(declaredInCurrentScope=!!_currentFunctBody[\"(parent)\"][\"(labels)\"][labelName]),!declaredInCurrentScope&&_current[\"(usages)\"][labelName]){var usage=_current[\"(usages)\"][labelName];usage[\"(onlyUsedSubFunction)\"]?_latedefWarning(type,labelName,token):warning(\"E056\",token,labelName,type)}declaredInCurrentScope?warning(\"E011\",token,labelName):\"outer\"===state.option.shadow&&scopeManagerInst.funct.has(labelName)&&warning(\"W004\",token,labelName),scopeManagerInst.block.add(labelName,type,token,!isexported)}else{var declaredInCurrentFunctionScope=scopeManagerInst.funct.has(labelName);!declaredInCurrentFunctionScope&&usedSoFarInCurrentFunction(labelName)&&_latedefWarning(type,labelName,token),scopeManagerInst.funct.has(labelName,{onlyBlockscoped:!0})?warning(\"E011\",token,labelName):state.option.shadow!==!0&&declaredInCurrentFunctionScope&&\"__proto__\"!==labelName&&\"global\"!==_currentFunctBody[\"(type)\"]&&warning(\"W004\",token,labelName),scopeManagerInst.funct.add(labelName,type,token,!isexported),\"global\"===_currentFunctBody[\"(type)\"]&&(usedPredefinedAndGlobals[labelName]=marker)}},funct:{labeltype:function(labelName,options){for(var onlyBlockscoped=options&&options.onlyBlockscoped,excludeParams=options&&options.excludeParams,currentScopeIndex=_scopeStack.length-(options&&options.excludeCurrent?2:1),i=currentScopeIndex;i>=0;i--){var current=_scopeStack[i];if(current[\"(labels)\"][labelName]&&(!onlyBlockscoped||current[\"(labels)\"][labelName][\"(blockscoped)\"]))return current[\"(labels)\"][labelName][\"(type)\"];var scopeCheck=excludeParams?_scopeStack[i-1]:current;if(scopeCheck&&\"functionparams\"===scopeCheck[\"(type)\"])return null}return null},hasBreakLabel:function(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current[\"(breakLabels)\"][labelName])return!0;if(\"functionparams\"===current[\"(type)\"])return!1}return!1},has:function(labelName,options){return Boolean(this.labeltype(labelName,options))},add:function(labelName,type,tok,unused){_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":tok,\"(blockscoped)\":!1,\"(function)\":_currentFunctBody,\"(unused)\":unused}}},block:{isGlobal:function(){return\"global\"===_current[\"(type)\"]},use:function(labelName,token){var paramScope=_currentFunctBody[\"(parent)\"];paramScope&&paramScope[\"(labels)\"][labelName]&&\"param\"===paramScope[\"(labels)\"][labelName][\"(type)\"]&&(scopeManagerInst.funct.has(labelName,{excludeParams:!0,onlyBlockscoped:!0})||(paramScope[\"(labels)\"][labelName][\"(unused)\"]=!1)),token&&(state.ignored.W117||state.option.undef===!1)&&(token.ignoreUndef=!0),_setupUsages(labelName),token&&(token[\"(function)\"]=_currentFunctBody,_current[\"(usages)\"][labelName][\"(tokens)\"].push(token))},reassign:function(labelName,token){this.modify(labelName,token),_current[\"(usages)\"][labelName][\"(reassigned)\"].push(token)},modify:function(labelName,token){_setupUsages(labelName),_current[\"(usages)\"][labelName][\"(modified)\"].push(token)},add:function(labelName,type,tok,unused){_current[\"(labels)\"][labelName]={\"(type)\":type,\"(token)\":tok,\"(blockscoped)\":!0,\"(unused)\":unused}},addBreakLabel:function(labelName,opts){var token=opts.token;scopeManagerInst.funct.hasBreakLabel(labelName)?warning(\"E011\",token,labelName):\"outer\"===state.option.shadow&&(scopeManagerInst.funct.has(labelName)?warning(\"W004\",token,labelName):_checkOuterShadow(labelName,token)),_current[\"(breakLabels)\"][labelName]=token}}};return scopeManagerInst};module.exports=scopeManager},{\"../lodash\":\"/node_modules/jshint/lodash.js\",events:\"/node_modules/browserify/node_modules/events/events.js\"}],\"/node_modules/jshint/src/state.js\":[function(_dereq_,module,exports){\"use strict\";var NameStack=_dereq_(\"./name-stack.js\"),state={syntax:{},isStrict:function(){return this.directive[\"use strict\"]||this.inClassBody||this.option.module||\"implied\"===this.option.strict},inMoz:function(){return this.option.moz},inES6:function(){return this.option.moz||this.option.esversion>=6},inES5:function(strict){return strict?!(this.option.esversion&&5!==this.option.esversion||this.option.moz):!this.option.esversion||this.option.esversion>=5||this.option.moz},reset:function(){this.tokens={prev:null,next:null,curr:null},this.option={},this.funct=null,this.ignored={},this.directive={},this.jsonMode=!1,this.jsonWarnings=[],this.lines=[],this.tab=\"\",this.cache={},this.ignoredLines={},this.forinifcheckneeded=!1,this.nameStack=new NameStack,this.inClassBody=!1}};exports.state=state},{\"./name-stack.js\":\"/node_modules/jshint/src/name-stack.js\"}],\"/node_modules/jshint/src/style.js\":[function(_dereq_,module,exports){\"use strict\";exports.register=function(linter){linter.on(\"Identifier\",function(data){linter.getOption(\"proto\")||\"__proto__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name,\"6\"]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"iterator\")||\"__iterator__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"camelcase\")&&data.name.replace(/^_+|_+$/g,\"\").indexOf(\"_\")>-1&&!data.name.match(/^[A-Z0-9_]*$/)&&linter.warn(\"W106\",{line:data.line,\"char\":data.from,data:[data.name]})}),linter.on(\"String\",function(data){var code,quotmark=linter.getOption(\"quotmark\");quotmark&&(\"single\"===quotmark&&\"'\"!==data.quote&&(code=\"W109\"),\"double\"===quotmark&&'\"'!==data.quote&&(code=\"W108\"),quotmark===!0&&(linter.getCache(\"quotmark\")||linter.setCache(\"quotmark\",data.quote),linter.getCache(\"quotmark\")!==data.quote&&(code=\"W110\")),code&&linter.warn(code,{line:data.line,\"char\":data.char}))}),linter.on(\"Number\",function(data){\".\"===data.value.charAt(0)&&linter.warn(\"W008\",{line:data.line,\"char\":data.char,data:[data.value]}),\".\"===data.value.substr(data.value.length-1)&&linter.warn(\"W047\",{line:data.line,\"char\":data.char,data:[data.value]}),/^00+/.test(data.value)&&linter.warn(\"W046\",{line:data.line,\"char\":data.char,data:[data.value]})}),linter.on(\"String\",function(data){var re=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i;linter.getOption(\"scripturl\")||re.test(data.value)&&linter.warn(\"W107\",{line:data.line,\"char\":data.char})})}},{}],\"/node_modules/jshint/src/vars.js\":[function(_dereq_,module,exports){\"use strict\";exports.reservedVars={arguments:!1,NaN:!1},exports.ecmaIdentifiers={3:{Array:!1,Boolean:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,isFinite:!1,isNaN:!1,Math:!1,Number:!1,Object:!1,parseInt:!1,parseFloat:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,TypeError:!1,URIError:!1},5:{JSON:!1},6:{Map:!1,Promise:!1,Proxy:!1,Reflect:!1,Set:!1,Symbol:!1,WeakMap:!1,WeakSet:!1}},exports.browser={Audio:!1,Blob:!1,addEventListener:!1,applicationCache:!1,atob:!1,blur:!1,btoa:!1,cancelAnimationFrame:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,CSS:!1,clearInterval:!1,clearTimeout:!1,close:!1,closed:!1,Comment:!1,CustomEvent:!1,DOMParser:!1,defaultStatus:!1,Document:!1,document:!1,DocumentFragment:!1,Element:!1,ElementTimeControl:!1,Event:!1,event:!1,fetch:!1,FileReader:!1,FormData:!1,focus:!1,frames:!1,getComputedStyle:!1,HTMLElement:!1,HTMLAnchorElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLCollection:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPreElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTemplateElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLUListElement:!1,HTMLVideoElement:!1,history:!1,Image:!1,Intl:!1,length:!1,localStorage:!1,location:!1,matchMedia:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationObserver:!1,name:!1,Node:!1,NodeFilter:!1,NodeList:!1,Notification:!1,navigator:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,Option:!1,parent:!1,performance:!1,print:!1,Range:!1,requestAnimationFrame:!1,removeEventListener:!1,resizeBy:!1,resizeTo:!1,screen:!1,scroll:!1,scrollBy:!1,scrollTo:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,SharedWorker:!1,status:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimationElement:!1,SVGCSSRule:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLineElement:!1,SVGLinearGradientElement:!1,SVGLocatable:!1,SVGMPathElement:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGSVGElement:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformList:!1,SVGTransformable:!1,SVGURIReference:!1,SVGUnitTypes:!1,SVGUseElement:!1,SVGVKernElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGZoomAndPan:!1,Text:!1,TextDecoder:!1,TextEncoder:!1,TimeEvent:!1,top:!1,URL:!1,WebGLActiveInfo:!1,WebGLBuffer:!1,WebGLContextEvent:!1,WebGLFramebuffer:!1,WebGLProgram:!1,WebGLRenderbuffer:!1,WebGLRenderingContext:!1,WebGLShader:!1,WebGLShaderPrecisionFormat:!1,WebGLTexture:!1,WebGLUniformLocation:!1,WebSocket:!1,window:!1,Window:!1,Worker:!1,XDomainRequest:!1,XMLHttpRequest:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1},exports.devel={alert:!1,confirm:!1,console:!1,Debug:!1,opera:!1,prompt:!1},exports.worker={importScripts:!0,postMessage:!0,self:!0,FileReaderSync:!0},exports.nonstandard={escape:!1,unescape:!1},exports.couch={require:!1,respond:!1,getRow:!1,emit:!1,send:!1,start:!1,sum:!1,log:!1,exports:!1,module:!1,provides:!1},exports.node={__filename:!1,__dirname:!1,GLOBAL:!1,global:!1,module:!1,acequire:!1,Buffer:!0,console:!0,exports:!0,process:!0,setTimeout:!0,clearTimeout:!0,setInterval:!0,clearInterval:!0,setImmediate:!0,clearImmediate:!0},exports.browserify={__filename:!1,__dirname:!1,global:!1,module:!1,acequire:!1,Buffer:!0,exports:!0,process:!0},exports.phantom={phantom:!0,acequire:!0,WebPage:!0,console:!0,exports:!0},exports.qunit={asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,\"throws\":!1},exports.rhino={defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},exports.shelljs={target:!1,echo:!1,exit:!1,cd:!1,pwd:!1,ls:!1,find:!1,cp:!1,rm:!1,mv:!1,mkdir:!1,test:!1,cat:!1,sed:!1,grep:!1,which:!1,dirs:!1,pushd:!1,popd:!1,env:!1,exec:!1,chmod:!1,config:!1,error:!1,tempdir:!1},exports.typed={ArrayBuffer:!1,ArrayBufferView:!1,DataView:!1,Float32Array:!1,Float64Array:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1},exports.wsh={ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WSH:!0,WScript:!0,XDomainRequest:!0},exports.dojo={dojo:!1,dijit:!1,dojox:!1,define:!1,require:!1},exports.jquery={$:!1,jQuery:!1},exports.mootools={$:!1,$$:!1,Asset:!1,Browser:!1,Chain:!1,Class:!1,Color:!1,Cookie:!1,Core:!1,Document:!1,DomReady:!1,DOMEvent:!1,DOMReady:!1,Drag:!1,Element:!1,Elements:!1,Event:!1,Events:!1,Fx:!1,Group:!1,Hash:!1,HtmlTable:!1,IFrame:!1,IframeShim:!1,InputValidator:!1,instanceOf:!1,Keyboard:!1,Locale:!1,Mask:!1,MooTools:!1,Native:!1,Options:!1,OverText:!1,Request:!1,Scroller:!1,Slick:!1,Slider:!1,Sortables:!1,Spinner:!1,Swiff:!1,Tips:!1,Type:!1,typeOf:!1,URI:!1,Window:!1},exports.prototypejs={$:!1,$$:!1,$A:!1,$F:!1,$H:!1,$R:!1,$break:!1,$continue:!1,$w:!1,Abstract:!1,Ajax:!1,Class:!1,Enumerable:!1,Element:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Selector:!1,Template:!1,Toggle:!1,Try:!1,Autocompleter:!1,Builder:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Scriptaculous:!1},exports.yui={YUI:!1,Y:!1,YUI_config:!1},exports.mocha={mocha:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,context:!1,xcontext:!1,before:!1,after:!1,beforeEach:!1,afterEach:!1,suite:!1,test:!1,setup:!1,teardown:!1,suiteSetup:!1,suiteTeardown:!1},exports.jasmine={jasmine:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,beforeEach:!1,afterEach:!1,setFixtures:!1,loadFixtures:!1,spyOn:!1,expect:!1,runs:!1,waitsFor:!1,waits:!1,beforeAll:!1,afterAll:!1,fail:!1,fdescribe:!1,fit:!1,pending:!1}},{}]},{},[\"/node_modules/jshint/src/jshint.js\"])}),ace.define(\"ace/mode/javascript_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/javascript/jshint\"],function(acequire,exports,module){\"use strict\";function startRegex(arr){return RegExp(\"^(\"+arr.join(\"|\")+\")\")}var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,lint=acequire(\"./javascript/jshint\").JSHINT,disabledWarningsRe=startRegex([\"Bad for in variable '(.+)'.\",'Missing \"use strict\"']),errorsRe=startRegex([\"Unexpected\",\"Expected \",\"Confusing (plus|minus)\",\"\\\\{a\\\\} unterminated regular expression\",\"Unclosed \",\"Unmatched \",\"Unbegun comment\",\"Bad invocation\",\"Missing space after\",\"Missing operator at\"]),infoRe=startRegex([\"Expected an assignment\",\"Bad escapement of EOL\",\"Unexpected comma\",\"Unexpected space\",\"Missing radix parameter.\",\"A leading decimal point can\",\"\\\\['{a}'\\\\] is better written in dot notation.\",\"'{a}' used out of scope\"]),JavaScriptWorker=exports.JavaScriptWorker=function(sender){Mirror.call(this,sender),this.setTimeout(500),this.setOptions()};oop.inherits(JavaScriptWorker,Mirror),function(){this.setOptions=function(options){this.options=options||{esnext:!0,moz:!0,devel:!0,browser:!0,node:!0,laxcomma:!0,laxbreak:!0,lastsemic:!0,onevar:!1,passfail:!1,maxerr:100,expr:!0,multistr:!0,globalstrict:!0},this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(newOptions){oop.mixin(this.options,newOptions),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.isValidJS=function(str){try{eval(\"throw 0;\"+str)}catch(e){if(0===e)return!0}return!1},this.onUpdate=function(){var value=this.doc.getValue();if(value=value.replace(/^#!.*\\n/,\"\\n\"),!value)return this.sender.emit(\"annotate\",[]);var errors=[],maxErrorLevel=this.isValidJS(value)?\"warning\":\"error\";lint(value,this.options);for(var results=lint.errors,errorAdded=!1,i=0;results.length>i;i++){var error=results[i];if(error){var raw=error.raw,type=\"warning\";if(\"Missing semicolon.\"==raw){var str=error.evidence.substr(error.character);str=str.charAt(str.search(/\\S/)),\"error\"==maxErrorLevel&&str&&/[\\w\\d{(['\"]/.test(str)?(error.reason='Missing \";\" before statement',type=\"error\"):type=\"info\"}else{if(disabledWarningsRe.test(raw))continue;infoRe.test(raw)?type=\"info\":errorsRe.test(raw)?(errorAdded=!0,type=maxErrorLevel):\"'{a}' is not defined.\"==raw?type=\"warning\":\"'{a}' is defined but never used.\"==raw&&(type=\"info\")}errors.push({row:error.line-1,column:error.character-1,text:error.reason,type:type,raw:raw})}}this.sender.emit(\"annotate\",errors)}}.call(JavaScriptWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r Â áš€á Žâ€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\\u2028\\u2029ï»¿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

	var JsonHighlightRules = function() {
	    this.$rules = {
	        "start" : [
	            {
	                token : "variable", // single line
	                regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
	            }, {
	                token : "string", // single line
	                regex : '"',
	                next  : "string"
	            }, {
	                token : "constant.numeric", // hex
	                regex : "0[xX][0-9a-fA-F]+\\b"
	            }, {
	                token : "constant.numeric", // float
	                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
	            }, {
	                token : "constant.language.boolean",
	                regex : "(?:true|false)\\b"
	            }, {
	                token : "invalid.illegal", // single quoted strings are not allowed
	                regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
	            }, {
	                token : "invalid.illegal", // comments are not allowed
	                regex : "\\/\\/.*$"
	            }, {
	                token : "paren.lparen",
	                regex : "[[({]"
	            }, {
	                token : "paren.rparen",
	                regex : "[\\])}]"
	            }, {
	                token : "text",
	                regex : "\\s+"
	            }
	        ],
	        "string" : [
	            {
	                token : "constant.language.escape",
	                regex : /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
	            }, {
	                token : "string",
	                regex : '[^"\\\\]+'
	            }, {
	                token : "string",
	                regex : '"',
	                next  : "start"
	            }, {
	                token : "string",
	                regex : "",
	                next  : "start"
	            }
	        ]
	    };
	    
	};

	oop.inherits(JsonHighlightRules, TextHighlightRules);

	exports.JsonHighlightRules = JsonHighlightRules;
	});

	ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;

	var MatchingBraceOutdent = function() {};

	(function() {

	    this.checkOutdent = function(line, input) {
	        if (! /^\s+$/.test(line))
	            return false;

	        return /^\s*\}/.test(input);
	    };

	    this.autoOutdent = function(doc, row) {
	        var line = doc.getLine(row);
	        var match = line.match(/^(\s*\})/);

	        if (!match) return 0;

	        var column = match[1].length;
	        var openBracePos = doc.findMatchingBracket({row: row, column: column});

	        if (!openBracePos || openBracePos.row == row) return 0;

	        var indent = this.$getIndent(doc.getLine(openBracePos.row));
	        doc.replace(new Range(row, 0, row, column-1), indent);
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	}).call(MatchingBraceOutdent.prototype);

	exports.MatchingBraceOutdent = MatchingBraceOutdent;
	});

	ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;
	var lang = acequire("../../lib/lang");

	var SAFE_INSERT_IN_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator"];
	var SAFE_INSERT_BEFORE_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator", "comment"];

	var context;
	var contextCache = {};
	var initContext = function(editor) {
	    var id = -1;
	    if (editor.multiSelect) {
	        id = editor.selection.index;
	        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
	            contextCache = {rangeCount: editor.multiSelect.rangeCount};
	    }
	    if (contextCache[id])
	        return context = contextCache[id];
	    context = contextCache[id] = {
	        autoInsertedBrackets: 0,
	        autoInsertedRow: -1,
	        autoInsertedLineEnd: "",
	        maybeInsertedBrackets: 0,
	        maybeInsertedRow: -1,
	        maybeInsertedLineStart: "",
	        maybeInsertedLineEnd: ""
	    };
	};

	var getWrapped = function(selection, selected, opening, closing) {
	    var rowDiff = selection.end.row - selection.start.row;
	    return {
	        text: opening + selected + closing,
	        selection: [
	                0,
	                selection.start.column + 1,
	                rowDiff,
	                selection.end.column + (rowDiff ? 0 : 1)
	            ]
	    };
	};

	var CstyleBehaviour = function() {
	    this.add("braces", "insertion", function(state, action, editor, session, text) {
	        var cursor = editor.getCursorPosition();
	        var line = session.doc.getLine(cursor.row);
	        if (text == '{') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '{', '}');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
	                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                    return {
	                        text: '{}',
	                        selection: [1, 1]
	                    };
	                } else {
	                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
	                    return {
	                        text: '{',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == '}') {
	            initContext(editor);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == '}') {
	                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == "\n" || text == "\r\n") {
	            initContext(editor);
	            var closing = "";
	            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
	                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
	                CstyleBehaviour.clearMaybeInsertedClosing();
	            }
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === '}') {
	                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
	                if (!openBracePos)
	                     return null;
	                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
	            } else if (closing) {
	                var next_indent = this.$getIndent(line);
	            } else {
	                CstyleBehaviour.clearMaybeInsertedClosing();
	                return;
	            }
	            var indent = next_indent + session.getTabString();

	            return {
	                text: '\n' + indent + '\n' + next_indent + closing,
	                selection: [1, indent.length, 1, indent.length]
	            };
	        } else {
	            CstyleBehaviour.clearMaybeInsertedClosing();
	        }
	    });

	    this.add("braces", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '{') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.end.column, range.end.column + 1);
	            if (rightChar == '}') {
	                range.end.column++;
	                return range;
	            } else {
	                context.maybeInsertedBrackets--;
	            }
	        }
	    });

	    this.add("parens", "insertion", function(state, action, editor, session, text) {
	        if (text == '(') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '(', ')');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, ")");
	                return {
	                    text: '()',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ')') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ')') {
	                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("parens", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '(') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ')') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("brackets", "insertion", function(state, action, editor, session, text) {
	        if (text == '[') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '[', ']');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, "]");
	                return {
	                    text: '[]',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ']') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ']') {
	                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("brackets", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '[') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ']') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
	        if (text == '"' || text == "'") {
	            initContext(editor);
	            var quote = text;
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, quote, quote);
	            } else if (!selected) {
	                var cursor = editor.getCursorPosition();
	                var line = session.doc.getLine(cursor.row);
	                var leftChar = line.substring(cursor.column-1, cursor.column);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);
	                
	                var token = session.getTokenAt(cursor.row, cursor.column);
	                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
	                if (leftChar == "\\" && token && /escape/.test(token.type))
	                    return null;
	                
	                var stringBefore = token && /string|escape/.test(token.type);
	                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
	                
	                var pair;
	                if (rightChar == quote) {
	                    pair = stringBefore !== stringAfter;
	                } else {
	                    if (stringBefore && !stringAfter)
	                        return null; // wrap string with different quote
	                    if (stringBefore && stringAfter)
	                        return null; // do not pair quotes inside strings
	                    var wordRe = session.$mode.tokenRe;
	                    wordRe.lastIndex = 0;
	                    var isWordBefore = wordRe.test(leftChar);
	                    wordRe.lastIndex = 0;
	                    var isWordAfter = wordRe.test(leftChar);
	                    if (isWordBefore || isWordAfter)
	                        return null; // before or after alphanumeric
	                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
	                        return null; // there is rightChar and it isn't closing
	                    pair = true;
	                }
	                return {
	                    text: pair ? quote + quote : "",
	                    selection: [1,1]
	                };
	            }
	        }
	    });

	    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	};

	    
	CstyleBehaviour.isSaneInsertion = function(editor, session) {
	    var cursor = editor.getCursorPosition();
	    var iterator = new TokenIterator(session, cursor.row, cursor.column);
	    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
	        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
	        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
	            return false;
	    }
	    iterator.stepForward();
	    return iterator.getCurrentTokenRow() !== cursor.row ||
	        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
	};

	CstyleBehaviour.$matchTokenType = function(token, types) {
	    return types.indexOf(token.type || token) > -1;
	};

	CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
	        context.autoInsertedBrackets = 0;
	    context.autoInsertedRow = cursor.row;
	    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
	    context.autoInsertedBrackets++;
	};

	CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isMaybeInsertedClosing(cursor, line))
	        context.maybeInsertedBrackets = 0;
	    context.maybeInsertedRow = cursor.row;
	    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
	    context.maybeInsertedLineEnd = line.substr(cursor.column);
	    context.maybeInsertedBrackets++;
	};

	CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
	    return context.autoInsertedBrackets > 0 &&
	        cursor.row === context.autoInsertedRow &&
	        bracket === context.autoInsertedLineEnd[0] &&
	        line.substr(cursor.column) === context.autoInsertedLineEnd;
	};

	CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
	    return context.maybeInsertedBrackets > 0 &&
	        cursor.row === context.maybeInsertedRow &&
	        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
	        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
	};

	CstyleBehaviour.popAutoInsertedClosing = function() {
	    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
	    context.autoInsertedBrackets--;
	};

	CstyleBehaviour.clearMaybeInsertedClosing = function() {
	    if (context) {
	        context.maybeInsertedBrackets = 0;
	        context.maybeInsertedRow = -1;
	    }
	};



	oop.inherits(CstyleBehaviour, Behaviour);

	exports.CstyleBehaviour = CstyleBehaviour;
	});

	ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Range = acequire("../../range").Range;
	var BaseFoldMode = acequire("./fold_mode").FoldMode;

	var FoldMode = exports.FoldMode = function(commentRegex) {
	    if (commentRegex) {
	        this.foldingStartMarker = new RegExp(
	            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
	        );
	        this.foldingStopMarker = new RegExp(
	            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
	        );
	    }
	};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {
	    
	    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
	    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
	    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
	    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
	    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
	    this._getFoldWidgetBase = this.getFoldWidget;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	    
	        if (this.singleLineBlockCommentRe.test(line)) {
	            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
	                return "";
	        }
	    
	        var fw = this._getFoldWidgetBase(session, foldStyle, row);
	    
	        if (!fw && this.startRegionRe.test(line))
	            return "start"; // lineCommentRegionStart
	    
	        return fw;
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
	        var line = session.getLine(row);
	        
	        if (this.startRegionRe.test(line))
	            return this.getCommentRegionBlock(session, line, row);
	        
	        var match = line.match(this.foldingStartMarker);
	        if (match) {
	            var i = match.index;

	            if (match[1])
	                return this.openingBracketBlock(session, match[1], row, i);
	                
	            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
	            
	            if (range && !range.isMultiLine()) {
	                if (forceMultiline) {
	                    range = this.getSectionRange(session, row);
	                } else if (foldStyle != "all")
	                    range = null;
	            }
	            
	            return range;
	        }

	        if (foldStyle === "markbegin")
	            return;

	        var match = line.match(this.foldingStopMarker);
	        if (match) {
	            var i = match.index + match[0].length;

	            if (match[1])
	                return this.closingBracketBlock(session, match[1], row, i);

	            return session.getCommentFoldRange(row, i, -1);
	        }
	    };
	    
	    this.getSectionRange = function(session, row) {
	        var line = session.getLine(row);
	        var startIndent = line.search(/\S/);
	        var startRow = row;
	        var startColumn = line.length;
	        row = row + 1;
	        var endRow = row;
	        var maxRow = session.getLength();
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var indent = line.search(/\S/);
	            if (indent === -1)
	                continue;
	            if  (startIndent > indent)
	                break;
	            var subRange = this.getFoldWidgetRange(session, "all", row);
	            
	            if (subRange) {
	                if (subRange.start.row <= startRow) {
	                    break;
	                } else if (subRange.isMultiLine()) {
	                    row = subRange.end.row;
	                } else if (startIndent == indent) {
	                    break;
	                }
	            }
	            endRow = row;
	        }
	        
	        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
	    };
	    this.getCommentRegionBlock = function(session, line, row) {
	        var startColumn = line.search(/\s*$/);
	        var maxRow = session.getLength();
	        var startRow = row;
	        
	        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
	        var depth = 1;
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var m = re.exec(line);
	            if (!m) continue;
	            if (m[1]) depth--;
	            else depth++;

	            if (!depth) break;
	        }

	        var endRow = row;
	        if (endRow > startRow) {
	            return new Range(startRow, startColumn, endRow, line.length);
	        }
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/json",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle","ace/worker/worker_client"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var HighlightRules = acequire("./json_highlight_rules").JsonHighlightRules;
	var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
	var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
	var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;

	var Mode = function() {
	    this.HighlightRules = HighlightRules;
	    this.$outdent = new MatchingBraceOutdent();
	    this.$behaviour = new CstyleBehaviour();
	    this.foldingRules = new CStyleFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.getNextLineIndent = function(state, line, tab) {
	        var indent = this.$getIndent(line);

	        if (state == "start") {
	            var match = line.match(/^.*[\{\(\[]\s*$/);
	            if (match) {
	                indent += tab;
	            }
	        }

	        return indent;
	    };

	    this.checkOutdent = function(state, line, input) {
	        return this.$outdent.checkOutdent(line, input);
	    };

	    this.autoOutdent = function(state, doc, row) {
	        this.$outdent.autoOutdent(doc, row);
	    };

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(40), "JsonWorker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("annotate", function(e) {
	            session.setAnnotations(e.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };


	    this.$id = "ace/mode/json";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	module.exports.id = 'ace/mode/json_worker';
	module.exports.src = "\"no use strict\";(function(window){function resolveModuleId(id,paths){for(var testPath=id,tail=\"\";testPath;){var alias=paths[testPath];if(\"string\"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,\"/\")+(tail||alias.main||alias.name);if(alias===!1)return\"\";var i=testPath.lastIndexOf(\"/\");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log(\"unable to load \"+id);var path=resolveModuleId(id,window.acequire.tlns);return\".js\"!=path.slice(-3)&&(path+=\".js\"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error(\"Unknown command:\"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||\"\";switch(delta.action){case\"insert\":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case\"remove\":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert=\"insert\"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),applyDelta=acequire(\"./apply_delta\").applyDelta,EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(textOrLines){this.$lines=[\"\"],0===textOrLines.length?this.$lines=[\"\"]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(position,[\"\",\"\"])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:\"insert\",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([\"\"]),column=0):(lines=[\"\"].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:\"insert\",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:\"remove\",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:\"remove\",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert=\"insert\"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal(\"change\",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(\"\"),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:\"insert\"==delta.action?\"remove\":\"insert\",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if(\"object\"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}var cons=obj.constructor;if(cons===RegExp)return obj;copy=cons();for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";acequire(\"../range\").Range;var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:\"insert\",start:data[i],lines:data[i+1]};else var d={action:\"remove\",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/json/json_parse\",[\"require\",\"exports\",\"module\"],function(){\"use strict\";var at,ch,text,value,escapee={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\t\"},error=function(m){throw{name:\"SyntaxError\",message:m,at:at,text:text}},next=function(c){return c&&c!==ch&&error(\"Expected '\"+c+\"' instead of '\"+ch+\"'\"),ch=text.charAt(at),at+=1,ch},number=function(){var number,string=\"\";for(\"-\"===ch&&(string=\"-\",next(\"-\"));ch>=\"0\"&&\"9\">=ch;)string+=ch,next();if(\".\"===ch)for(string+=\".\";next()&&ch>=\"0\"&&\"9\">=ch;)string+=ch;if(\"e\"===ch||\"E\"===ch)for(string+=ch,next(),(\"-\"===ch||\"+\"===ch)&&(string+=ch,next());ch>=\"0\"&&\"9\">=ch;)string+=ch,next();return number=+string,isNaN(number)?(error(\"Bad number\"),void 0):number},string=function(){var hex,i,uffff,string=\"\";if('\"'===ch)for(;next();){if('\"'===ch)return next(),string;if(\"\\\\\"===ch)if(next(),\"u\"===ch){for(uffff=0,i=0;4>i&&(hex=parseInt(next(),16),isFinite(hex));i+=1)uffff=16*uffff+hex;string+=String.fromCharCode(uffff)}else{if(\"string\"!=typeof escapee[ch])break;string+=escapee[ch]}else string+=ch}error(\"Bad string\")},white=function(){for(;ch&&\" \">=ch;)next()},word=function(){switch(ch){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+ch+\"'\")},array=function(){var array=[];if(\"[\"===ch){if(next(\"[\"),white(),\"]\"===ch)return next(\"]\"),array;for(;ch;){if(array.push(value()),white(),\"]\"===ch)return next(\"]\"),array;next(\",\"),white()}}error(\"Bad array\")},object=function(){var key,object={};if(\"{\"===ch){if(next(\"{\"),white(),\"}\"===ch)return next(\"}\"),object;for(;ch;){if(key=string(),white(),next(\":\"),Object.hasOwnProperty.call(object,key)&&error('Duplicate key \"'+key+'\"'),object[key]=value(),white(),\"}\"===ch)return next(\"}\"),object;next(\",\"),white()}}error(\"Bad object\")};return value=function(){switch(white(),ch){case\"{\":return object();case\"[\":return array();case'\"':return string();case\"-\":return number();default:return ch>=\"0\"&&\"9\">=ch?number():word()}},function(source,reviver){var result;return text=source,at=0,ch=\" \",result=value(),white(),ch&&error(\"Syntax error\"),\"function\"==typeof reviver?function walk(holder,key){var k,v,value=holder[key];if(value&&\"object\"==typeof value)for(k in value)Object.hasOwnProperty.call(value,k)&&(v=walk(value,k),void 0!==v?value[k]=v:delete value[k]);return reviver.call(holder,key,value)}({\"\":result},\"\"):result}}),ace.define(\"ace/mode/json_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/json/json_parse\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,parse=acequire(\"./json/json_parse\"),JsonWorker=exports.JsonWorker=function(sender){Mirror.call(this,sender),this.setTimeout(200)};oop.inherits(JsonWorker,Mirror),function(){this.onUpdate=function(){var value=this.doc.getValue(),errors=[];try{value&&parse(value)}catch(e){var pos=this.doc.indexToPosition(e.at-1);errors.push({row:pos.row,column:pos.column,text:e.message,type:\"error\"})}this.sender.emit(\"annotate\",errors)}}.call(JsonWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0\n}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r Â áš€á Žâ€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\\u2028\\u2029ï»¿\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	ace.define("ace/theme/twilight",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {

	exports.isDark = true;
	exports.cssClass = "ace-twilight";
	exports.cssText = ".ace-twilight .ace_gutter {\
	background: #232323;\
	color: #E2E2E2\
	}\
	.ace-twilight .ace_print-margin {\
	width: 1px;\
	background: #232323\
	}\
	.ace-twilight {\
	background-color: #141414;\
	color: #F8F8F8\
	}\
	.ace-twilight .ace_cursor {\
	color: #A7A7A7\
	}\
	.ace-twilight .ace_marker-layer .ace_selection {\
	background: rgba(221, 240, 255, 0.20)\
	}\
	.ace-twilight.ace_multiselect .ace_selection.ace_start {\
	box-shadow: 0 0 3px 0px #141414;\
	}\
	.ace-twilight .ace_marker-layer .ace_step {\
	background: rgb(102, 82, 0)\
	}\
	.ace-twilight .ace_marker-layer .ace_bracket {\
	margin: -1px 0 0 -1px;\
	border: 1px solid rgba(255, 255, 255, 0.25)\
	}\
	.ace-twilight .ace_marker-layer .ace_active-line {\
	background: rgba(255, 255, 255, 0.031)\
	}\
	.ace-twilight .ace_gutter-active-line {\
	background-color: rgba(255, 255, 255, 0.031)\
	}\
	.ace-twilight .ace_marker-layer .ace_selected-word {\
	border: 1px solid rgba(221, 240, 255, 0.20)\
	}\
	.ace-twilight .ace_invisible {\
	color: rgba(255, 255, 255, 0.25)\
	}\
	.ace-twilight .ace_keyword,\
	.ace-twilight .ace_meta {\
	color: #CDA869\
	}\
	.ace-twilight .ace_constant,\
	.ace-twilight .ace_constant.ace_character,\
	.ace-twilight .ace_constant.ace_character.ace_escape,\
	.ace-twilight .ace_constant.ace_other,\
	.ace-twilight .ace_heading,\
	.ace-twilight .ace_markup.ace_heading,\
	.ace-twilight .ace_support.ace_constant {\
	color: #CF6A4C\
	}\
	.ace-twilight .ace_invalid.ace_illegal {\
	color: #F8F8F8;\
	background-color: rgba(86, 45, 86, 0.75)\
	}\
	.ace-twilight .ace_invalid.ace_deprecated {\
	text-decoration: underline;\
	font-style: italic;\
	color: #D2A8A1\
	}\
	.ace-twilight .ace_support {\
	color: #9B859D\
	}\
	.ace-twilight .ace_fold {\
	background-color: #AC885B;\
	border-color: #F8F8F8\
	}\
	.ace-twilight .ace_support.ace_function {\
	color: #DAD085\
	}\
	.ace-twilight .ace_list,\
	.ace-twilight .ace_markup.ace_list,\
	.ace-twilight .ace_storage {\
	color: #F9EE98\
	}\
	.ace-twilight .ace_entity.ace_name.ace_function,\
	.ace-twilight .ace_meta.ace_tag,\
	.ace-twilight .ace_variable {\
	color: #AC885B\
	}\
	.ace-twilight .ace_string {\
	color: #8F9D6A\
	}\
	.ace-twilight .ace_string.ace_regexp {\
	color: #E9C062\
	}\
	.ace-twilight .ace_comment {\
	font-style: italic;\
	color: #5F5A60\
	}\
	.ace-twilight .ace_variable {\
	color: #7587A6\
	}\
	.ace-twilight .ace_xml-pe {\
	color: #494949\
	}\
	.ace-twilight .ace_indent-guide {\
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y\
	}";

	var dom = acequire("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass);
	});


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(43);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(19);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Stage = function (_React$Component) {
	  _inherits(Stage, _React$Component);

	  function Stage(props) {
	    _classCallCheck(this, Stage);

	    var _this = _possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this, props));

	    _initialiseProps.call(_this);

	    _this.state = {
	      constrast: false,
	      componentError: null,
	      reloadNeeded: false
	    };
	    _this._defineElement(props);
	    return _this;
	  }

	  _createClass(Stage, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      this._defineElement(nextProps);
	    }
	  }, {
	    key: '_renderComponent',
	    value: function _renderComponent() {
	      var _props = this.props,
	          component = _props.component,
	          properties = _props.properties;

	      var targetRender = document.getElementById('__stage_render__');
	      try {
	        _reactDom2.default.unstable_renderSubtreeIntoContainer(this, _react2.default.createElement(
	          'div',
	          { className: 'stage' },
	          this._renderStageBoard(),
	          this._renderStageTools()
	        ), targetRender);
	      } catch (error) {
	        targetRender.innerHTML = '';
	        _reactDom2.default.unstable_renderSubtreeIntoContainer(this, _react2.default.createElement(
	          'div',
	          { className: 'stage' },
	          this._renderErrorAlert(error)
	        ), targetRender);
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: '__stage_render__', className: 'stage' });
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this._renderComponent();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._renderComponent();
	    }
	  }, {
	    key: '_renderStageBoard',
	    value: function _renderStageBoard() {
	      var className = (0, _classnames2.default)('stage-board', { 'stage-board-dark': this.state.constrast });
	      return _react2.default.createElement(
	        'div',
	        { className: className },
	        this._instance
	      );
	    }
	  }, {
	    key: '_renderErrorAlert',
	    value: function _renderErrorAlert(error) {
	      this._setInvalidComponent(this.props.component);
	      return _react2.default.createElement(
	        'div',
	        { className: 'stage-render-error' },
	        _react2.default.createElement(
	          'button',
	          { onClick: this.onReloadAtellier, className: 'reload' },
	          'Reload'
	        ),
	        _react2.default.createElement(
	          'span',
	          { className: 'stage-error-text' },
	          'React component ',
	          _react2.default.createElement(
	            'b',
	            null,
	            this.state.componentError,
	            ' '
	          ),
	          ' crashed!'
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'stage-error-message' },
	          error.message
	        )
	      );
	    }
	  }, {
	    key: '_setInvalidComponent',
	    value: function _setInvalidComponent(component) {
	      var componentName = component.componentName,
	          indexKey = component.indexKey;

	      var invalidComponents = JSON.parse(localStorage.getItem('invalidComponents')) || [];

	      var exists = invalidComponents.filter(function (item) {
	        return item.componentName === componentName && item.indexKey === indexKey;
	      });

	      if (!exists.length && !this.state.reloadNeeded) {
	        this.setState({
	          reloadNeeded: true
	        });
	        invalidComponents.push({
	          indexKey: indexKey,
	          componentName: componentName
	        });
	      } else if (exists.length && !this.state.reloadNeeded) {
	        this.setState({
	          reloadNeeded: true
	        });
	      }

	      localStorage.setItem('invalidComponents', JSON.stringify(invalidComponents));
	    }
	  }, {
	    key: '_renderStageTools',
	    value: function _renderStageTools() {
	      return _react2.default.createElement(
	        'div',
	        { className: 'stage-tools' },
	        _react2.default.createElement(
	          'label',
	          null,
	          'Stage color'
	        ),
	        _react2.default.createElement(
	          'select',
	          { className: 'atellier-input', onChange: this._handleChangeConstrast },
	          _react2.default.createElement(
	            'option',
	            { value: 'false' },
	            'Light'
	          ),
	          _react2.default.createElement(
	            'option',
	            { value: 'true' },
	            'Dark'
	          )
	        )
	      );
	    }
	  }]);

	  return Stage;
	}(_react2.default.Component);

	Stage.defaultProps = {
	  component: {},
	  properties: {}
	};
	Stage.propTypes = {
	  component: _react.PropTypes.shape({
	    component: _react.PropTypes.func,
	    componentName: _react.PropTypes.string,
	    defaultAtellierProps: _react.PropTypes.object,
	    extraPropTypes: _react.PropTypes.object
	  }),
	  properties: _react.PropTypes.object
	};

	var _initialiseProps = function _initialiseProps() {
	  var _this2 = this;

	  this.onReloadAtellier = function () {
	    window.location.reload();
	  };

	  this._handleChangeConstrast = function (event) {
	    _this2.setState({
	      constrast: event.target.value === 'true'
	    });
	  };

	  this._defineElement = function (props) {
	    var component = props.component,
	        properties = props.properties;

	    if (component && component.component) {
	      _this2._instance = _react2.default.cloneElement(_react2.default.createElement(component.component, properties));
	    }
	  };
	};

	exports.default = Stage;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_43__;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	exports.default = DefaultPropsMerger;

	var _react = __webpack_require__(16);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function removeRequired(propType) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	        for (var _iterator = Object.entries(_react2.default.PropTypes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _step$value = _slicedToArray(_step.value, 2),
	                key = _step$value[0],
	                value = _step$value[1];

	            if (propType === value.isRequired) {
	                return value;
	            }
	        }
	        //ISSUE: If it has a function proptype(), it will just return without changes
	        //Some compoenents do need values to be defined for them to work
	        //This should actaully deep run and assign instead
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }

	    return propType;
	}

	function DefaultPropsMerger(componentList) {
	    componentList.map(function (componentOuter, componentOuterIndex) {

	        if (_typeof(componentOuter.extraPropTypes) === "object") {
	            //Add to PropTypes props - mainly for higher-order components
	            componentOuter.component.propTypes = _extends({}, componentOuter.component.propTypes, componentOuter.extraPropTypes);
	        }

	        //Give required props a default value
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	            for (var _iterator2 = Object.entries(componentOuter.component.propTypes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var _step2$value = _slicedToArray(_step2.value, 2),
	                    key = _step2$value[0],
	                    value = _step2$value[1];

	                componentOuter.component.propTypes[key] = removeRequired(value);
	            }
	        } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                }
	            } finally {
	                if (_didIteratorError2) {
	                    throw _iteratorError2;
	                }
	            }
	        }

	        if (_typeof(componentOuter.defaultAtellierProps) === "object") {
	            //Add in default atellier props
	            componentOuter.component.defaultProps = _extends({}, componentOuter.component.defaultProps, componentOuter.defaultAtellierProps);
	        }
	    });
	    return componentList;
	};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(46);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(53)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/index.js?outputStyle=expanded&includePaths[]=/Users/scottangelinetta/Documents/Development/Koorong/React-Search-Suggest/node_modules/react-atellier/bower_components&includePaths[]=/Users/scottangelinetta/Documents/Development/Koorong/React-Search-Suggest/node_modules/react-atellier/node_modules!../../node_modules/autoprefixer-loader/index.js!./atellier.less", function() {
				var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/index.js?outputStyle=expanded&includePaths[]=/Users/scottangelinetta/Documents/Development/Koorong/React-Search-Suggest/node_modules/react-atellier/bower_components&includePaths[]=/Users/scottangelinetta/Documents/Development/Koorong/React-Search-Suggest/node_modules/react-atellier/node_modules!../../node_modules/autoprefixer-loader/index.js!./atellier.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(47)();
	// imports


	// module
	exports.push([module.id, "/* ------------------------- *\\\n      ATTELLIER\n\\* ------------------------- */\n/* ------------------------- *\\\n      SETTINGS\n\\* ------------------------- */\n/* ------------------------- *\\\n      FONTS\n\\* ------------------------- */\n@font-face {\n  font-family: \"Proxima Nova\";\n  src: url(" + __webpack_require__(48) + ");\n  font-weight: 300;\n}\n@font-face {\n  font-family: \"Proxima Nova\";\n  src: url(" + __webpack_require__(49) + ");\n  font-weight: 400;\n}\n@font-face {\n  font-family: \"Proxima Nova\";\n  src: url(" + __webpack_require__(50) + ");\n  font-weight: 500;\n}\n@font-face {\n  font-family: \"Sci Fly\";\n  src: url(" + __webpack_require__(51) + ");\n}\n/* ------------------------- *\\\n      COLORS\n\\* ------------------------- */\n/* ------------------------- *\\\n      DEFAULT\n\\* ------------------------- */\n/* ------------------------- *\\\n      ANIMATIONS\n\\* ------------------------- */\n/* ------------------------- *\\\n      BASE\n\\* ------------------------- */\n/* ------------------------- *\\\n      BASE\n\\* ------------------------- */\nhtml,\nbody,\n#main {\n  height: 100%;\n  width: 100%;\n}\nbody {\n  font: 300 16px 'Proxima Nova';\n  margin: 0;\n  padding: 0;\n}\n/* ------------------------- *\\\n      FORMS\n\\* ------------------------- */\n.atellier-input {\n  background-color: #3f3639;\n  border-radius: 2px;\n  border: none;\n  color: #a49d98;\n  font-size: 16px;\n  font-weight: 300;\n  outline: none;\n  padding: 13px;\n  width: 100%;\n  resize: none;\n  box-sizing: border-box;\n}\n.atellier-input::-webkit-input-placeholder {\n  color: #736d6b;\n}\n.atellier-input::-webkit-outer-spin-button,\n.atellier-input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.atellier-input-icon {\n  background-repeat: no-repeat;\n  background-position: 13px;\n  padding-left: 36px;\n}\n.atellier-input.json {\n  height: 160px;\n}\nselect.atellier-input {\n  height: 44px;\n}\n.atellier-editor {\n  width: 100%!important;\n  height: 300px!important;\n}\n/* ------------------------- *\\\n      COMPONENTS\n\\* ------------------------- */\n/* ------------------------- *\\\n      ATTELLIER\n\\* ------------------------- */\n.atellier {\n  background-color: #393234;\n  position: fixed;\n  height: 100%;\n  width: 100%;\n  align-content: stretch;\n  align-items: stretch;\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-start;\n}\n/* ------------------------- *\\\n      COMPONENT LIST\n\\* ------------------------- */\n.component-nav {\n  flex: 1 1 auto;\n  align-content: stretch;\n  align-items: stretch;\n  display: flex;\n  flex-flow: column;\n  justify-content: flex-start;\n}\n.component-tools {\n  padding: 0 12px;\n  flex: 0 0 56px;\n}\n.component-filter {\n  margin: 8px 0;\n  height: 40px;\n  background-image: url(" + __webpack_require__(52) + ");\n}\n.component-list {\n  border-top: 1px solid #2f272a;\n  display: block;\n  height: 1px;\n  list-style: none;\n  margin-top: 18px;\n  margin: 0;\n  overflow: scroll;\n  padding: 0;\n  flex: 1 1 auto;\n}\n.component-list-item {\n  border-bottom: 1px solid #3c3336;\n  color: #a49d98;\n  cursor: pointer;\n  display: block;\n  padding: 19px 24px;\n  line-height: 16px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.component-list-item-selected {\n  background-color: #987b62;\n  color: #cac4bc;\n  font-weight: bold;\n}\n.component-list-item-error {\n  opacity: 0.5;\n  text-shadow: none;\n  color: grey;\n  text-decoration: line-through;\n}\n/* ------------------------- *\\\n      COMPONENT PROPERTIES\n\\* ------------------------- */\n.component-properties {\n  padding: 25px;\n  position: relative;\n  overflow: scroll;\n  border-right: 1px solid #2f272a;\n  flex: 0 0 362px;\n}\n.properties-container {\n  background-color: #494043;\n  border-radius: 2px;\n  border: 1px solid #2f272a;\n  position: relative;\n  width: 100%;\n}\n.properties-container .properties-container {\n  margin-top: 21px;\n}\n.container-close-button {\n  color: #2f272a;\n  cursor: pointer;\n  font-size: 35px;\n  position: absolute;\n  right: 23px;\n  top: 7px;\n  transform: rotate(45deg);\n}\n.properties-component {\n  border-bottom: 1px solid #2f272a;\n  color: #cac4bc;\n  font-size: 18.67px;\n  font-weight: 400;\n  margin: 0;\n  padding: 14px 24px;\n}\n.properties-form {\n  padding: 0 14px;\n  position: relative;\n}\n.no-properties {\n  margin: 22px 0;\n}\n/* ------------------------- *\\\n      FIELD TYPE\n\\* ------------------------- */\n.properties-field {\n  padding: 21px 0;\n  border-top: 1px solid #3c3336;\n}\n.properties-field:first-child {\n  border-top: none;\n}\n.properties-field label {\n  color: #cac4bc;\n  display: inline-block;\n  font-weight: 400;\n  margin-bottom: 11px;\n}\n.properties-field .atellier-toggle {\n  float: right;\n}\n.properties-field .atellier-toggle + label {\n  margin-bottom: 0;\n  line-height: 25px;\n}\n.properties-field.error {\n  color: #c64040;\n}\n.properties-field.error label {\n  color: #c64040;\n}\n.properties-field.error input,\n.properties-field.error textarea,\n.properties-field.error select {\n  color: #c64040;\n  background-color: #f0cdcd;\n  border-top: 1px solid #c64040;\n  border: 1px solid #c64040;\n}\n/* ------------------------- *\\\n      SIDEBAR\n\\* ------------------------- */\n.sidebar {\n  background-color: #494043;\n  border-right: 1px solid #2f272a;\n  height: 100%;\n  position: relative;\n  margin-left: 0;\n  margin-right: 0;\n  transition: margin-left 0.5s, margin-right 0.5s;\n  flex: 0 0 315px;\n  align-content: stretch;\n  align-items: stretch;\n  display: flex;\n  flex-flow: column;\n  justify-content: flex-start;\n}\n.sidebar-close {\n  margin-left: -315px;\n  margin-right: 50px;\n}\n.sidebar-close .sidebar-toggle-button {\n  background-color: #494043;\n  right: -51px;\n}\n.sidebar-close .sidebar-toggle-button img {\n  transform: rotate(0deg);\n}\n.sidebar-toggle-button {\n  background-color: #3f3639;\n  color: #9d9693;\n  cursor: pointer;\n  display: block;\n  font-weight: 400;\n  height: 25px;\n  line-height: 25px;\n  position: absolute;\n  right: 12px;\n  text-align: center;\n  top: 25px;\n  transition: right 0.5s, color 0.5s;\n  width: 25px;\n}\n.sidebar-toggle-button img {\n  padding: 8px 0;\n  transform: rotate(180deg);\n  transition: transform 0.5s;\n}\n.logo {\n  color: #987b62;\n  font: 23.33px \"Sci Fly\";\n  letter-spacing: 3px;\n  margin: 25px 0 18px 0;\n  text-align: center;\n  text-transform: uppercase;\n  flex: 0 0 25px;\n}\n/* ------------------------- *\\\n      STAGE\n\\* ------------------------- */\n.stage {\n  padding: 25px;\n  position: relative;\n  overflow: hidden;\n  flex: 1 1 auto;\n  align-content: stretch;\n  align-items: stretch;\n  display: flex;\n  flex-flow: column;\n  justify-content: flex-start;\n}\n.stage-board {\n  border-radius: 2px;\n  background-color: #ffffff;\n  background-image: linear-gradient(#f1f1f1 1px, transparent 1px), linear-gradient(90deg, #f1f1f1 1px, transparent 1px);\n  background-size: 20px 20px, 20px 20px;\n  background-position: -1px -1px, -1px -1px;\n  position: relative;\n  overflow: scroll;\n  flex: 1 1 auto;\n}\n.stage-board-dark {\n  background-color: #000000;\n}\n.stage-tools {\n  margin-top: 25px;\n  flex: 0 0 54px;\n}\n.stage-tools label {\n  color: #cac4bc;\n  margin-right: 10px;\n  font-weight: 400;\n}\n.stage-tools select.atellier-input {\n  width: 200px;\n}\n.stage-render-error {\n  background-color: #F2DEDE;\n  padding: 10px 20px;\n}\n.stage-render-error .stage-error-text {\n  margin-left: 10px;\n}\n.stage-render-error .stage-error-message {\n  padding: 5px;\n  background: white;\n}\n.stage-render-error button.reload {\n  border: 0;\n  padding: 5px 20px;\n  background-color: #C9302C;\n  color: white;\n  cursor: pointer;\n}\n/* ------------------------- *\\\n      TOGGLE\n\\* ------------------------- */\n.atellier-toggle {\n  border-radius: 25px;\n  cursor: pointer;\n  display: block;\n  height: 25px;\n  outline: none;\n  position: relative;\n  user-select: none;\n  width: 49px;\n}\n.atellier-toggle:before,\n.atellier-toggle:after {\n  bottom: 1px;\n  content: \"\";\n  display: block;\n  left: 1px;\n  position: absolute;\n  top: 1px;\n}\n.atellier-toggle:before {\n  background-color: #3e3538;\n  border-radius: 25px;\n  right: 1px;\n  transition: background 0.4s;\n}\n.atellier-toggle:after {\n  width: 23px;\n  border: 1px solid #2f272a;\n  background-color: #494043;\n  border-radius: 100%;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);\n  transition: margin 0.4s;\n}\n.atellier-toggle-checked:before {\n  background-color: #94785f;\n}\n.atellier-toggle-checked:after {\n  margin-left: 25px;\n}\n/* ------------------------- *\\\n      WORKSPACE\n\\* ------------------------- */\n.workspace {\n  height: 100%;\n  overflow: hidden;\n  flex: 1 1 auto;\n  align-content: stretch;\n  align-items: stretch;\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-start;\n}\n", ""]);

	// exports


/***/ }),
/* 47 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = "data:font/opentype;base64,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A+wD8gP4BAQEEAQWBBwEIAQkBCoEMAQ8BEgETgRUBF8EYgRlBGwEcwR5BH8EjASZBJ8EpQSxBL0EwwTJBM8E1QTgBOsE8wT7BQcFEwUZBR8FIwUnBS0FMwU6BUEFRwVNBVIFVwVkBXEFeAV/BYoFlQWgBasFsQW3BcEFywXQBdcF3gXpBfQGAAYMBhUGIAYkBisGMQY2Bj0GRgZPBlgGYQZsBnUGfgaFBo8GmAalBrEGvAbDBsoG1QbeBucG8Qb4BwEHBgcJBxkHIwcsBzQHPgdHB1AHWAdiB2wHdQeBB4sHlAedB6gHsge8B8UH0AfbB+UH9wgACAsIGggnCC8IOAhBCEkIUQhbCGQIbQh1CH8IiQiSCJsIowirCLUIvgjHCM8I2QjjCOwI9wkDCQ8JGwkmCTEJQQlQCVsJZglxCXwJiwmXCZ8Jqwm2CcYJ1wnmCfYJ/woKChEKHQopCjQKRApVCmAKawp8CoUKkAqbCqwKtwrJCtUK5QrwCvsLDAsXCyQLNAtFC04LWQtqC3ULhwuTC58LqQu0C8QL1AvfC+4L/QwLDBoMKgw7DEkMWAxnDHgMigydDK8MwgzNDNgM4wz2DQENCg0VDR0NKA0vDToNRQ1QDVsNaQ1yDXoNgg2MDZUNng2mDbANug3DDdAN1g3cDeIN6A3uDfQN+g4ADgYODA4SDhgOHg4kDioOMA42DjwOQg5IDk4OVA5aDmAOZg5sDnsOjA6XDqIOsg69DssO1Q7cDukO9A7/Dw8PHQ8oDzMPQw9RD1kPZA9vD3oPig+VD6MPrg+5D8QP1A/iD+0P9xAFEAgQDRASEEkQWxBqbm90ZXF1YWxpbmZpbml0eWxlc3NlcXVhbGdyZWF0ZXJlcXVhbHBhcnRpYWxkaWZmc3VtbWF0aW9ucHJvZHVjdHBpaW50ZWdyYWxPbWVnYXJhZGljYWxhcHByb3hlcXVhbERlbHRhbmJzcGFjZWxvemVuZ2VFdXJvdW5pMjMxOGYuYWx0MWZfYmZfaGZfa2wuYWx0MWEuYWx0MXkuYWx0MUcuYWx0MUcuc21jcC5hbHQxR2JyZXZlLmFsdDFHYnJldmUuc21jcC5hbHQxR2NvbW1hYWNjZW50LmFsdDFHY29tbWFhY2NlbnQuc21jcC5hbHQxbHNsYXNoLmFsdDFsYWN1dGUuYWx0MWxjb21tYWFjY2VudC5hbHQxbGNhcm9uLmFsdDFhYWN1dGUuYWx0MWFncmF2ZS5hbHQxYWNpcmN1bWZsZXguYWx0MWFkaWVyZXNpcy5hbHQxYXRpbGRlLmFsdDFhcmluZy5hbHQxYW1hY3Jvbi5hbHQxYWJyZXZlLmFsdDFhb2dvbmVrLmFsdDF5YWN1dGUuYWx0MXlkaWVyZXNpcy5hbHQxYWUuYWx0MXplcm8ucHplcm9HY2lyY3VtZmxleC5hbHQxR2RvdGFjY2VudC5hbHQxR2NpcmN1bWZsZXguc21jcC5hbHQxR2RvdGFjY2VudC5zbWNwLmFsdDFhZWFjdXRlLmFsdDF5Y2lyY3VtZmxleC5hbHQxbGRvdC5hbHQxZmwuYWx0MWZfZl9sLmFsdDFBbWFjcm9uYW1hY3JvbkFicmV2ZWFicmV2ZUFvZ29uZWthb2dvbmVrQ2FjdXRlY2FjdXRlQ2NpcmN1bWZsZXhjY2lyY3VtZmxleENkb3RhY2NlbnRjZG90YWNjZW50Q2Nhcm9uY2Nhcm9uRGNhcm9uZGNhcm9uRGNyb2F0ZGNyb2F0RW1hY3JvbmVtYWNyb25FYnJldmVlYnJldmVFZG90YWNjZW50ZWRvdGFjY2VudEVvZ29uZWtlb2dvbmVrRWNhcm9uZWNhcm9uR2NpcmN1bWZsZXhnY2lyY3VtZmxleEdicmV2ZWdicmV2ZUdkb3RhY2NlbnRnZG90YWNjZW50R2NvbW1hYWNjZW50Z2NvbW1hYWNjZW50SGNpcmN1bWZsZXhoY2lyY3VtZmxleEhiYXJoYmFySXRpbGRlaXRpbGRlSW1hY3JvbmltYWNyb25JYnJldmVpYnJldmVJb2dvbmVraW9nb25la0lkb3RhY2NlbnRJSmlqSmNpcmN1bWZsZXhqY2lyY3VtZmxleEtjb21tYWFjY2VudGtjb21tYWFjY2VudGtncmVlbmxhbmRpY0xhY3V0ZWxhY3V0ZUxjb21tYWFjY2VudGxjb21tYWFjY2VudExjYXJvbmxjYXJvbkxkb3RsZG90TmFjdXRlbmFjdXRlTmNvbW1hYWNjZW50bmNvbW1hYWNjZW50TmNhcm9ubmNhcm9ubmFwb3N0cm9waGVFbmdlbmdPbWFjcm9ub21hY3Jvbk9icmV2ZW9icmV2ZU9odW5nYXJ1bWxhdXRvaHVuZ2FydW1sYXV0UmFjdXRlcmFjdXRlUmNvbW1hYWNjZW50cmNvbW1hYWNjZW50UmNhcm9ucmNhcm9uU2FjdXRlc2FjdXRlU2NpcmN1bWZsZXhzY2lyY3VtZmxleFNjZWRpbGxhc2NlZGlsbGFUY29tbWFhY2NlbnR0Y29tbWFhY2NlbnRUY2Fyb250Y2Fyb25UYmFydGJhclV0aWxkZXV0aWxkZVVtYWNyb251bWFjcm9uVWJyZXZldWJyZXZlVXJpbmd1cmluZ1VodW5nYXJ1bWxhdXR1aHVuZ2FydW1sYXV0VW9nb25la3VvZ29uZWtXY2lyY3VtZmxleHdjaXJjdW1mbGV4WWNpcmN1bWZsZXh5Y2lyY3VtZmxleFphY3V0ZXphY3V0ZVpkb3RhY2NlbnR6ZG90YWNjZW50bG9uZ3NBRWFjdXRlYWVhY3V0ZU9zbGFzaGFjdXRlb3NsYXNoYWN1dGVTY29tbWFhY2NlbnRzY29tbWFhY2NlbnRoc3VwZXJpb3JmcmVuY2hmcmFuY2xpcmF1bmkyMEE2cGVzZXRhcnVwZWV1bmkyMEE5YWZpaTU3NjM2YWZpaTYxMjg5YWZpaTYxMzUycHVibGlzaGVkc2VydmljZW1hcmtlc3RpbWF0ZWRhcnJvd2xlZnRhcnJvd3VwYXJyb3dyaWdodGFycm93ZG93bnRyaWFuZ2xlcmlnaHR0cmlhbmdsZWxlZnRibGFja3NxdWFyZXRyaWFndXB0cmlhZ2RuY2lyY2xlc29saWRibGFja3N0YXJiYWxsb3Rib3hib3hjaGVja2VkZGlhbW9uZGNoZWNrbWFya2ZfZl9qZl9qcGVydGhvdXNhbmQub251bXplcm8udHplcm96ZXJvLnRudW10d28udG51bXRocmVlLnRudW1mb3VyLnRudW1maXZlLnRudW1zaXgudG51bXNldmVuLnRudW1laWdodC50bnVtbmluZS50bnVtcGVyY2VudC5vbnVtemVyby50b251bW9uZS50b251bXR3by50b251bXRocmVlLnRvbnVtZm91ci50b251bWZpdmUudG9udW1zaXgudG9udW1zZXZlbi50b251bWVpZ2h0LnRvbnVtbmluZS50b251bWNvbG9ubW9uZXRhcnkub251bUV1cm8ub251bWZsb3Jpbi5vbnVtbnVtYmVyc2lnbi5vbnVtc3Rlcmxpbmcub251bXllbi5vbnVtY2VudC5vbnVtemVyby5kbm9tb25lLmRub210d28uZG5vbXRocmVlLmRub21mb3VyLmRub21maXZlLmRub21zaXguZG5vbXNldmVuLmRub21laWdodC5kbm9tbmluZS5kbm9temVyby5udW1yb25lLm51bXJ0d28ubnVtcnRocmVlLm51bXJmb3VyLm51bXJmaXZlLm51bXJzaXgubnVtcnNldmVuLm51bXJlaWdodC5udW1ybmluZS5udW1yQWJyZXZlLnNtY3BBbWFjcm9uLnNtY3BBb2dvbmVrLnNtY3BBRWFjdXRlLnNtY3BDYWN1dGUuc21jcENjYXJvbi5zbWNwQ2NpcmN1bWZsZXguc21jcENkb3RhY2NlbnQuc21jcERjYXJvbi5zbWNwRGNyb2F0LnNtY3BFYnJldmUuc21jcEVjYXJvbi5zbWNwRWRvdGFjY2VudC5zbWNwRW1hY3Jvbi5zbWNwRW5nLnNtY3BFb2dvbmVrLnNtY3BHYnJldmUuc21jcEdjaXJjdW1mbGV4LnNtY3BHY29tbWFhY2NlbnQuc21jcEdkb3RhY2NlbnQuc21jcEhjaXJjdW1mbGV4LnNtY3BIYmFyLnNtY3BJYnJldmUuc21jcElKLnNtY3BJbWFjcm9uLnNtY3BJb2dvbmVrLnNtY3BJdGlsZGUuc21jcEpjaXJjdW1mbGV4LnNtY3BLY29tbWFhY2NlbnQuc21jcExhY3V0ZS5zbWNwTGNhcm9uLnNtY3BMY29tbWFhY2NlbnQuc21jcExkb3Quc21jcE5hY3V0ZS5zbWNwTmNhcm9uLnNtY3BOY29tbWFhY2NlbnQuc21jcE9icmV2ZS5zbWNwT2h1bmdhcnVtbGF1dC5zbWNwT21hY3Jvbi5zbWNwT3NsYXNoYWN1dGUuc21jcFJhY3V0ZS5zbWNwUmNhcm9uLnNtY3BSY29tbWFhY2NlbnQuc21jcFNhY3V0ZS5zbWNwU2NlZGlsbGEuc21jcFNjaXJjdW1mbGV4LnNtY3BTY29tbWFhY2NlbnQuc21jcFRiYXIuc21jcFRjYXJvbi5zbWNwVGNvbW1hYWNjZW50LnNtY3BVYnJldmUuc21jcFVodW5nYXJ1bWxhdXQuc21jcFVtYWNyb24uc21jcFVvZ29uZWsuc21jcFVyaW5nLnNtY3BVdGlsZGUuc21jcFdjaXJjdW1mbGV4LnNtY3BZY2lyY3VtZmxleC5zbWNwWmFjdXRlLnNtY3BaZG90YWNjZW50LnNtY3BJZG90YWNjZW50LnNtY3BwYXJlbmxlZnQuY2FzZXBhcmVucmlnaHQuY2FzZWJyYWNrZXRsZWZ0LmNhc2VicmFja2V0cmlnaHQuY2FzZWJyYWNlbGVmdC5jYXNlYnJhY2VyaWdodC5jYXNlZXhjbGFtZG93bi5jYXNlcXVlc3Rpb25kb3duLmNhc2VndWlsbGVtb3RsZWZ0LmNhc2VndWlsbGVtb3RyaWdodC5jYXNlZ3VpbHNpbmdsbGVmdC5jYXNlZ3VpbHNpbmdscmlnaHQuY2FzZWh5cGhlbi5jYXNlZW5kYXNoLmNhc2VlbWRhc2guY2FzZXBlcmlvZGNlbnRlcmVkLmNhc2VidWxsZXQuY2FzZWNlbnQuY2FzZWNvbW1hYWNjZW50b25lLnRudW1Mc2xhc2guc21jcE9FLnNtY3BTY2Fyb24uc21jcFpjYXJvbi5zbWNwZXhjbGFtLnNtY3Bkb2xsYXIub251bWFtcGVyc2FuZC5zbWNwemVyby5vbnVtb25lLm9udW10d28ub251bXRocmVlLm9udW1mb3VyLm9udW1maXZlLm9udW1zaXgub251bXNldmVuLm9udW1laWdodC5vbnVtbmluZS5vbnVtcXVlc3Rpb24uc21jcEEuc21jcEIuc21jcEMuc21jcEQuc21jcEUuc21jcEYuc21jcEcuc21jcEguc21jcEkuc21jcEouc21jcEsuc21jcEwuc21jcE0uc21jcE4uc21jcE8uc21jcFAuc21jcFEuc21jcFIuc21jcFMuc21jcFQuc21jcFUuc21jcFYuc21jcFcuc21jcFguc21jcFkuc21jcFouc21jcGV4Y2xhbWRvd24uc21jcHF1ZXN0aW9uZG93bi5zbWNwQWdyYXZlLnNtY3BBYWN1dGUuc21jcEFjaXJjdW1mbGV4LnNtY3BBdGlsZGUuc21jcEFkaWVyZXNpcy5zbWNwQXJpbmcuc21jcEFFLnNtY3BDY2VkaWxsYS5zbWNwRWdyYXZlLnNtY3BFYWN1dGUuc21jcEVjaXJjdW1mbGV4LnNtY3BFZGllcmVzaXMuc21jcElncmF2ZS5z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AOMALQDjABEBTwAlAfAAHQDbADoBLAAeANsAQQEaAAACYAA6ATQAGgJGADgCIAAgAh0AIwJGAEoCSAA6AfYAIQI7ADsCSAA5ANkAQQDbADoB8AAdAfAAHQHwAB0B0AAWAw8AIwKHAA8CZwBTAp8AOgK0AFMCNABTAh4AUwLHADoCvwBTAN8AUwHWAA4CSgBTAeQARQMWAFMCuwBTAvwAOgI7AFMC/AA6AlIAUwJFAC4CNAAjAq4AUwKHAA8DYwATAoUAEwJqAA8CRQAyAOQAJQEaAAAA5AARAawAEwI0//0A2wAzAgkANwI7AFEB7gA2AjsANgI3ADYBCQASAjoANgIcAFEA1gBDANb/nwH5AFEA1gBRAxUAUQIcAFECOwA2AjcAUQI3ADIBPQBRAcsAJwETAAsCHABRAeEABwLPABEB3wARAeEABwHVADgA+QAGANAAUwD5ABEB8wAcANsAQQHuADYB+AASAIL/VQJqAA8BpgAhAc0AJwIKACQAuwA6AWkAPAGSAB4BFQAeARUAHgHeABIB3gASAlEAHgEBABgBAQAYANsAQgHBABsBZgBNANsAOgFpADoBaQA6AZIAHgKRAEIEKwAiAYgAJADYAAAA2AAAAPoAAAEzAAABawAAAV8AAABVAAUBBv/4AL8AAADGAAABIwAAAKsAAAD6AAADQQAeA6sADgF3AC4CCAALAvwAOgRbADoBlQAsA4EANwDWAFEBFQALAjsANgPPADYCQgBRANYAEQHzAB0CHABRAcYAEQLRAAsDDQARAfAAHQI7AFMC5gARAf8AHQDQAFMBGgAZAjcAUQNbAC4BgAA0Ae4AIwHwAB0COwA2AfAAQwGAAC4DCgAsAocADwKHAA8ChwAPAocADwKHAA8ChwAPAp8AOgI0AFMCNABTAjQAUwI0AFMA3wA1AN//9ADf/+UA3//UArsAUwL8ADoC/AA6AvwAOgL8ADoC/AA6AkUALgKuAFMCrgBTAq4AUwKuAFMCagAPAmoADwJFADICCQA3AgkANwIJADcCCQA3AgkANwIJADcB7gA2AjcANgI3ADYCNwA2AjcANgDWADAA1v/uANb/4ADW/84CHABTAjsANgI7ADYCOwA2AjsANgI7ADYBywAnAhwAUQIcAFECHABRAhwAUQHhAAcB4QAHAdUAOAFtABwAlAAbAJQAGQCDABsAiAAlAXcALgGYAEEBMQAgAZkALAGRACwAmAAuAKwAQQIxAEEBiQBBAZUALADpAEEBSAAfAMEACQCUABsAlAAZALgAEgKiADwETwBTALgAEgMNABEDggAuA4AAMAMrACMDDQARA4IANAGAACMBgAArAYAAMAGAACoBZwAjAYAALgGAACoBgAAjANYAEQGAADQBgAAuAYAAKwGAADABgAAqAWcAIwGAAC4BgAAqATEAIAFtABwAiAAlAIMAGwHwAB0CggAdAfAAHQHwABwCOwA2AjsAOgKhACMCFwAjAVEAEQL8ADoC6ABIAfAAHQKHAA8BAwAAAXcAEwKyACMCmwAqAQkAEgNDABIDJQASAwIAEgEAAFECOwA2AhwASwLHADoChwA2AuoAOgKGADYC6gA6AocANgEfAAsBAAAwAQAAUQENAFECOwA2AjsANgI7ADYCOwA2AjsANgI7ADYCOwA2AjsANgI7ADYCHABLAhwASwOzADYCYAA6AuoAOgLqADoCdgA2AnYANgOBADYCHABLAREAUQIJABIDEQASAocADwIJADcChwAPAgkANwKHAA8CCQA3Ap8AOgHuADYCnwA6Ae4ANgKfADoB7gA2Ap8AOgHuADYCtABTAnEANgLRAAsCPgA2AjQAUwI3ADYCNABTAjcANgI0AFMCNwA2AjQAUwI3ADYCNABTAjcANgLHADoCOgA2AscAOgI6ADYCxwA6AjoANgLHADoCOgA2Ar8AUwIc//AC1AALAh4ACwDf/9YA1v/RAN//uwDW/7YA3//BANb/vADfABgA1gARAN8ASgK1AFMBqwBDAdYADgDW/58CTQBTAfkAUQH5AFEB5ABFANYAMAHkAEUA1gBAAeQARQEIAFEB7gBFAREAUQK7AFMCHABTArsAUwIcAFMCuwBTAhwAUwIcAD4CuwBTAhwAUQL8ADoCOwA2AvwAOgI7ADYC/AA6AjsANgJSAFMBPQBRAlIAUwE9AFECUgBTAT0APQJFAC4BywAnAkUALgHLACcCRQAuAcsAJwI0ACMBEwALAjQAIwEdAAsCNAAjARMACwKuAFMCHABRAq4AUwIcAFECrgBTAhwAUQKuAFMCHABRAq4AUwIcAFECrgBTAhwAUQNjABMCzwARAmoADwHhAAcCRQAyAdUAOAJFADIB1QA4AQkAEgOrAA4DgQA3AvwAOgI7ADYCSAAwAc0AJwGJAEECKQALAfgAEgLSAAsCcAALA+QAUwNjABMDKgBRAcYAUQRQAFMDCgAsAdwADwNKAB8CRgAAAkYAVgJGAC8CRgBXAksANgJLAAAClQAvAmj//gJo//4CtwAyAvcAAAKVAC0ClQAtAfUAAAITAAAC5wASAd4AEgNjABoCXAA4AkwAMAJMAEUCTABDAkwAOQJMAE0CTABAAkwATAJMAEMCTAA3AkYAGgJMADACTACtAkwARQJMAEMCTAA5AkwATQJMAEACTABMAkwAQwJMADcCRQA2AmIAIwFiABoB6AAYAZ8ADgIbAAwCRQA2AYAAIwDWABEBgAA0AYAALgGAACsBgAAwAYAAKgFnACMBgAAuAYAAKgGAACMA1gARAYAANAGAAC4BgAArAYAAMAGAACoBZwAjAYAALgGAACoCMgAMAjIADAIyAAwDKwAMAkUANgJFADYCRQA2AkUANgJjAEMCbgALAfkAUQH5AFEB+QBRAfkAUAJxAFEB+QBRAnYANgJ2ADYCdgA2AnYANgJ1AFECigALANf/uQJ5AFEA1/+4ANcAEwDX/9MBoQAKAgkAUQHGAFEBxgBRAcYAUQHNAFECcQBRAnEAUQJxAFECmgA2ApoANgKaADYCmgA2AhUAUQIVAFECFQBRAfMAJwHzACcB8wAnAfMAJwHRAB0B0QAdAdEAHQJlAFECZQBRAmUAUQJlAFECZQBRAmUAUQLtAA8CGwAMAgEAKQIBACkAvAA4AOMALQDjABEA5AAlAOQAEQD5AAYA+QARANsAQQHQACQBkgAeAZIAHgEVAB4BFQAeASwAHgJRAB4DQQAeANsAQgFmAE0B7gA2ANsAPQJMAK0B4gALA8QANgHzACcCAQApALAALAHzACcCKAAeAmAAOgE0ABoCQAA0Ah4AHgIdACMCRgBKAkgAOgH2ACECOwA7AkgAOQGNAAwCMgAMAh0AUQJFADYCYwBRAfkAUQHjAFECdgA2AnUAUQDYAFEBoQAKAgkAUQHGAFECvwBRAnEAUQKaADYB/QBRApoANgIVAFEB8wAnAdEAHQJlAFECMgAMAu0ADwIwAA4CGwAMAgEAKQCwAC0BjQAcAjIADAIyAAwCMgAMAjIADAIyAAwCMgAMAysADAJFADYB+QBRAfkAUQH5AFEB+QBRANf/0ADXADIA1//wANf/4gJuAAsCcQBRApoANgKaADYCmgA2ApoANgKaADYCmgA2AmUAUQJlAFECZQBRAmUAUQIbAAwB/QBRAhsADAISABIC5wASABIAAAABAAAACgBmAZwAAWxhdG4ACAAQAAJNT0wgAERST00gAEwAAP//ABcAAAABAAIAAwAEAAUACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYAAD//wABAAYAAP//AAEABwAZYzJzYwCYY2FzZQCeZG5vbQCkZnJhYwCqbGlnYQC4bG51bQC+bG9jbADEbG9jbADKbnVtcgDQb251bQDWb3JkbgDccG51bQDic2FsdADoc2luZgDuc21jcAD0c3MwMQD6c3MwMgEAc3MwMwEGc3MwNAEMc3MwNgESc3MwNwEYc3VicwEec3VwcwEkdG51bQEqemVybwEwAAAAAQANAAAAAQAbAAAAAQADAAAABQAEAAUABgAHAAgAAAABABYAAAABABcAAAABAAAAAAABAAEAAAABAAIAAAABABgAAAABAAwAAAABABoAAAABABUAAAABAAsAAAABAA4AAAABAA8AAAABABAAAAABABEAAAABABIAAAABABMAAAABABQAAAABAAoAAAABAAkAAAABABkAAAABABwAHwBAAEgAUABYAGAAaACAAIgAkACYAKAAqACwAOAA6ADwAPgBAAEIARABGAEgASgBMAE4AUABSAFQAVgBYAFoAAEAAAABATAAAQAAAAEBNAABAAAAAQE4AAEAAAABATYAAQAAAAEBNAAGAAAACQEyAUYBWgFuAYIBlgGqAb4B0gABAAAAAQHOAAYAAAABAcwAAQAAAAEB1gABAAAAAQHUAAEAAAABAfQAAQAAAAECFAAGAAAAFQI0AkYCWAJsAoAClgKsAr4C0gLmAvYDCAMaAy4DQgNSA2QDdgOKA54DsgABAAAAAQOWAAEAAAABBJwAAQAAAAEFvgABAAAAAQXoAAEAAAABBhIAAQAAAAEGJAABAAAAAQY6AAEAAAABBkQAAQAAAAEGSgAEAAAAAQaIAAEAAAABBvIAAQAAAAEHLAABAAAAAQdmAAEAAAABB44AAQAAAAEHtgABAAAAAQgUAAQAAAABCBYAAQAAAAEI3AACCP4AAwHKAcsCSQACCPIAAwHKAcsCSQABCPACAAABCOoB9gABCOQCAAADAAAAAwjoCO4I9gAAAAEAAAAdAAMAAAADCNQI2gjoAAAAAQAAAB0AAwAAAAMI2gjGCNQAAAABAAAAHQADAAAAAwisCLIIxgAAAAEAAAAdAAMAAAADCKYIngiyAAAAAQAAAB0AAwAAAAMIhAiKCKQAAAABAAAAHQADAAAAAwiKCHYIkAAAAAEAAAAdAAMAAAADCIIIYgh8AAAAAQAAAB0AAwAAAAMIdAhOCGgAAAABAAAAHQABCCoCAAADAAEIYAABCI4AAAABAAAAHgABCIYAUwACCIYAEQDlAOYA5wDoAPkA6QEDAJYApACpAQQBBQEGAQcBCAEJAOwAAgheABEBFQD3APgBFwD8ARYBCgELAQwBDQEOAQ8BEAERARIBEwEUAAIINgARARUA9wD4ARcA/AEWAQoBCwEMAQ0BDgEPARABEQESARMBFAADAAEHlAABCDAAAAABAAAAHgADAAEHggABCCQAAAABAAAAHgADAAIIGAdwAAEIDAAAAAEAAAAeAAMAAggEB1wAAQf+AAAAAQAAAB4AAwACB0gHUgABB/YAAQf8AAEAAAAeAAMAAwfsBzIHPAABB+YAAAABAAAAHgADAAIHJgcmAAEH3AABB8oAAAADAAEHFAABB8oAAQe4AAEAAAAeAAMAAge8BwAAAQekAAAAAQAAAB4AAwACBvoG7AABB64AAAAAAAMAAQbqAAEHngAAAAEAAAAeAAMAAgbYBsoAAQeSAAEHjAAAAAMAAQbGAAEHgAABB3oAAQAAAB4AAwACB3IGsgABB2YAAAABAAAAHgADAAIGqgaQAAEHUgAAAAAAAwABBpoAAQdCAAAAAQAAAB4AAwACBogGbgABB0IAAQcwAAAAAwABBnYAAQcwAAEHHgABAAAAHgADAAIHIgZiAAEHCgAAAAEAAAAeAAMAAQcUAAEG2AABBt4AAQAAAB4AAwACBtAHAAABBsoAAAABAAAAHgACBvwAhAJwAnICfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZAqACbAKxAm0CqgK3ApsCnAKeApoCnwKdAqECowKkAqUCogKnAqgCqQKmAqsCrQKuArACrAKvAm4CswK0ArUCsgK2ArgCbwExATMBSgE1AUkCHAIbAh0CHwIhAiICIAIjAiQCKAIlAicCKgImAiwCKwIuAi0CLwIwAjUCMwIxAjQCVwIyAjYCNwI4AjoCOQI7AjwCPgI9AikCQQI/AkACQwJFAkQCRgJIAkcCTAJLAkoCUgJPAk0CUQJOAlACUwJUAlUCVgIeAkICSQACBvoAkgJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCoAKGAmwCsQJtArcCqgKbApwCngKaAp8CnQKhAqMCpAKlAqICpwKoAqkCpgKrAq0CrgKwAqwCrwJuArMCtAK1ArICtgK4Am8CiQJ+ApYCbAI4AjoCOQKbApoCnAKeAp0CnwIcAhsCHQK2ArgCoAIeAlQCOwIcAhsCHQIfAiECIgIgAiMCJAIoAiUCJwIqAiYCLAIrAi4CLQIvAjACNQIzAjECNAIyAjYCNwKIAjgCOgI5AjsCPAI+Aj0CKQJBAj8CQAJDAkUCRAJGAkgCRwJMAksCSgJSAk8CTQJRAk4CUAJTAlQCVQJWApACHgJCAkkAAgb4ABYBLgEtAS8BRQE2AToBPAE9ATsBPwE+AUMBRAFAAUEBQgE3ATgBOQFNAUwBSwACBvYAFgEwAS4BRQE6ATwBPQE7AT8BPgFAAUEBQgFHATIBSAE0AUsBMwFJATUBSgExAAIG9AAKATABRwEyAUgBNAEzAUkBNQFKATEAAgbyAAwBLgFFAToBPAE9ATsBPwE+AUABQQFCAUsAAgbwAAYBLQE2ATcBOAE5AU0AAgbuAAQBLwFDAUQBTAACBuwAIAEwAS4BLQEvAUUBNgE6ATwBPQE7AT8BPgFDAUQBQAFBAUIBRwEyAUgBNAE3ATgBOQFNAUwBSwEzAUkBNQFKATEAAQbqAAEACAAMABoAIgAqADIAOgBAAEYATABSAFgAXgBkAroAAwBHAEoB6AADAEcASwK7AAMARwBNAU8AAwBHAS0BKgACAEMCuQACAEcBKwACAEkAbQACAEoB6QACAEsBLAACAEwAbgACAE0BTgACAS0AAgZ+AB4AegAGAewCawHtAe4B7wHwAfEB8gHzAfQA+gEnAGUABABiAGQAYQAFABEAEgATABQAFQAWABcAGAAZABoAAgZYAB4CAwJxAfUCcwJ0AnUCdgJ3AngCeQJ6AnsCfAIGAgQCBQICAeoCAAIBAfYB+AH5AfoB+wH8Af0B/gH/AfcAAgZQABUB7AJrAe0B7gHvAfAB8QHyAfMB9AHrAfYB9wH4AfkB+gH7AfwB/QH+Af8AAgY2ABUBRgARABMAFAAVABYAFwAYABkAGgJzAnQCdQJ2AncCeAJ5AnoCewJ8ABIAAgYcADACWAJZAmQCWgJbAlwCXQJeAmkCYAJiAmMCZQJnAmgCYQJfAmYAegAGAewCawHtAe4B7wHwAfEB8gHzAfQA+gEnAGUABABiAGQAYQAFABEAEgATABQAFQAWABcAGAAZABoAAgYaAAIBRgHrAAEGGAAFABAAYgB4AKIAuAAIABIAGgAiACoAMgA6AEIASgCbAAMAEAATAQEAAwAQABQAngADABAAFQD9AAMAEAAZAJsAAwBjABMBAQADAGMAFACeAAMAYwAVAP0AAwBjABkAAgAGAA4BAgADABAAFAECAAMAYwAUAAQACgASABoAIgCjAAMAEAAVAP4AAwAQABkAowADAGMAFQD+AAMAYwAZAAIABgAOAP8AAwAQABkA/wADAGMAGQACAAYADgEAAAMAEAAZAQAAAwBjABkAAgVYABIAiwDtAcwA8gCPAPQA9QD2AgcCCAIJAgoCCwIMAg0CDgIPAhAAAQADAakBqgJHAAIAAQARABoAAAABAAEAEgABAAIAEABjAAEAAQATAAEAAQAVAAEAAQAUAAEAAQAZAAEAAQAWAAEAAQAYAAIABwAQABAAAABjAGMAAQCbAJsAAgCeAJ4AAwCjAKMABAD9AQIABQIHAhAACwACAAECEQIaAAAAAQABABAAAgAFAAUABQAAAAkACgABAA0ADwADABEAGgAGAGEAYQAQAAEAAQBCAAEAAQBQAAEAAQAPAAEAAQBVAAEAAQBJAAEAAQD2AAEAAQBUAAEAAQD1AAEAAQBFAAEAAQBPAAEAAQDyAAEAAQBTAAEAAQD0AAIAAgARABEAAAAVABoAAQABAIQAAgAHACAAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7AGAAewCKAIwAjQCOAJoAnQCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcBMAEyATQBRwFIAVABUgFUAVYBWAFaAVwBXgFgAWIBZAFmAWgBagFsAW4BcAFyAXQBdgF4AXoBfAF+AYABgQGDAYUBiAGKAYwBjgGQAZIBlAGXAZkBmwGdAZ8BoQGjAaUBpwGpAasBrQGvAbEBswG1AbcBuQG7Ab0BvwHBAcMBxgHIAcoAAQCSAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwCQAJEAkgCTAJQAogCnAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5AEtAS4BLwE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUsBTAFNAVEBUwFVAVcBWQFbAV0BXwFhAWMBZQFnAWkBawFtAW8BcQFzAXUBdwF5AXsBfQF/AYIBhAGGAYcBiQGLAY0BjwGRAZMBlQGYAZoBnAGeAaABogGkAaYBqAGqAawBrgGwAbIBtAG2AbgBugG8Ab4BwAHCAcQBxQHHAckBywABABYAQgBNAFoAkACSAMgAyQDKAMsAzADNAOIA4wFRAVMBVQGJAYsBjQGPAcABxwABABYAKABCAJAAyADJAMoAywDMAM0BUQFTAVUBbAFuAXABcgHHAisCLAItAi4ChAABAAoAKAFsAW4BcAFyAisCLAItAi4ChAABAAwAQgCQAMgAyQDKAMsAzADNAVEBUwFVAccAAQAGAE0AkgGJAYsBjQGPAAEABABaAOIA4wHAAAEAIAAoAEIATQBaAJAAkgDIAMkAygDLAMwAzQDiAOMBUQFTAVUBbAFuAXABcgGJAYsBjQGPAcABxwIrAiwCLQIuAoQAAQABAEcAAgAEAeoB6gAAAfUCBgABAnECcQATAnMCfAAUAAIACQAEAAYAAAARABoAAwBhAGIADQBkAGUADwB6AHoAEQD6APoAEgEnAScAEwHsAfQAFAJrAmsAHQACAAMAEQAaAAABRgFGAAoCcwJ8AAsAAgADAesB9AAAAfYB/wAKAmsCawAUAAEAMAAJAAoADgA8AD4AXABeAGAAYQBqAGsAbABvAHIAdAB4AHsAiQHqAfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAnECcwJ0AnUCdgJ3AngCeQJ6AnsCfAABAAIAEQHsAAEABQASABMAFAAWABgAAgAGAEIAQgAAAEUARQABAEkASQACAE8AUAAD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ADYANgAFADcANwAHADgAOAAIADkAOQAiADoAOgAJADsAOwAjAEEAQQAQAEcARwARAFUAVQASAFYAVgATAFcAVwAUAFgAWAAVAFoAWgAWAGgAaQAQAG0AbgARAHAAcAAOAHEAcQAPAHQAdAAdAHUAdgAkAHcAdwAQAHkAeQAkAIoAigAgAI0AjgAGAJkAmQAQAKUApQAQAKsAsAAgALEAsQAGALsAvwAGAMAAwAACAMEAxAAFAMUAxgAJAMcAxwAjAOIA4wAWASQBJAAgASkBKQARASsBLAARAS8BLwATATABMAAGATEBMQAXATIBMgAGATMBMwAXATQBNAAGATUBNQAXAUcBSAAGAUkBSgAXAU4BTwARAVABUAAgAVIBUgAgAVQBVAAgAVYBVgAGAVgBWAAGAVoBWgAGAVwBXAAGAWwBbAAGAW4BbgAGAXABcAAGAXIBcgAGAYMBgwABAZkBmQAGAZsBmwAGAZ0BnQAGAaUBpQACAacBpwACAakBqQACAasBqwADAawBrAASAa0BrQADAa4BrgASAa8BrwADAbABsAASAbMBswAFAbUBtQAFAbcBtwAFAbkBuQAFAbsBuwAFAbwBvAATAb0BvQAIAb8BvwAJAcABwAAWAcEBwQAjAcMBwwAjAcUBxQARAcYBxgAgAcgByAAGAcoBygACAegB6QARAhsCHgAfAh8CIgAXAisCLgAXAjYCNgAcAj8CQgAXAkoCTAAEAk0CUQAYAlMCUwAaAlQCVAAbAmQCZwANAmgCaAAMAm0CbQAXAn0CfQAeAn4CfgAfAoACgAAXAoQChAAXAocChwAcAowCjAAXAo4CjgAXApECkQAEApICkgAYApMCkwAZApQClAAaApUClQAhApYClgAbApoCoAAfAqECoQAXAqwCsQAXArICtQAYArYCtgAbArgCuAAbArkCuwARAAIAIQAnACcAAQAoACgAAwAsACwABgAtAC0ACACMAIwACAEwATAAAwExATEABAEyATIAAwEzATMABAE0ATQAAwE1ATUABAFHAUgAAwFsAWwAAwFuAW4AAwFwAXAAAwFyAXIAAwGFAYUABgGIAYgACAGKAYoACAIrAisABAItAi0ABAIwAjAABQIzAjQABQI3AjcABwI8Aj4ABQJXAlcABQKDAoMAAgKEAoQABAKFAoYABQKIAogABwKKAosABQKmAqkABQKrAqsABQACAJQAAwADAA8ABwAHAAQACAAIAA8ACwALACYADQANAAUADgAOAB0ADwAPAAUAIAAgAA4AIgAiAAIAJAAkABEAKAAoABEAKwArAAMAMAAwABEAMgAyABEANQA1AAEANgA2ACQANwA3AAsAOAA4AAwAOQA5AAoAOgA6AA0AQQBBAA8AQgBCABQARABGABUARwBHABYASABIABUAUABQABUAUgBSABUAVQBVABcAVgBWABgAVwBXABkAWABYABoAWQBZABsAWgBaABwAaABpAA8AbQBuABYAbwBvAB0AcABwACcAcQBxACgAcgByAB0AdAB0ACUAdQB2AAUAdwB3AA8AeQB5AAUAiQCJAB0AigCKAAIAjQCOABEAkACQABQAkwCUABUAmQCZAA8ApQClAA8ApwCnABUAqwCwAAIAsQCxABEAuwC/ABEAwQDEACQAxQDGAA0AzgDOABUA4gDjABwBJAEkAAIBKQEpABYBKwEsABYBLgEuABUBLwEvABgBMAEwABEBMQExAB4BMgEyABEBMwEzAB4BNAE0ABEBNQE1AB4BQgFCABUBRQFFABUBRwFIABEBSQFKAB4BSwFLABUBTgFPABYBUAFQAAIBUgFSAAIBVAFUAAIBVQFVABQBVgFWABEBWAFYABEBWgFaABEBXAFcABEBXwFfABUBaQFpABUBbAFsABEBbgFuABEBcAFwABEBcgFyABEBgwGDAAMBmQGZABEBmwGbABEBnQGdABEBqwGrAAEBrAGsABcBrQGtAAEBrgGuABcBrwGvAAEBsAGwABcBswGzACQBtQG1ACQBtwG3ACQBuQG5ACQBuwG7ACQBvAG8ABgBvQG9AAwBvwG/AA0BwAHAABwBxQHFABYBxgHGAAIBxwHHABQByAHIABEB6AHpABYCGwIeAAYCHwIiAB4CKwIuAB4CNgI2AAcCPwJCAB4CRgJJAB8CSgJMACACTQJRACECUwJTACMCVAJUABACZAJnABMCaAJoABICbQJtAB4CbgJuAB8CcgJyAAkCfgJ+AAYCgAKAAB4ChAKEAB4ChwKHAAcCjAKMAB4CjgKOAB4CkAKQAB8CkQKRACACkgKSACECkwKTACIClAKUACMClQKVAAgClgKWABACmgKgAAYCoQKhAB4CrAKxAB4CsgK1ACECtgK2ABACuAK4ABACuQK7ABYAAgAVADEAMQABADMAMwADADQANAAEADUANQAGAMAAwAAEAZ8BnwADAaEBoQADAaMBowADAaUBpQAEAacBpwAEAakBqQAEAasBqwAGAa0BrQAGAa8BrwAGAcoBygAEAkYCSQAFAkoCTAAHAm4CbgAFAo0CjQACApACkAAFApECkQAHAAIArgADAAMACAAHAAcAEAAIAAgACAALAAsAAQANAA0AEQAOAA4AFAAPAA8AEQAbABwAIAAiACIADQAkACQAAwAoACgAAwArACsADgAwADAAAwAyADIAAwA0ADQAHwA1ADUABAA3ADcABQA4ADgABgA5ADkADwA6ADoABwBBAEEACABCAEIAEgBEAEYAEwBHAEcAIgBIAEgAEwBOAE8AIwBQAFAAEwBRAFEAIwBSAFIAEwBTAFMAIwBUAFQAGQBVAFUAGgBWAFYAKQBXAFcAGwBYAFgAHABZAFkAHQBaAFoAHgBbAFsAIwBoAGkACABtAG4AIgBvAG8AFAByAHIAFAB1AHYAEQB3AHcACAB5AHkAEQCJAIkAFACKAIoADQCNAI4AAwCQAJAAEgCTAJQAEwCZAJkACAClAKUACACnAKcAEwCrALAADQCxALEAAwC7AL8AAwDAAMAAHwDFAMYABwDOAM4AEwDiAOMAHgEkASQADQEpASkAIgErASwAIgEuAS4AEwEvAS8AKQEwATAAAwExATEAAgEyATIAAwEzATMAAgE0ATQAAwE1ATUAAgFCAUIAEwFFAUUAEwFHAUgAAwFJAUoAAgFLAUsAEwFOAU8AIgFQAVAADQFSAVIADQFUAVQADQFVAVUAEgFWAVYAAwFYAVgAAwFaAVoAAwFcAVwAAwFfAV8AEwFpAWkAEwFsAWwAAwFuAW4AAwFwAXAAAwFyAXIAAwGDAYMADgGTAZMAIwGYAZgAIwGZAZkAAwGbAZsAAwGdAZ0AAwGiAaIAIwGlAaUAHwGnAacAHwGpAakAHwGqAaoAGQGrAasABAGsAawAGgGtAa0ABAGuAa4AGgGvAa8ABAGwAbAAGgG8AbwAKQG9Ab0ABgG/Ab8ABwHAAcAAHgHFAcUAIgHGAcYADQHHAccAEgHIAcgAAwHKAcoAHwHLAcsAGQHoAekAIgIbAh4AFQIfAiIAAgIjAiQAJAImAigAJAIqAioAJAIrAi4AAgIvAjAAJAIzAjQAJAI2AjYAFgI3AjoAJAI8Aj4AJAI/AkIAAgJDAkUAJAJGAkkAJQJKAkwACQJNAlEAJgJTAlMACwJUAlQADAJVAlYAKAJXAlcAJAJkAmcAIQJoAmgAGAJsAmwAJAJtAm0AAgJuAm4AJQJvAm8AKAJyAnIAFwJ+An4AFQJ/An8AJAKAAoAAAgKBAoMAJAKEAoQAAgKFAoYAJAKHAocAFgKIAosAJAKMAowAAgKNAo0AJAKOAo4AAgKPAo8AJAKQApAAJQKRApEACQKSApIAJgKTApMACgKUApQACwKVApUAJwKWApYADAKXApcAKAKaAqAAFQKhAqEAAgKiAqsAJAKsArEAAgKyArUAJgK2ArYADAK4ArgADAK5ArsAIgACAAwANwA3AAIAOAA4AAQAOgA6AAYAxQDGAAYBvwG/AAYCMgIyAAECTQJRAAEChwKHAAECkgKSAAECkwKTAAMClAKUAAUCsgK1AAEAAgCVAAcABwAJAA0ADQADAA4ADgAXAA8ADwADABsAHAAfACIAIgABACQAJAAIACgAKAAIACsAKwACADAAMAAIADIAMgAIADQANAAeADUANQAGADcANwAHAEIAQgAMAEQARgANAEcARwAOAEgASAANAE4ATwAPAFAAUAANAFEAUQAPAFIAUgANAFMAUwAPAFQAVAAQAFUAVQARAFYAVgASAFcAVwATAFgAWAAUAFkAWQAVAFoAWgAWAFsAWwAPAG0AbgAOAG8AbwAXAHIAcgAXAHUAdgADAHkAeQADAIkAiQAXAIoAigABAI0AjgAIAJAAkAAMAJMAlAANAKcApwANAKsAsAABALEAsQAIALsAvwAIAMAAwAAeAM4AzgANAOIA4wAWASQBJAABASkBKQAOASsBLAAOAS4BLgANAS8BLwASATABMAAIATEBMQAYATIBMgAIATMBMwAYATQBNAAIATUBNQAYAUIBQgANAUUBRQANAUcBSAAIAUkBSgAYAUsBSwANAU4BTwAOAVABUAABAVIBUgABAVQBVAABAVUBVQAMAVYBVgAIAVgBWAAIAVoBWgAIAVwBXAAIAV8BXwANAWkBaQANAWwBbAAIAW4BbgAIAXABcAAIAXIBcgAIAYMBgwACAZMBkwAPAZgBmAAPAZkBmQAIAZsBmwAIAZ0BnQAIAaIBogAPAaUBpQAeAacBpwAeAakBqQAeAaoBqgAQ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Al8CXwADApUClQANAAIAjgADAAMAFwAHAAcAIwAIAAgAFwANAA0AHgAOAA4AAwAPAA8AHgARABEAEAASABIADwAXABcAEAAYABgAEQAgACAAIAAiACIAGQAkACQAGgAoACgAGgArACsAHQAwADAAGgAyADIAGgA1ADUABQA2ADYACAA3ADcABgA4ADgABwA5ADkAHwA6ADoABABBAEEAFwBEAEYAAQBHAEcACgBIAEgAAQBLAEsAGABQAFAAAQBSAFIAAQBUAFQAHABVAFUACwBXAFcADABYAFgADQBaAFoADgBjAGMAJABoAGkAFwBtAG4ACgBvAG8AAwByAHIAAwB0AHQAAgB1AHYAHgB3AHcAFwB5AHkAHgCJAIkAAwCKAIoAGQCNAI4AGgCTAJQAAQCZAJkAFwClAKUAFwCnAKcAAQCrALAAGQCxALEAGgC7AL8AGgDBAMQACADFAMYABADOAM4AAQDiAOMADgEkASQAGQEpASkACgErASwACgEuAS4AAQEwATAAGgExATEACQEyATIAGgEzATMACQE0ATQAGgE1ATUACQFCAUIAAQFFAUUAAQFHAUgAGgFJAUoACQFLAUsAAQFOAU8ACgFQAVAAGQFSAVIAGQFUAVQAGQFWAVYAGgFYAVgAGgFaAVoAGgFcAVwAGgFfAV8AAQFpAWkAAQFsAWwAGgFuAW4AGgFwAXAAGgFyAXIAGgGDAYMAHQGEAYQAGAGZAZkAGgGbAZsAGgGdAZ0AGgGqAaoAHAGrAasABQGsAawACwGtAa0ABQGuAa4ACwGvAa8ABQGwAbAACwGzAbMACAG1AbUACAG3AbcACAG5AbkACAG7AbsACAG9Ab0ABwG/Ab8ABAHAAcAADgHFAcUACgHGAcYAGQHIAcgAGgHLAcsAHAHoAekACgIIAggAJgILAgsAJQIbAh4AGwIfAiIACQIrAi4ACQI/AkIACQJKAkwAEgJNAlEAFAJTAlMAFQJUAlQAFgJkAmcAIgJoAmgAIQJtAm0ACQJ+An4AGwKAAoAACQKEAoQACQKMAowACQKOAo4ACQKRApEAEgKSApIAFAKTApMAEwKUApQAFQKWApYAFgKaAqAAGwKhAqEACQKsArEACQKyArUAFAK2ArYAFgK4ArgAFgK5ArsACg=="

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = "data:font/opentype;base64,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A8gD1APgA+wD8gP4BAQEEAQWBBwEIAQkBCoEMAQ8BEgETgRUBF8EYgRlBGwEcwR5BH8EjASZBJ8EpQSxBL0EwwTJBM8E1QTgBOsE8wT7BQcFEwUZBR8FIwUnBS0FMwU6BUEFRwVNBVIFVwVkBXEFeAV/BYoFlQWgBasFsQW3BcEFywXQBdcF3gXpBfQGAAYMBhUGIAYkBisGMQY2Bj0GRgZPBlgGYQZsBnUGfgaFBo8GmAalBrEGvAbDBsoG1QbeBucG8Qb4BwEHBgcJBxkHIwcsBzQHPgdHB1AHWAdiB2wHdQeBB4sHlAedB6gHsge8B8UH0AfbB+UH9wgACAsIGggnCC8IOAhBCEkIUQhbCGQIbQh1CH8IiQiSCJsIowirCLUIvgjHCM8I2QjjCOwI9wkDCQ8JGwkmCTEJQQlQCVsJZglxCXwJiwmXCZ8Jqwm2CcYJ1wnmCfYJ/woKChEKHQopCjQKRApVCmAKawp8CoUKkAqbCqwKtwrJCtUK5QrwCvsLDAsXCyQLNAtFC04LWQtqC3ULhwuTC58LqQu0C8QL1AvfC+4L/QwLDBoMKgw7DEkMWAxnDHgMigydDK8MwgzNDNgM4wz2DQENCg0VDR0NKA0vDToNRQ1QDVsNaQ1yDXoNgg2MDZUNng2mDbANug3DDdAN1g3cDeIN6A3uDfQN+g4ADgYODA4SDhgOHg4kDioOMA42DjwOQg5IDk4OVA5aDmAOZg5sDnsOjA6XDqIOsg69DssO1Q7cDukO9A7/Dw8PHQ8oDzMPQw9RD1kPZA9vD3oPig+VD6MPrg+5D8QP1A/iD+0P9xAFEAgQDRASEEkQXRBsbm90ZXF1YWxpbmZpbml0eWxlc3NlcXVhbGdyZWF0ZXJlcXVhbHBhcnRpYWxkaWZmc3VtbWF0aW9ucHJvZHVjdHBpaW50ZWdyYWxPbWVnYXJhZGljYWxhcHByb3hlcXVhbERlbHRhbmJzcGFjZWxvemVuZ2VFdXJvdW5pMjMxOGYuYWx0MWZfYmZfaGZfa2wuYWx0MWEuYWx0MXkuYWx0MUcuYWx0MUcuc21jcC5hbHQxR2JyZXZlLmFsdDFHYnJldmUuc21jcC5hbHQxR2NvbW1hYWNjZW50LmFsdDFHY29tbWFhY2NlbnQuc21jcC5hbHQxbHNsYXNoLmFsdDFsYWN1dGUuYWx0MWxjb21tYWFjY2VudC5hbHQxbGNhcm9uLmFsdDFhYWN1dGUuYWx0MWFncmF2ZS5hbHQxYWNpcmN1bWZsZXguYWx0MWFkaWVyZXNpcy5hbHQxYXRpbGRlLmFsdDFhcmluZy5hbHQxYW1hY3Jvbi5hbHQxYWJyZXZlLmFsdDFhb2dvbmVrLmFsdDF5YWN1dGUuYWx0MXlkaWVyZXNpcy5hbHQxYWUuYWx0MXplcm8ucHplcm9HY2lyY3VtZmxleC5hbHQxR2RvdGFjY2VudC5hbHQxR2NpcmN1bWZsZXguc21jcC5hbHQxR2RvdGFjY2VudC5zbWNwLmFsdDFhZWFjdXRlLmFsdDF5Y2lyY3VtZmxleC5hbHQxbGRvdC5hbHQxZmwuYWx0MWZfZl9sLmFsdDFBbWFjcm9uYW1hY3JvbkFicmV2ZWFicmV2ZUFvZ29uZWthb2dvbmVrQ2FjdXRlY2FjdXRlQ2NpcmN1bWZsZXhjY2lyY3VtZmxleENkb3RhY2NlbnRjZG90YWNjZW50Q2Nhcm9uY2Nhcm9uRGNhcm9uZGNhcm9uRGNyb2F0ZGNyb2F0RW1hY3JvbmVtYWNyb25FYnJldmVlYnJldmVFZG90YWNjZW50ZWRvdGFjY2VudEVvZ29uZWtlb2dvbmVrRWNhcm9uZWNhcm9uR2NpcmN1bWZsZXhnY2lyY3VtZmxleEdicmV2ZWdicmV2ZUdkb3RhY2NlbnRnZG90YWNjZW50R2NvbW1hYWNjZW50Z2NvbW1hYWNjZW50SGNpcmN1bWZsZXhoY2lyY3VtZmxleEhiYXJoYmFySXRpbGRlaXRpbGRlSW1hY3JvbmltYWNyb25JYnJldmVpYnJldmVJb2dvbmVraW9nb25la0lkb3RhY2NlbnRJSmlqSmNpcmN1bWZsZXhqY2lyY3VtZmxleEtjb21tYWFjY2VudGtjb21tYWFjY2VudGtncmVlbmxhbmRpY0xhY3V0ZWxhY3V0ZUxjb21tYWFjY2VudGxjb21tYWFjY2VudExjYXJvbmxjYXJvbkxkb3RsZG90TmFjdXRlbmFjdXRlTmNvbW1hYWNjZW50bmNvbW1hYWNjZW50TmNhcm9ubmNhcm9ubmFwb3N0cm9waGVFbmdlbmdPbWFjcm9ub21hY3Jvbk9icmV2ZW9icmV2ZU9odW5nYXJ1bWxhdXRvaHVuZ2FydW1sYXV0UmFjdXRlcmFjdXRlUmNvbW1hYWNjZW50cmNvbW1hYWNjZW50UmNhcm9ucmNhcm9uU2FjdXRlc2FjdXRlU2NpcmN1bWZsZXhzY2lyY3VtZmxleFNjZWRpbGxhc2NlZGlsbGFUY29tbWFhY2NlbnR0Y29tbWFhY2NlbnRUY2Fyb250Y2Fyb25UYmFydGJhclV0aWxkZXV0aWxkZVVtYWNyb251bWFjcm9uVWJyZXZldWJyZXZlVXJpbmd1cmluZ1VodW5nYXJ1bWxhdXR1aHVuZ2FydW1sYXV0VW9nb25la3VvZ29uZWtXY2lyY3VtZmxleHdjaXJjdW1mbGV4WWNpcmN1bWZsZXh5Y2lyY3VtZmxleFphY3V0ZXphY3V0ZVpkb3RhY2NlbnR6ZG90YWNjZW50bG9uZ3NBRWFjdXRlYWVhY3V0ZU9zbGFzaGFjdXRlb3NsYXNoYWN1dGVTY29tbWFhY2NlbnRzY29tbWFhY2NlbnRoc3VwZXJpb3JmcmVuY2hmcmFuY2xpcmF1bmkyMEE2cGVzZXRhcnVwZWV1bmkyMEE5YWZpaTU3NjM2YWZpaTYxMjg5YWZpaTYxMzUycHVibGlzaGVkc2VydmljZW1hcmtlc3RpbWF0ZWRhcnJvd2xlZnRhcnJvd3VwYXJyb3dyaWdodGFycm93ZG93bnRyaWFuZ2xlcmlnaHR0cmlhbmdsZWxlZnRibGFja3NxdWFyZXRyaWFndXB0cmlhZ2RuY2lyY2xlc29saWRibGFja3N0YXJiYWxsb3Rib3hib3hjaGVja2VkZGlhbW9uZGNoZWNrbWFya2ZfZl9qZl9qcGVydGhvdXNhbmQub251bXplcm8udHplcm96ZXJvLnRudW10d28udG51bXRocmVlLnRudW1mb3VyLnRudW1maXZlLnRudW1zaXgudG51bXNldmVuLnRudW1laWdodC50bnVtbmluZS50bnVtcGVyY2VudC5vbnVtemVyby50b251bW9uZS50b251bXR3by50b251bXRocmVlLnRvbnVtZm91ci50b251bWZpdmUudG9udW1zaXgudG9udW1zZXZlbi50b251bWVpZ2h0LnRvbnVtbmluZS50b251bWNvbG9ubW9uZXRhcnkub251bUV1cm8ub251bWZsb3Jpbi5vbnVtbnVtYmVyc2lnbi5vbnVtc3Rlcmxpbmcub251bXllbi5vbnVtY2VudC5vbnVtemVyby5kbm9tb25lLmRub210d28uZG5vbXRocmVlLmRub21mb3VyLmRub21maXZlLmRub21zaXguZG5vbXNldmVuLmRub21laWdodC5kbm9tbmluZS5kbm9temVyby5udW1yb25lLm51bXJ0d28ubnVtcnRocmVlLm51bXJmb3VyLm51bXJmaXZlLm51bXJzaXgubnVtcnNldmVuLm51bXJlaWdodC5udW1ybmluZS5udW1yQWJyZXZlLnNtY3BBbWFjcm9uLnNtY3BBb2dvbmVrLnNtY3BBRWFjdXRlLnNtY3BDYWN1dGUuc21jcENjYXJvbi5zbWNwQ2NpcmN1bWZsZXguc21jcENkb3RhY2NlbnQuc21jcERjYXJvbi5zbWNwRGNyb2F0LnNtY3BFYnJldmUuc21jcEVjYXJvbi5zbWNwRWRvdGFjY2VudC5zbWNwRW1hY3Jvbi5zbWNwRW5nLnNtY3BFb2dvbmVrLnNtY3BHYnJldmUuc21jcEdjaXJjdW1mbGV4LnNtY3BHY29tbWFhY2NlbnQuc21jcEdkb3RhY2NlbnQuc21jcEhjaXJjdW1mbGV4LnNtY3BIYmFyLnNtY3BJYnJldmUuc21jcElKLnNtY3BJbWFjcm9uLnNtY3BJb2dvbmVrLnNtY3BJdGlsZGUuc21jcEpjaXJjdW1mbGV4LnNtY3BLY29tbWFhY2NlbnQuc21jcExhY3V0ZS5zbWNwTGNhcm9uLnNtY3BMY29tbWFhY2NlbnQuc21jcExkb3Quc21jcE5hY3V0ZS5zbWNwTmNhcm9uLnNtY3BOY29tbWFhY2NlbnQuc21jcE9icmV2ZS5zbWNwT2h1bmdhcnVtbGF1dC5zbWNwT21hY3Jvbi5zbWNwT3NsYXNoYWN1dGUuc21jcFJhY3V0ZS5zbWNwUmNhcm9uLnNtY3BSY29tbWFhY2NlbnQuc21jcFNhY3V0ZS5zbWNwU2NlZGlsbGEuc21jcFNjaXJjdW1mbGV4LnNtY3BTY29tbWFhY2NlbnQuc21jcFRiYXIuc21jcFRjYXJvbi5zbWNwVGNvbW1hYWNjZW50LnNtY3BVYnJldmUuc21jcFVodW5nYXJ1bWxhdXQuc21jcFVtYWNyb24uc21jcFVvZ29uZWsuc21jcFVyaW5nLnNtY3BVdGlsZGUuc21jcFdjaXJjdW1mbGV4LnNtY3BZY2lyY3VtZmxleC5zbWNwWmFjdXRlLnNtY3BaZG90YWNjZW50LnNtY3BJZG90YWNjZW50LnNtY3BwYXJlbmxlZnQuY2FzZXBhcmVucmlnaHQuY2FzZWJyYWNrZXRsZWZ0LmNhc2VicmFja2V0cmlnaHQuY2FzZWJyYWNlbGVmdC5jYXNlYnJhY2VyaWdodC5jYXNlZXhjbGFtZG93bi5jYXNlcXVlc3Rpb25kb3duLmNhc2VndWlsbGVtb3RsZWZ0LmNhc2VndWlsbGVtb3RyaWdodC5jYXNlZ3VpbHNpbmdsbGVmdC5jYXNlZ3VpbHNpbmdscmlnaHQuY2FzZWh5cGhlbi5jYXNlZW5kYXNoLmNhc2VlbWRhc2guY2FzZXBlcmlvZGNlbnRlcmVkLmNhc2VidWxsZXQuY2FzZWNlbnQuY2FzZWNvbW1hYWNjZW50b25lLnRudW1Mc2xhc2guc21jcE9FLnNtY3BTY2Fyb24uc21jcFpjYXJvbi5zbWNwZXhjbGFtLnNtY3Bkb2xsYXIub251bWFtcGVyc2FuZC5zbWNwemVyby5vbnVtb25lLm9udW10d28ub251bXRocmVlLm9udW1mb3VyLm9udW1maXZlLm9udW1zaXgub251bXNldmVuLm9udW1laWdodC5vbnVtbmluZS5vbnVtcXVlc3Rpb24uc21jcEEuc21jcEIuc21jcEMuc21jcEQuc21jcEUuc21jcEYuc21jcEcuc21jcEguc21jcEkuc21jcEouc21jcEsuc21jcEwuc21jcE0uc21jcE4uc21jcE8uc21jcFAuc21jcFEuc21jcFIuc21jcFMuc21jcFQuc21jcFUuc21jcFYuc21jcFcuc21jcFguc21jcFkuc21jcFouc21jcGV4Y2xhbWRvd24uc21jcHF1ZXN0aW9uZG93bi5zbWNwQWdyYXZlLnNtY3BBYWN1dGUuc21jcEFjaXJjdW1mbGV4LnNtY3BBdGlsZGUuc21jcEFkaWVyZXNpcy5zbWNwQXJpbmcuc21jcEFFLnNtY3BDY2VkaWxsYS5zbWNwRWdyYXZlLnNtY3BFYWN1dGUuc21jcEVjaXJjdW1mbGV4LnNtY3BFZGllcmVzaXMuc21jcEln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Aj8ALwIzAC8BHAAQAj8ALwIoAEwA4QA+AOH/ngICAEsA4QBLAygASwIoAEsCPAAvAjwASwI8ACwBSgBLAdEAIgEmAAoCJwBLAeoAAwLeAAwB5wAMAeoAAwHYADQBBQAFANMATgEFABEB9wAbAOYAPAHwAC8CBgAUAIv/VQJyAAkBsAAZAdQAIgIKACQAxwA2AYYANgG3AB4BJwAeAScAHgH9ABAB/QAQAlEAHgEHABcBBwAXAOcAPAHBABsBZgBIAOYAOQGGADkBhgA5AbcAHgKzADwEPAAfAYoAHwDiAAAA4gAAAQkAAAE5AAABawAAAV8AAABwAAkBEP/yAMQAAADNAAABMQAAALIAAAEJAAADQQAeA7QABwF6ACkCDAAKAv0AMwRRADMBlQAoA3kAMQDhAEsBHwAKAjwALwPCAC8CVQBMAOsADgH4AB0CJwBLAcYAEQLYAAoDJwAOAfMAHQJLAE4DAgAOAf8AHQDTAE4BIgAXAjwASwNuACoBhAAxAe4AIwHzAB0CPAAvAfMAQAGEACoDCgAsApIACQKSAAkCkgAJApIACQKSAAkCkgAJAqQAMwI5AE4COQBOAjkATgI5AE4A7wA3AO//8wDv/+EA7//XAsQATgL9ADMC/QAzAv0AMwL9ADMC/QAzAkoAJgK9AE4CvQBOAr0ATgK9AE4CcgAJAnIACQJJADACEAAxAhAAMQIQADECEAAxAhAAMQIQADEB8AAvAjMALwIzAC8CMwAvAjMALwDhAC8A4f/tAOH/2wDh/9ACKABOAjwALwI8AC8CPAAvAjwALwI8AC8B0QAiAicASwInAEsCJwBLAicASwHqAAMB6gADAdgANAFyABkAoQAaAKEAFwCLABwAjwAiAXoAKQGaADwBMwAcAZoAKAGOACgAogAsALIAPAI7ADwBjgA8AZUAKADwADwBSgAcAM4ACQChABoAoQAXALgAEgKpADcEZgBOALgAEgMnAA4DkwAqA5AALAM+ACEDJwAOA5MAMQGEACEBhAAnAYQALAGEACYBagAhAYQAKQGEACYBhAAhAOsADgGEADEBhAAqAYQAJwGEACwBhAAmAWoAIQGEACkBhAAmATMAHAFyABkAjwAiAIsAHAHzAB0CkAAdAfMAHQHzABwCPAAvAkAANgLEACACMQAgAVwAEQL9ADMC1QBCAfMAHQKSAAkBAwAAAXcAEwK3AB8CmwAqARwAEANbABADRAAQAx4AEAENAEsCPwAvAicARgLJADMCgwAvAuYAMwKAAC8C5gAzAoMALwErAAoBDQAvAQ0ASwEoAEsCPwAvAj8ALwI/AC8CPwAvAj8ALwI/AC8CPwAvAj8ALwI/AC8CJwBGAicARgOoAC8CZAAzAuYAMwLmADMCcgAvAnIALwN5AC8CJwBGATMASwIoABADRAAQApIACQIQADECkgAJAhAAMQKSAAkCEAAxAqQAMwHwAC8CpAAzAfAALwKkADMB8AAvAqQAMwHwAC8CvABOAoQALwLYAAoCQwAvAjkATgIzAC8COQBOAjMALwI5AE4CMwAvAjkATgIzAC8COQBOAjMALwLJADMCPwAvAskAMwI/AC8CyQAzAj8ALwLJADMCPwAvAsgATgIo/+4C2wAKAisACgDv/9sA4f/UAO//wgDh/7wA7//KAOH/wgDvACgA4QAdAO8ASQLKAE4BwwA+AdsACwDh/54CXgBOAgIASwICAEsB7QBDAOEALwHtAEMA4QBDAe0AQwEjAEsCAABDATMASwLEAE4CKABOAsQATgIoAE4CxABOAigATgIoADoCxABOAigASwL9ADMCPAAvAv0AMwI8AC8C/QAzAjwALwJhAE4BSgBLAmEATgFKAEsCYQBOAUoAOwJKACYB0QAiAkoAJgHRACICSgAmAdEAIgI6ACABJgAKAjoAIAE5AAoCOgAgASYACgK9AE4CJwBLAr0ATgInAEsCvQBOAicASwK9AE4CJwBLAr0ATgInAEsCvQBOAicASwNzAA4C3gAMAnIACQHqAAMCSQAwAdgANAJJADAB2AA0ARwAEAO0AAcDeQAxAv0AMwI8AC8CUQArAdQAIgGOADwCMQAKAgYAFALZAAoCgAAKA/sATgNzAA4DNQBLAdsATARZAE4DCgAsAdwADwNKAB8CRgAAAkYAVgJGAC8CRgBXAksANgJLAAAClQAvAmj//gJo//4CtwAyAvcAAAKVAC0ClQAtAfUAAAITAAADGAAQAf0AEANuABoCZAAzAlYALAJWAEQCVgA9AlYAMwJWAEYCVgA6AlYASAJWADwCVgAyAlAAGgJWACwCVgCcAlYAQAJWAD0CVgAzAlYARgJWADoCVgBIAlYAPAJWADICRgAvAmIAHwFvABcB8AAWAakADgIjAAcCRgAvAYQAIQDrAA4BhAAxAYQAKgGEACcBhAAsAYQAJgFqACEBhAApAYQAJgGEACEA6wAOAYQAMQGEACoBhAAnAYQALAGEACYBagAhAYQAKQGEACYCPAAHAjwABwI8AAcDNQAGAkYALwJGAC8CRgAvAkYALwJnAD8CcgAKAf0ASwH9AEsB/QBLAf0ASwJ4AEsB/QBLAnIALwJyAC8CcgAvAnIALwJ7AEsCjwAKAOP/vwKLAEsA4/+9AOMAIADj/9YBpgAIAhYASwHKAEsBygBLAcoASwHYAEsCeABLAngASwJ4AEsClgAvApYALwKWAC8ClgAvAiEASwIhAEsCIQBLAfgAIAH4ACAB+AAgAfgAIAHYABoB2AAaAdgAGgJvAEsCbwBLAm8ASwJvAEsCbwBLAm8ASwL8AAoCIwAHAgQAKAIEACgAygA3APgALAD4ABEA8wAoAPMAEQEFAAUBBQARAOYAPAHOAB8BtwAeAbcAHgEnAB4BJwAeASwAHgJRAB4DQQAeAOcAPAFmAEgB8AAvAOYAQAJWAJwB4QAKA7kALwH4ACACBAAoALgAJQH4ACACLAAbAmQAMwFTABUCQgAtAikAGQIuACACTgBCAk8AMwIDAB8CRgA0Ak8AMQGMAAoCPAAHAioASwJGAC8CZwBLAf0ASwHrAEsCcgAvAnsASwDlAEsBpgAIAhYASwHKAEsCzwBLAngASwKWAC8CCwBLApYALwIhAEsB+AAgAdgAGgJvAEsCPAAHAvwACgI3AAkCIwAHAgQAKAC4ACUBjAAXAjwABwI8AAcCPAAHAjwABwI8AAcCPAAHAzUABgJGAC8B/QBLAf0ASwH9AEsB/QBLAOP/0gDjADEA4//uAOP/3QJyAAoCeABLApYALwKWAC8ClgAvApYALwKWAC8ClgAvAm8ASwJvAEsCbwBLAm8ASwIjAAcCCwBLAiMABwI3ABADGAAQABAAAAABAAAACgBmAZwAAWxhdG4ACAAQAAJNT0wgAERST00gAEwAAP//ABcAAAABAAIAAwAEAAUACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYAAD//wABAAYAAP//AAEABwAZYzJzYwCYY2FzZQCeZG5vbQCkZnJhYwCqbGlnYQC4bG51bQC+bG9jbADEbG9jbADKbnVtcgDQb251bQDWb3JkbgDccG51bQDi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AI0AjgAGAJkAmQAQAKUApQAQAKsAsAAgALEAsQAGALsAvwAGAMAAwAACAMEAxAAFAMUAxgAJAMcAxwAjAOIA4wAWASQBJAAgASkBKQARASsBLAARAS8BLwATATABMAAGATEBMQAXATIBMgAGATMBMwAXATQBNAAGATUBNQAXAUcBSAAGAUkBSgAXAU4BTwARAVABUAAgAVIBUgAgAVQBVAAgAVYBVgAGAVgBWAAGAVoBWgAGAVwBXAAGAWwBbAAGAW4BbgAGAXABcAAGAXIBcgAGAYMBgwABAZkBmQAGAZsBmwAGAZ0BnQAGAaUBpQACAacBpwACAakBqQACAasBqwADAawBrAASAa0BrQADAa4BrgASAa8BrwADAbABsAASAbMBswAFAbUBtQAFAbcBtwAFAbkBuQAFAbsBuwAFAbwBvAATAb0BvQAIAb8BvwAJAcABwAAWAcEBwQAjAcMBwwAjAcUBxQARAcYBxgAgAcgByAAGAcoBygACAegB6QARAhsCHgAfAh8CIgAXAisCLgAXAjYCNgAcAj8CQgAXAkoCTAAEAk0CUQAYAlMCUwAaAlQCVAAbAmQCZwANAmgCaAAMAm0CbQAXAn0CfQAeAn4CfgAfAoACgAAXAoQChAAXAocChwAcAowCjAAXAo4CjgAXApECkQAEApICkgAYApMCkwAZApQClAAaApUClQAhApYClgAbApoCoAAfAqECoQAXAqwCsQAXArICtQAYArYCtgAbArgCuAAbArkCuwARAAIAIQAnACcAAQAoACgAAwAsACwABgAtAC0ACACMAIwACAEwATAAAwExATEABAEyATIAAwEzATMABAE0ATQAAwE1ATUABAFHAUgAAwFsAWwAAwFuAW4AAwFwAXAAAwFyAXIAAwGFAYUABgGIAYgACAGKAYoACAIrAisABAItAi0ABAIwAjAABQIzAjQABQI3AjcABwI8Aj4ABQJXAlcABQKDAoMAAgKEAoQABAKFAoYABQKIAogABwKKAosABQKmAqkABQKrAqsABQACAJQAAwADAA8ABwAHAAQACAAIAA8ACwALACYADQANAAUADgAOAB0ADwAPAAUAIAAgAA4AIgAiAAIAJAAkABEAKAAoABEAKwArAAMAMAAwABEAMgAyABEANQA1AAEANgA2ACQANwA3AAsAOAA4AAwAOQA5AAoAOgA6AA0AQQBBAA8AQgBCABQARABGABUARwBHABYASABIABUAUABQABUAUgBSABUAVQBVABcAVgBWABgAVwBXABkAWABYABoAWQBZABsAWgBaABwAaABpAA8AbQBuABYAbwBvAB0AcABwACcAcQBxACgAcgByAB0AdAB0ACUAdQB2AAUAdwB3AA8AeQB5AAUAiQCJAB0AigCKAAIAjQCOABEAkACQABQAkwCUABUAmQCZAA8ApQClAA8ApwCnABUAqwCwAAIAsQCxABEAuwC/ABEAwQDEACQAxQDGAA0AzgDOABUA4gDjABwBJAEkAAIBKQEpABYBKwEsABYBLgEuABUBLwEvABgBMAEwABEBMQExAB4BMgEyABEBMwEzAB4BNAE0ABEBNQE1AB4BQgFCABUBRQFFABUBRwFIABEBSQFKAB4BSwFLABUBTgFPABYBUAFQAAIBUgFSAAIBVAFUAAIBVQFVABQBVgFWABEBWAFYABEBWgFaABEBXAFcABEBXwFfABUBaQFpABUBbAFsABEBbgFuABEBcAFwABEBcgFyABEBgwGDAAMBmQGZABEBmwGbABEBnQGdABEBqwGrAAEBrAGsABcBrQGtAAEBrgGuABcBrwGvAAEBsAGwABcBswGzACQBtQG1ACQBtwG3ACQBuQG5ACQBuwG7ACQBvAG8ABgBvQG9AAwBvwG/AA0BwAHAABwBxQHFABYBxgHGAAIBxwHHABQByAHIABEB6AHpABYCGwIeAAYCHwIiAB4CKwIuAB4CNgI2AAcCPwJCAB4CRgJJAB8CSgJMACACTQJRACECUwJTACMCVAJUABACZAJnABMCaAJoABICbQJtAB4CbgJuAB8CcgJyAAkCfgJ+AAYCgAKAAB4ChAKEAB4ChwKHAAcCjAKMAB4CjgKOAB4CkAKQAB8CkQKRACACkgKSACECkwKTACIClAKUACMClQKVAAgClgKWABACmgKgAAYCoQKhAB4CrAKxAB4CsgK1ACECtgK2ABACuAK4ABACuQK7ABYAAgAeACsAKwAIADEAMQABADMAMwADADQANAAEADUANQAGADYANgAIAMAAwAAEAMEAxAAIAYEBgQAIAZ8BnwADAaEBoQADAaMBowADAaUBpQAEAacBpwAEAakBqQAEAasBqwAGAa0BrQAGAa8BrwAGAbMBswAIAbUBtQAIAbcBtwAI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ACAAIAAiACIAGQAkACQAGgAoACgAGgArACsAHQAwADAAGgAyADIAGgA1ADUABQA2ADYACAA3ADcABgA4ADgABwA5ADkAHwA6ADoABABBAEEAFwBEAEYAAQBHAEcACgBIAEgAAQBLAEsAGABQAFAAAQBSAFIAAQBUAFQAHABVAFUACwBXAFcADABYAFgADQBaAFoADgBjAGMAJABoAGkAFwBtAG4ACgBvAG8AAwByAHIAAwB0AHQAAgB1AHYAHgB3AHcAFwB5AHkAHgCJAIkAAwCKAIoAGQCNAI4AGgCTAJQAAQCZAJkAFwClAKUAFwCnAKcAAQCrALAAGQCxALEAGgC7AL8AGgDBAMQACADFAMYABADOAM4AAQDiAOMADgEkASQAGQEpASkACgErASwACgEuAS4AAQEwATAAGgExATEACQEyATIAGgEzATMACQE0ATQAGgE1ATUACQFCAUIAAQFFAUUAAQFHAUgAGgFJAUoACQFLAUsAAQFOAU8ACgFQAVAAGQFSAVIAGQFUAVQAGQFWAVYAGgFYAVgAGgFaAVoAGgFcAVwAGgFfAV8AAQFpAWkAAQFsAWwAGgFuAW4AGgFwAXAAGgFyAXIAGgGDAYMAHQGEAYQAGAGZAZkAGgGbAZsAGgGdAZ0AGgGqAaoAHAGrAasABQGsAawACwGtAa0ABQGuAa4ACwGvAa8ABQGwAbAACwGzAbMACAG1AbUACAG3AbcACAG5AbkACAG7AbsACAG9Ab0ABwG/Ab8ABAHAAcAADgHFAcUACgHGAcYAGQHIAcgAGgHLAcsAHAHoAekACgIIAggAJgILAgsAJQIbAh4AGwIfAiIACQIrAi4ACQI/AkIACQJKAkwAEgJNAlEAFAJTAlMAFQJUAlQAFgJkAmcAIgJoAmgAIQJtAm0ACQJ+An4AGwKAAoAACQKEAoQACQKMAowACQKOAo4ACQKRApEAEgKSApIAFAKTApMAEwKUApQAFQKWApYAFgKaAqAAGwKhAqEACQKsArEACQKyArUAFAK2ArYAFgK4ArgAFgK5ArsACgAA"

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	module.exports = "data:font/opentype;base64,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fAODA4oDkAOWA50DpAOuA7ADsgO9A8gD1APgA+wD8gP4BAQEEAQWBBwEIAQkBCoEMAQ8BEgETgRUBF8EYgRlBGwEcwR5BH8EjASZBJ8EpQSxBL0EwwTJBM8E1QTgBOsE8wT7BQcFEwUZBR8FIwUnBS0FMwU6BUEFRwVNBVIFVwVkBXEFeAV/BYoFlQWgBasFsQW3BcEFywXQBdcF3gXpBfQGAAYMBhUGIAYkBisGMQY2Bj0GRgZPBlgGYQZsBnUGfgaFBo8GmAalBrEGvAbDBsoG1QbeBucG8Qb4BwEHBgcJBxkHIwcsBzQHPgdHB1AHWAdiB2wHdQeBB4sHlAedB6gHsge8B8UH0AfbB+UH9wgACAsIGggnCC8IOAhBCEkIUQhbCGQIbQh1CH8IiQiSCJsIowirCLUIvgjHCM8I2QjjCOwI9wkDCQ8JGwkmCTEJQQlQCVsJZglxCXwJiwmXCZ8Jqwm2CcYJ1wnmCfYJ/woKChEKHQopCjQKRApVCmAKawp8CoUKkAqbCqwKtwrJCtUK5QrwCvsLDAsXCyQLNAtFC04LWQtqC3ULhwuTC58LqQu0C8QL1AvfC+4L/QwLDBoMKgw7DEkMWAxnDHgMigydDK8MwgzNDNgM4wz2DQENCg0VDR0NKA0vDToNRQ1QDVsNaQ1yDXoNgg2MDZUNng2mDbANug3DDdAN1g3cDeIN6A3uDfQN+g4ADgYODA4SDhgOHg4kDioOMA42DjwOQg5IDk4OVA5aDmAOZg5sDnsOjA6XDqIOsg69DssO1Q7cDukO9A7/Dw8PHQ8oDzMPQw9RD1kPZA9vD3oPig+VD6MPrg+5D8QP1A/iD+0P9xAFEAgQDRASEEkQXhBtEHVub3RlcXVhbGluZmluaXR5bGVzc2VxdWFsZ3JlYXRlcmVxdWFscGFydGlhbGRpZmZzdW1tYXRpb25wcm9kdWN0cGlpbnRlZ3JhbE9tZWdhcmFkaWNhbGFwcHJveGVxdWFsRGVsdGFuYnNwYWNlbG96ZW5nZUV1cm91bmkyMzE4Zi5hbHQxZl9iZl9oZl9rbC5hbHQxYS5hbHQxeS5hbHQxRy5hbHQxRy5zbWNwLmFsdDFHYnJldmUuYWx0MUdicmV2ZS5zbWNwLmFsdDFHY29tbWFhY2NlbnQuYWx0MUdjb21tYWFjY2VudC5zbWNwLmFsdDFsc2xhc2guYWx0MWxhY3V0ZS5hbHQxbGNvbW1hYWNjZW50LmFsdDFsY2Fyb24uYWx0MWFhY3V0ZS5hbHQxYWdyYXZlLmFsdDFhY2lyY3VtZmxleC5hbHQxYWRpZXJlc2lzLmFsdDFhdGlsZGUuYWx0MWFyaW5nLmFsdDFhbWFjcm9uLmFsdDFhYnJldmUuYWx0MWFvZ29uZWsuYWx0MXlhY3V0ZS5hbHQxeWRpZXJlc2lzLmFsdDFhZS5hbHQxemVyby5wemVyb0djaXJjdW1mbGV4LmFsdDFHZG90YWNjZW50LmFsdDFHY2lyY3VtZmxleC5zbWNwLmFsdDFHZG90YWNjZW50LnNtY3AuYWx0MWFlYWN1dGUuYWx0MXljaXJjdW1mbGV4LmFsdDFsZG90LmFsdDFmbC5hbHQxZl9mX2wuYWx0MUFtYWNyb25hbWFjcm9uQWJyZXZlYWJyZXZlQW9nb25la2FvZ29uZWtDYWN1dGVjYWN1dGVDY2lyY3VtZmxleGNjaXJjdW1mbGV4Q2RvdGFjY2VudGNkb3RhY2NlbnRDY2Fyb25jY2Fyb25EY2Fyb25kY2Fyb25EY3JvYXRkY3JvYXRFbWFjcm9uZW1hY3JvbkVicmV2ZWVicmV2ZUVkb3RhY2NlbnRlZG90YWNjZW50RW9nb25la2VvZ29uZWtFY2Fyb25lY2Fyb25HY2lyY3VtZmxleGdjaXJjdW1mbGV4R2JyZXZlZ2JyZXZlR2RvdGFjY2VudGdkb3RhY2NlbnRHY29tbWFhY2NlbnRnY29tbWFhY2NlbnRIY2lyY3VtZmxleGhjaXJjdW1mbGV4SGJhcmhiYXJJdGlsZGVpdGlsZGVJbWFjcm9uaW1hY3JvbklicmV2ZWlicmV2ZUlvZ29uZWtpb2dvbmVrSWRvdGFjY2VudElKaWpKY2lyY3VtZmxleGpjaXJjdW1mbGV4S2NvbW1hYWNjZW50a2NvbW1hYWNjZW50a2dyZWVubGFuZGljTGFjdXRlbGFjdXRlTGNvbW1hYWNjZW50bGNvbW1hYWNjZW50TGNhcm9ubGNhcm9uTGRvdGxkb3ROYWN1dGVuYWN1dGVOY29tbWFhY2NlbnRuY29tbWFhY2NlbnROY2Fyb25uY2Fyb25uYXBvc3Ryb3BoZUVuZ2VuZ09tYWNyb25vbWFjcm9uT2JyZXZlb2JyZXZlT2h1bmdhcnVtbGF1dG9odW5nYXJ1bWxhdXRSYWN1dGVyYWN1dGVSY29tbWFhY2NlbnRyY29tbWFhY2NlbnRSY2Fyb25yY2Fyb25TYWN1dGVzYWN1dGVTY2lyY3VtZmxleHNjaXJjdW1mbGV4U2NlZGlsbGFzY2VkaWxsYVRjb21tYWFjY2VudHRjb21tYWFjY2VudFRjYXJvbnRjYXJvblRiYXJ0YmFyVXRpbGRldXRpbGRlVW1hY3JvbnVtYWNyb25VYnJldmV1YnJldmVVcmluZ3VyaW5nVWh1bmdhcnVtbGF1dHVodW5nYXJ1bWxhdXRVb2dvbmVrdW9nb25la1djaXJjdW1mbGV4d2NpcmN1bWZsZXhZY2lyY3VtZmxleHljaXJjdW1mbGV4WmFjdXRlemFjdXRlWmRvdGFjY2VudHpkb3RhY2NlbnRsb25nc0FFYWN1dGVhZWFjdXRlT3NsYXNoYWN1dGVvc2xhc2hhY3V0ZVNjb21tYWFjY2VudHNjb21tYWFjY2VudGhzdXBlcmlvcmZyZW5jaGZyYW5jbGlyYXVuaTIwQTZwZXNldGFydXBlZXVuaTIwQTlhZmlpNTc2MzZhZmlpNjEyODlhZmlpNjEzNTJwdWJsaXNoZWRzZXJ2aWNlbWFya2VzdGltYXRlZGFycm93bGVmdGFycm93dXBhcnJvd3JpZ2h0YXJyb3dkb3dudHJpYW5nbGVyaWdodHRyaWFuZ2xlbGVmdGJsYWNrc3F1YXJldHJpYWd1cHRyaWFnZG5jaXJjbGVzb2xpZGJsYWNrc3RhcmJhbGxvdGJveGJveGNoZWNrZWRkaWFtb25kY2hlY2ttYXJrZl9mX2pmX2pwZXJ0aG91c2FuZC5vbnVtemVyby50emVyb3plcm8udG51bXR3by50bnVtdGhyZWUudG51bWZvdXIudG51bWZpdmUudG51bXNpeC50bnVtc2V2ZW4udG51bWVpZ2h0LnRudW1uaW5lLnRudW1wZXJjZW50Lm9udW16ZXJvLnRvbnVtb25lLnRvbnVtdHdvLnRvbnVtdGhyZWUudG9udW1mb3VyLnRvbnVtZml2ZS50b251bXNpeC50b251bXNldmVuLnRvbnVtZWlnaHQudG9udW1uaW5lLnRvbnVtY29sb25tb25ldGFyeS5vbnVtRXVyby5vbnVtZmxvcmluLm9udW1udW1iZXJzaWduLm9udW1zdGVybGluZy5vbnVteWVuLm9udW1jZW50Lm9udW16ZXJvLmRub21vbmUuZG5vbXR3by5kbm9tdGhyZWUuZG5vbWZvdXIuZG5vbWZpdmUuZG5vbXNpeC5kbm9tc2V2ZW4uZG5vbWVpZ2h0LmRub21uaW5lLmRub216ZXJvLm51bXJvbmUubnVtcnR3by5udW1ydGhyZWUubnVtcmZvdXIubnVtcmZpdmUubnVtcnNpeC5udW1yc2V2ZW4ubnVtcmVpZ2h0Lm51bXJuaW5lLm51bXJBYnJldmUuc21jcEFtYWNyb24uc21jcEFvZ29uZWsuc21jcEFFYWN1dGUuc21jcENhY3V0ZS5zbWNwQ2Nhcm9uLnNtY3BDY2lyY3VtZmxleC5zbWNwQ2RvdGFjY2VudC5zbWNwRGNhcm9uLnNtY3BEY3JvYXQuc21jcEVicmV2ZS5zbWNwRWNhcm9uLnNtY3BFZG90YWNjZW50LnNtY3BFbWFjcm9uLnNtY3BFbmcuc21jcEVvZ29uZWsuc21jcEdicmV2ZS5zbWNwR2NpcmN1bWZsZXguc21jcEdjb21tYWFjY2VudC5zbWNwR2RvdGFjY2VudC5zbWNwSGNpcmN1bWZsZXguc21jcEhiYXIuc21jcElicmV2ZS5zbWNwSUouc21jcEltYWNyb24uc21jcElvZ29uZWsuc21jcEl0aWxkZS5zbWNwSmNpcmN1bWZsZXguc21jcEtjb21tYWFjY2VudC5zbWNwTGFjdXRlLnNtY3BMY2Fyb24uc21jcExjb21tYWFjY2VudC5zbWNwTGRvdC5zbWNwTmFjdXRlLnNtY3BOY2Fyb24uc21jcE5jb21tYWFjY2VudC5zbWNwT2JyZXZlLnNtY3BPaHVuZ2FydW1sYXV0LnNtY3BPbWFjcm9uLnNtY3BPc2xhc2hhY3V0ZS5zbWNwUmFjdXRlLnNtY3BSY2Fyb24uc21jcFJjb21tYWFjY2VudC5zbWNwU2FjdXRlLnNtY3BTY2VkaWxsYS5zbWNwU2NpcmN1bWZsZXguc21jcFNjb21tYWFjY2VudC5zbWNwVGJhci5zbWNwVGNhcm9uLnNtY3BUY29tbWFhY2NlbnQuc21jcFVicmV2ZS5zbWNwVWh1bmdhcnVtbGF1dC5zbWNwVW1hY3Jvbi5zbWNwVW9nb25lay5zbWNwVXJpbmcuc21jcFV0aWxkZS5zbWNwV2NpcmN1bWZsZXguc21jcFljaXJjdW1mbGV4LnNtY3BaYWN1dGUuc21jcFpkb3RhY2NlbnQuc21jcElkb3RhY2NlbnQuc21jcHBhcmVubGVmdC5jYXNlcGFyZW5yaWdodC5jYXNlYnJhY2tldGxlZnQuY2FzZWJyYWNrZXRyaWdodC5jYXNlYnJhY2VsZWZ0LmNhc2VicmFjZXJpZ2h0LmNhc2VleGNsYW1kb3duLmNhc2VxdWVzdGlvbmRvd24uY2FzZWd1aWxsZW1vdGxlZnQuY2FzZWd1aWxsZW1vdHJpZ2h0LmNhc2VndWlsc2luZ2xsZWZ0LmNhc2VndWlsc2luZ2xyaWdodC5jYXNlaHlwaGVuLmNhc2VlbmRhc2guY2FzZWVtZGFzaC5jYXNlcGVyaW9kY2VudGVyZWQuY2FzZWJ1bGxldC5jYXNlY2VudC5jYXNlY29tbWFhY2NlbnRvbmUudG51bUxzbGFzaC5zbWNwT0Uuc21jcFNjYXJvbi5zbWNwWmNhcm9uLnNtY3BleGNsYW0uc21jcGRvbGxhci5vbnVtYW1wZXJzYW5kLnNtY3B6ZXJvLm9udW1vbmUub251bXR3by5vbnVtdGhyZWUub251bWZvdXIub251bWZpdmUub251bXNpeC5vbnVtc2V2ZW4ub251bWVpZ2h0Lm9udW1uaW5lLm9udW1xdWVzdGlvbi5zbWNwQS5zbWNwQi5zbWNwQy5zbWNwRC5zbWNwRS5zbWNwRi5zbWNwRy5zbWNwSC5zbWNwSS5zbWNwSi5zbWNwSy5zbWNwTC5zbWNwTS5zbWNwTi5zbWNwTy5zbWNwUC5zbWNwUS5zbWNwUi5zbWNwUy5zbWNwVC5zbWNwVS5zbWNwVi5zbWNwVy5zbWNwWC5zbWNwWS5zbWNwWi5zbWNwZXhjbGFtZG93bi5zbWNwcXVlc3Rpb25kb3duLnNtY3BBZ3JhdmUuc21jcEFhY3V0ZS5zbWNwQWNpcmN1bWZsZXguc21jcEF0aWxkZS5zbWNwQWRpZXJlc2lzLnNtY3BBcmluZy5zbWNwQUUuc21jcENjZWRpbGxhLnNtY3BFZ3JhdmUuc21jcEVhY3V0ZS5zbWNwRWNpcmN1bWZs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Aj4AJwI+ACcCPgAnAj4AJwI+ACcB2AAbAjcARAI3AEQCNwBEAjcARAH3//4B9//+AdwALwF6ABUAswAZALMAEwCVABoAmAAeAX4AIwGcADcBNgAYAZwAIgGKACIArwApALsANwJJADcBlgA3AZUAIgD6ADcBTgAXAN8ACACzABkAswATALgAEgKyADAEhABHALgAEgNJAAoDqgAlA6UAJwNXAB0DSQAKA6oAKQGKAB0BigAhAYoAJwGKACEBbwAdAYoAIgGKACEBigAdAQgACgGKACkBigAlAYoAIQGKACcBigAhAW8AHQGKACIBigAhATYAGAF6ABUAmAAeAJUAGgH2AB0CpAAdAfYAHQH2AB0CPgAnAkYAMQLyABwCUwAcAWsAEQL9ACoCvQA7AfYAHQKhAAIBAgAAAXcAEwK/ABoCmwAqATUADgN6AA4DbQAOA0MADgEeAEQCRQAnAjcAPwLNACoCfQAnAuIAKgJ5ACcC4gAqAn0AJwE6AAoBHgAuAR4ARAFLAEQCRQAnAkUAJwJFACcCRQAnAkUAJwJFACcCRQAnAkUAJwJFACcCNwA/AjcAPwObACcCaQAqAuIAKgLiACoCbAAnAmwAJwNuACcCNwA/AV8ARAJSAA4DhwAOAqEAAgIZACgCoQACAhkAKAKhAAICGQAoAqoAKgHyACcCqgAqAfIAJwKqACoB8gAnAqoAKgHyACcCxgBHAp8AJwLgAAoCSgAnAkEARwItACcCQQBHAi0AJwJBAEcCLQAnAkEARwItACcCQQBHAi0AJwLNACoCRQAnAs0AKgJFACcCzQAqAkUAJwLNACoCRQAnAtMARwI4/+wC5QAKAjwACgED/+EA8f/YAQP/zADx/8MBA//UAPH/ygEDADsA8QAsAQMARwLlAEcB4gA4AeIACADx/5sCdgBHAg8ARAIPAEQB+gA/APEALgH6AD8A8QBEAfoAPwFIAEQCGQA/AV8ARALQAEcCOABJAtAARwI4AEkC0ABHAjgASQI4ADMC0ABHAjgARAL9ACoCPgAnAv0AKgI+ACcC/QAqAj4AJwJ1AEcBWwBEAnUARwFbAEQCdQBHAVsANwJSABwB2AAbAlIAHAHYABsCUgAcAdgAGwJBABwBPwAKAkEAHAFgAAoCQQAcAT8ACgLQAEcCNwBEAtAARwI3AEQC0ABHAjcARALQAEcCNwBEAtAARwI3AEQC0ABHAjcARAOHAAcC8wAFAn0AAgH3//4CTQAtAdwALwJNAC0B3AAvATUADgPA//4DbgAoAv0AKgI+ACcCXQAkAd0AGwGWADcCPAAKAhgAFgLjAAoClgAKBBkARwOHAAcDQwBEAfgARQRlAEcDCgAsAdwADwNKAB8CRgAAAkYAVgJGAC8CRgBXAksANgJLAAAClQAvAmj//gJo//4CtwAyAvcAAAKVAC0ClQAtAfUAAAITAAADWgAOAiYADgN+ABkCcAAuAmUAKAJlADsCZQA1AmUAKgJlAD4CZQAzAmUAQwJlADMCZQAsAlwAGQJlACgCZQCGAmUAOQJlADUCZQAqAmUAPgJlADMCZQBDAmUAMwJlACwCSAAnAmMAGgGBABIB/AATAbcADwItAAACSAAnAYoAHQEIAAoBigApAYoAJQGKACEBigAnAYoAIQFvAB0BigAiAYoAIQGKAB0BCAAKAYoAKQGKACUBigAhAYoAJwGKACEBbwAdAYoAIgGKACECSgAAAkoAAAJKAAADQ///AkgAJwJIACcCSAAnAkgAJwJuADkCdwAKAgMARAIDAEQCAwBEAgMARAKCAEQCAwBEAmwAJwJsACcCbAAnAmwAJwKEAEQClgAKAPL/yAKiAEQA8v/FAPIAMADy/9oBrAAGAikARAHQAEQB0ABEAdAARAHoAEQCggBEAoIARAKCAEQCkgAnApIAJwKSACcCkgAnAjIARAIyAEQCMgBEAf8AGAH/ABgB/wAYAf8AGAHgABcB4AAXAeAAFwJ8AEQCfABEAnwARAJ8AEQCfABEAnwARAMPAAQCLQAAAgkAJgIJACYA3QA1ARQAKgEVABIBCQAsAQkAEgEVAAUBFQARAPQANAHLABkB6gAeAeoAHgFAAB4BQAAeASwAHgJRAB4DQQAeAPYANQFmAEIB8gAnAPUAQgJlAIYB4QAKA6wAJwH/ABgCCQAmAMQAHQH/ABgCMwAYAmkAKgF8AA8CRQAkAjgAEgJEABwCWAA5AlkAKgIUABsCVAAqAlkAJwGMAAcCSgAAAj0ARAJIACcCbgBEAgMARAH1AEQCbAAnAoQARAD2AEQBrAAGAikARAHQAEQC5QBEAoIARAKSACcCHQBEApIAJwIyAEQB/wAYAeAAFwJ8AEQCSgAAAw8ABAJBAAICLQAAAgkAJgDEABwBjAASAkoAAAJKAAACSgAAAkoAAAJKAAACSgAAA0P//wJIACcCAwBEAgMARAIDAEQCAwBEAPL/1ADyAC8A8v/rAPL/1gJ3AAoCggBEApIAJwKSACcCkgAnApIAJwKSACcCkgAnAnwARAJ8AEQCfABEAnwARAItAAACHQBEAi0AAAJpAA4DWgAOAA4AAAABAAAACgBmAZwAAWxhdG4ACAAQAAJNT0wgAERST00gAEwAAP//ABcAAAABAAIAAwAEAAUACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYAAD//wABAAYAAP//AAEABwAZYzJzYwCYY2FzZQCeZG5vbQCkZnJhYwCqbGlnYQC4bG51bQC+bG9jbADEbG9jbADKbnVtcgDQb251bQDWb3JkbgDccG51bQDic2FsdADoc2luZgDuc21jcAD0c3MwMQD6c3MwMgEAc3MwMwEGc3MwNAEMc3MwNgESc3MwNwEYc3VicwEec3VwcwEkdG51bQEqemVybwEwAAAAAQANAAAAAQAbAAAAAQADAAAABQAEAAUABgAHAAgAAAABABYAAAABABcAAAABAAAAAAABAAEAAAABAAIAAAABABgAAAABAAwAAAABABoAAAABABUAAAABAAsAAAABAA4AAAABAA8AAAABABAAAAABABEAAAABABIAAAABABMAAAABABQAAAABAAoAAAABAAkAAAABABkAAAABABwAHwBAAEgAUABYAGAAaACAAIgAkACYAKAAqACwAOAA6ADwAPgBAAEIARABGAEgASgBMAE4AUABSAFQAVgBYAFoAAEAAAABATAAAQAAAAEBNAABAAAAAQE4AAEAAAABATYAAQAAAAEBNAAGAAAACQEyAUYBWgFuAYIBlgGqAb4B0gABAAAAAQHOAAYAAAABAcwAAQAAAAEB1gABAAAAAQHUAAEAAAABAfQAAQAAAAECFAAGAAAAFQI0AkYCWAJsAoAClgKsAr4C0gLmAvYDCAMaAy4DQgNSA2QDdgOKA54DsgABAAAAAQOWAAEAAAABBJwAAQAAAAEFvgABAAAAAQXoAAEAAAABBhIAAQAAAAEGJAABAAAAAQY6AAEAAAABBkQAAQAAAAEGSgAEAAAAAQaIAAEAAAABBvIAAQAAAAEHLAABAAAAAQdmAAEAAAABB44AAQAAAAEHtgABAAAAAQgUAAQAAAABCBYAAQAAAAEI3AACCP4AAwHKAcsCSQACCPIAAwHKAcsCSQABCPACAAABCOoB9gABCOQCAAADAAAAAwjoCO4I9gAAAAEAAAAdAAMAAAADCNQI2gjoAAAAAQAAAB0AAwAAAAMI2gjGCNQAAAABAAAAHQADAAAAAwisCLIIxgAAAAEAAAAdAAMAAAADCKYIngiyAAAAAQAAAB0AAwAAAAMIhAiKCKQAAAABAAAAHQADAAAAAwiKCHYIkAAAAAEAAAAdAAMAAAADCIIIYgh8AAAAAQAAAB0AAwAAAAMIdAhOCGgAAAABAAAAHQABCCoCAAADAAEIYAABCI4AAAABAAAAHgABCIYAUwACCIYAEQDlAOYA5wDoAPkA6QEDAJYApACpAQQBBQEGAQcBCAEJAOwAAgheABEBFQD3APgBFwD8ARYBCgELAQwBDQEOAQ8BEAERARIBEwEUAAIINgARARUA9wD4ARcA/AEWAQoBCwEMAQ0BDgEPARABEQESARMBFAADAAEHlAABCDAAAAABAAAAHgADAAEHggABCCQAAAABAAAAHgADAAIIGAdwAAEIDAAAAAEAAAAeAAMAAggEB1wAAQf+AAAAAQAAAB4AAwACB0gHUgABB/YAAQf8AAEAAAAeAAMAAwfsBzIHPAABB+YAAAABAAAAHgADAAIHJgcmAAEH3AABB8oAAAADAAEHFAABB8oAAQe4AAEAAAAeAAMAAge8BwAAAQekAAAAAQAAAB4AAwACBvoG7AABB64AAAAAAAMAAQbqAAEHngAAAAEAAAAeAAMAAgbYBsoAAQeSAAEHjAAAAAMAAQbGAAEHgAABB3oAAQAAAB4AAwACB3IGsgABB2YAAAABAAAAHgADAAIGqgaQAAEHUgAAAAAAAwABBpoAAQdCAAAAAQAAAB4AAwACBogGbgABB0IAAQcwAAAAAwABBnYAAQcwAAEHHgABAAAAHgADAAIHIgZiAAEHCgAAAAEAAAAeAAMAAQcUAAEG2AABBt4AAQAAAB4AAwACBtAHAAABBsoAAAABAAAAHgACBvwAhAJwAnICfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZAqACbAKxAm0CqgK3ApsCnAKeApoCnwKdAqECowKkAqUCogKnAqgCqQKmAqsCrQKuArACrAKvAm4CswK0ArUCsgK2ArgCbwExATMBSgE1AUkCHAIbAh0CHwIhAiICIAIjAiQCKAIlAicCKgImAiwCKwIuAi0CLwIwAjUCMwIxAjQCVwIyAjYCNwI4AjoCOQI7AjwCPgI9AikCQQI/AkACQwJFAkQCRgJIAkcCTAJLAkoCUgJPAk0CUQJOAlACUwJUAlUCVgIeAkICSQACBvoAkgJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCoAKGAmwCsQJtArcCqgKbApwCngKaAp8CnQKhAqMCpAKlAqICpwKoAqkCpgKrAq0CrgKwAqwCrwJuArMCtAK1ArICtgK4Am8CiQJ+ApYCbAI4AjoCOQKbApoCnAKeAp0CnwIcAhsCHQK2ArgCoAIeAlQCOwIcAhsCHQIfAiECIgIgAiMCJAIoAiUCJwIqAiYCLAIrAi4CLQIvAjACNQIzAjECNAIyAjYCNwKIAjgCOgI5AjsCPAI+Aj0CKQJBAj8CQAJDAkUCRAJGAkgCRwJMAksCSgJSAk8CTQJRAk4CUAJTAlQCVQJWApACHgJCAkkAAgb4ABYBLgEtAS8BRQE2AToBPAE9ATsBPwE+AUMBRAFAAUEBQgE3ATgBOQFNAUwBSwACBvYAFgEwAS4BRQE6ATwBPQE7AT8BPgFAAUEBQgFHATIBSAE0AUsBMwFJATUBSgExAAIG9AAKATABRwEyAUgBNAEzAUkBNQFKATEAAgbyAAwBLgFFAToBPAE9ATsBPwE+AUABQQFCAUsAAgbwAAYBLQE2ATcBOAE5AU0AAgbuAAQBLwFDAUQBTAACBuwAIAEwAS4BLQEvAUUBNgE6ATwBPQE7AT8BPgFDAUQBQAFBAUIBRwEyAUgBNAE3ATgBOQFNAUwBSwEzAUkBNQFKATEAAQbqAAEACAAMABoAIgAqADIAOgBAAEYATABSAFgAXgBkAroAAwBHAEoB6AADAEcASwK7AAMARwBNAU8AAwBHAS0BKgACAEMCuQACAEcBKwACAEkAbQACAEoB6QACAEsBLAACAEwAbgACAE0BTgACAS0AAgZ+AB4AegAGAewCawHtAe4B7wHwAfEB8gHzAfQA+gEnAGUABABiAGQAYQAFABEAEgATABQAFQAWABcAGAAZABoAAgZYAB4CAwJxAfUCcwJ0AnUCdgJ3AngCeQJ6AnsCfAIGAgQCBQICAeoCAAIBAfYB+AH5AfoB+wH8Af0B/gH/AfcAAgZQABUB7AJrAe0B7gHvAfAB8QHyAfMB9AHrAfYB9wH4AfkB+gH7AfwB/QH+Af8AAgY2ABUBRgARABMAFAAVABYAFwAYABkAGgJzAnQCdQJ2AncCeAJ5AnoCewJ8ABIAAgYcADACWAJZAmQCWgJbAlwCXQJeAmkCYAJiAmMCZQJnAmgCYQJfAmYAegAGAewCawHtAe4B7wHwAfEB8gHzAfQA+gEnAGUABABiAGQAYQAFABEAEgATABQAFQAWABcAGAAZABoAAgYaAAIBRgHrAAEGGAAFABAAYgB4AKIAuAAIABIAGgAiACoAMgA6AEIASgCbAAMAEAATAQEAAwAQABQAngADABAAFQD9AAMAEAAZAJsAAwBjABMBAQADAGMAFACeAAMAYwAVAP0AAwBjABkAAgAGAA4BAgADABAAFAECAAMAYwAUAAQACgASABoAIgCjAAMAEAAVAP4AAwAQABkAowADAGMAFQD+AAMAYwAZAAIABgAOAP8AAwAQABkA/wADAGMAGQACAAYADgEAAAMAEAAZAQAAAwBjABkAAgVYABIAiwDtAcwA8gCPAPQA9QD2AgcCCAIJAgoCCwIMAg0CDgIPAhAAAQADAakBqgJHAAIAAQARABoAAAABAAEAEgABAAIAEABjAAEAAQATAAEAAQAVAAEAAQAUAAEAAQAZAAEAAQAWAAEAAQAYAAIABwAQABAAAABjAGMAAQCbAJsAAgCeAJ4AAwCjAKMABAD9AQIABQIHAhAACwACAAECEQIaAAAAAQABABAAAgAFAAUABQAAAAkACgABAA0ADwADABEAGgAGAGEAYQAQAAEAAQBCAAEAAQBQAAEAAQAPAAEAAQBVAAEAAQBJAAEAAQD2AAEAAQBUAAEAAQD1AAEAAQBFAAEAAQBPAAEAAQDyAAEAAQBTAAEAAQD0AAIAAgARABEAAAAVABoAAQABAIQAAgAHACAAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7AGAAewCKAIwAjQCOAJoAnQCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcBMAEyATQBRwFIAVABUgFUAVYBWAFaAVwBXgFgAWIBZAFmAWgBagFsAW4BcAFyAXQBdgF4AXoBfAF+AYABgQGDAYUBiAGKAYwBjgGQAZIBlAGXAZkBmwGdAZ8BoQGjAaUBpwGpAasBrQGvAbEBswG1AbcBuQG7Ab0BvwHBAcMBxgHIAcoAAQCSAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwCQAJEAkgCTAJQAogCnAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5AEtAS4BLwE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUsBTAFNAVEBUwFVAVcBWQFbAV0BXwFhAWMBZQFnAWkBawFtAW8BcQFzAXUBdwF5AXsBfQF/AYIBhAGGAYcBiQGLAY0BjwGRAZMBlQGYAZoBnAGeAaABogGkAaYBqAGqAawBrgGwAbIBtAG2AbgBugG8Ab4BwAHCAcQBxQHHAckBywABABYAQgBNAFoAkACSAMgAyQDKAMsAzADNAOIA4wFRAVMBVQGJAYsBjQGPAcABxwABABYAKABCAJAAyADJAMoAywDMAM0BUQFTAVUBbAFuAXABcgHHAisCLAItAi4ChAABAAoAKAFsAW4BcAFyAisCLAItAi4ChAABAAwAQgCQAMgAyQDKAMsAzADNAVEBUwFVAccAAQAGAE0AkgGJAYsBjQGPAAEABABaAOIA4wHAAAEAIAAoAEIATQBaAJAAkgDIAMkAygDLAMwAzQDiAOMBUQFTAVUBbAFuAXABcgGJAYsBjQGPAcABxwIrAiwCLQIuAoQAAQABAEcAAgAEAeoB6gAAAfUCBgABAnECcQATAnMCfAAUAAIACQAEAAYAAAARABoAAwBhAGIADQBkAGUADwB6AHoAEQD6APoAEgEnAScAEwHsAfQAFAJrAmsAHQACAAMAEQAaAAABRgFGAAoCcwJ8AAsAAgADAesB9AAAAfYB/wAKAmsCawAUAAEAMAAJAAoADgA8AD4AXABeAGAAYQBqAGsAbABvAHIAdAB4AHsAiQHqAfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIG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AAD/tQAA/87/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/pgAAAAAAAAAAAAAAAAAAAAAAAAAA/+cAAAAAAAAAAAAAAAAAAAAA/9gAAP/x//sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAAAAAAAD/7AAAAAAAAAAA/7//3QAAAAAAAAAAAAAAAAAAAAAAAP/YAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/EAAAAAAAA//EAAAAAAAAAAP/Y/9gAAAAAAAAAAAAAAAAAAAAAAAD/2AAA//b/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAAAAAAAP/sAAAAAAAAAAD/yf/d//sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAA/+L/4v/d/9j/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/iAAAAAAAAAAAAAAAA/8T/tf/TAAAAAAAAAAAAAP/nAAAAAAAA/+cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6EAAAAAAAAAAAAAAAAAAAAAAAAAAP/OAAD/5//nAAD/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84ACgABAEUAIgAjACQAJQAwADIAjQCaAJ0AqwCsAK0ArgCvALAAsQC7ALwAvQC+AL8BJAFQAVIBVAFWAVgBWgFcAV4BYAGZAZsBnQHIAhsCHAIdAh8CIAIhAiICIwIkAj8CQAJBAkICfgJ/AoACgQKMAo4CmgKbApwCnQKeAp8CoQKqAqwCrQKuAq8CsAKxArcAAQA1ACcAKAAsAC0AjAEwATEBMgEzATQBNQFHAUgBbAFuAXABcgGFAYgBigImAicCKAIqAisCLQIwAjMCNAI3AjwCPQI+AlcCbQKCAoMChAKFAoYCiAKKAosCoAKiAqMCpAKlAqYCpwKoAqkCqwABACoAKwAxADMANAA1ADYAwADBAMIAwwDEAYEBnwGhAaMBpQGnAakBqwGtAa8BswG1AbcBuQG7AcoCOAI6AkYCRwJIAkkCSgJLAkwCbAJuAokCjQKQApEAAQAYADcAOAA6AMUAxgG/AjICTQJOAk8CUAJRAlQChwKSApMClAKWArICswK0ArUCtgK4AAEAPQAHAAsADgAbABwAOwBCAEMARABGAEcASABJAEwATgBPAFAAUQBSAGEAbwByAHQAiQCQAJMAlACiAKcAxwDOASkBKgErASwBLwFFAUsBVQFpAXUBhgGHAZMBlgGYAcEBwwHFAccCVQJWAmQCZQJmAmcCaAJvAnIClwK5AAEAMQADAAgACQANAA8AEQAYABoAOQA8AEEAUwBUAFUAVgBXAFgAWQBaAFsAXABjAGgAaQB1AHYAdwB5AHsA4gDjAS4BQgGgAaIBpAGqAawBsAG8AcABywISAhgCWAJaAlwCXwKVAAIAIwAjACMAAgAkACQABAAlACUABgAwADAABgAyADIABgCNAI0ABgCaAJoABgCdAJ0ABgCxALEABAC7AL8ABgFWAVYABAFYAVgABAFaAVoABAFcAVwABAFeAV4ABgFgAWAABgGZAZkABgGbAZsABgGdAZ0ABgHIAcgABgIbAh0AAQIfAiIABQIjAiQABwI/AkIABwJ+An4AAQJ/An8AAwKAAoAABQKBAoEABwKMAowABwKOAo4ABwKaAp8AAQKhAqEABQKqAqoABwKsArEABwK3ArcABwACAIQAAwADABAACAAIABAACwALAAsADQANACQADwAPACQAIAAgAAoAIgAiACAAJAAkAAYAKAAoAAYAKwArAAEAMAAwAAYAMgAyAAYANAA0AAIANQA1AAMANgA2AAUANwA3AAcAOAA4AAgAOQA5ACIAOgA6AAkAOwA7ACMAQQBBABAARwBHABEAVQBVABIAVgBWABMAVwBXABQAWABYABUAWgBaABYAaABpABAAbQBuABEAcABwAA4AcQBxAA8AdAB0AB0AdQB2ACQAdwB3ABAAeQB5ACQAigCKACAAjQCOAAYAmQCZABAApQClABAAqwCwACAAsQCxAAYAuwC/AAYAwADAAAIAwQDEAAUAxQDGAAkAxwDHACMA4gDjABYBJAEkACABKQEpABEBKwEsABEBLwEvABMBMAEwAAYBMQExABcBMgEyAAYBMwEzABcBNAE0AAYBNQE1ABcBRwFIAAYBSQFKABcBTgFPABEBUAFQACABUgFSACABVAFUACABVgFWAAYBWAFYAAYBWgFaAAYBXAFcAAYBbAFsAAYBbgFuAAYBcAFwAAYBcgFyAAYBgwGDAAEBmQGZAAYBmwGbAAYBnQGdAAYBpQGlAAIBpwGnAAIBqQGpAAIBqwGrAAMBrAGsABIBrQGtAAMBrgGuABIBrwGvAAMBsAGwABIBswGzAAUBtQG1AAUBtwG3AAUBuQG5AAUBuwG7AAUBvAG8ABMBvQG9AAgBvwG/AAkBwAHAABYBwQHBACMBwwHDACMBxQHFABEBxgHGACAByAHIAAYBygHKAAIB6AHpABECGwIeAB8CHwIiABcCKwIuABcCNgI2ABwCPwJCABcCSgJMAAQCTQJRABgCUwJTABoCVAJUABsCZAJnAA0CaAJoAAwCbQJtABcCfQJ9AB4CfgJ+AB8CgAKAABcChAKEABcChwKHABwCjAKMABcCjgKOABcCkQKRAAQCkgKSABgCkwKTABkClAKUABoClQKVACEClgKWABsCmgKgAB8CoQKhABcCrAKxABcCsgK1ABgCtgK2ABsCuAK4ABsCuQK7ABEAAgAhACcAJwABACgAKAADACwALAAGAC0ALQAIAIwAjAAIATABMAADATEBMQAEATIBMgADATMBMwAEATQBNAADATUBNQAEAUcBSAADAWwBbAADAW4BbgADAXABcAADAXIBcgADAYUBhQAGAYgBiAAIAYoBigAIAisCKwAEAi0CLQAEAjACMAAFAjMCNAAFAjcCNwAHAjwCPgAFAlcCVwAFAoMCgwACAoQChAAEAoUChgAFAogCiAAHAooCiwAFAqYCqQAFAqsCqwAFAAIAlAADAAMADwAHAAcABAAIAAgADwALAAsAJgANAA0ABQAOAA4AHQAPAA8ABQAgACAADgAiACIAAgAkACQAEQAoACgAEQArACsAAwAwADAAEQAyADIAEQA1ADUAAQA2ADYAJAA3ADcACwA4ADgADAA5ADkACgA6ADoADQBBAEEADwBCAEIAFABEAEYAFQBHAEcAFgBIAEgAFQBQAFAAFQBSAFIAFQBVAFUAFwBWAFYAGABXAFcAGQBYAFgAGgBZAFkAGwBaAFoAHABoAGkADwBtAG4AFgBvAG8AHQBwAHAAJwBxAHEAKAByAHIAHQB0AHQAJQB1AHYABQB3AHcADwB5AHkABQCJAIkAHQCKAIoAAgCNAI4AEQCQAJAAFACTAJQAFQCZAJkADwClAKUADwCnAKcAFQCrALAAAgCxALEAEQC7AL8AEQDBAMQAJADFAMYADQDOAM4AFQDiAOMAHAEkASQAAgEpASkAFgErASwAFgEuAS4AFQEvAS8AGAEwATAAEQExATEAHgEyATIAEQEzATMAHgE0ATQAEQE1ATUAHgFCAUIAFQFFAUUAFQFHAUgAEQFJAUoAHgFLAUsAFQFOAU8AFgFQAVAAAgFSAVIAAgFUAVQAAgFVAVUAFAFWAVYAEQFYAVgAEQFaAVoAEQFcAVwAEQFfAV8AFQFpAWkAFQFsAWwAEQFuAW4AEQFwAXAAEQFyAXIAEQGDAYMAAwGZAZkAEQGbAZsAEQGdAZ0AEQGrAasAAQGsAawAFwGtAa0AAQGuAa4AFwGvAa8AAQGwAbAAFwGzAbMAJAG1AbUAJAG3AbcAJAG5AbkAJAG7AbsAJAG8AbwAGAG9Ab0ADAG/Ab8ADQHAAcAAHAHFAcUAFgHGAcYAAgHHAccAFAHIAcgAEQHoAekAFgIbAh4ABgIfAiIAHgIrAi4AHgI2AjYABwI/AkIAHgJGAkkAHwJKAkwAIAJNAlEAIQJTAlMAIwJUAlQAEAJkAmcAEwJoAmgAEgJtAm0AHgJuAm4AHwJyAnIACQJ+An4ABgKAAoAAHgKEAoQAHgKHAocABwKMAowAHgKOAo4AHgKQApAAHwKRApEAIAKSApIAIQKTApMAIgKUApQAIwKVApUACAKWApYAEAKaAqAABgKhAqEAHgKsArEAHgKyArUAIQK2ArYAEAK4ArgAEAK5ArsAFgACAB4AKwArAAgAMQAxAAEAMwAzAAMANAA0AAQANQA1AAYANgA2AAgAwADAAAQAwQDEAAgBgQGBAAgBnwGfAAMBoQGhAAMBowGjAAMBpQGlAAQBpwGnAAQBqQGpAAQBqwGrAAYBrQGtAAYBrwGvAAYBswGzAAgBtQG1AAgBtwG3AAgBuQG5AAgBuwG7AAgBygHKAAQCRgJJAAUCSgJMAAcCbgJuAAUCjQKNAAICkAKQAAUCkQKRAAcAAgCuAAMAAwAIAAcABwAQAAgACAAIAAsACwABAA0ADQARAA4ADgAUAA8ADwARABsAHAAgACIAIgANACQAJAADACgAKAADACsAKwAOADAAMAADADIAMgADADQANAAfADUANQAEADcANwAFADgAOAAGADkAOQAPADoAOgAHAEEAQQAIAEIAQgASAEQARgATAEcARwAiAEgASAATAE4ATwAjAFAAUAATAFEAUQAjAFIAUgATAFMAUwAjAFQAVAAZAFUAVQAaAFYAVgApAFcAVwAbAFgAWAAcAFkAWQAdAFoAWgAeAFsAWwAjAGgAaQAIAG0AbgAiAG8AbwAUAHIAcgAUAHUAdgARAHcAdwAIAHkAeQARAIkAiQAUAIoAigANAI0AjgADAJAAkAASAJMAlAATAJkAmQAIAKUApQAIAKcApwATAKsAsAANALEAsQADALsAvwADAMAAwAAfAMUAxgAHAM4AzgATAOIA4wAeASQBJAANASkBKQAiASsBLAAiAS4BLgATAS8BLwApATABMAADATEBMQACATIBMgADATMBMwACATQBNAADATUBNQACAUIBQgATAUUBRQATAUcBSAADAUkBSgACAUsBSwATAU4BTwAiAVABUAANAVIBUgANAVQBVAANAVUBVQASAVYBVgADAVgBWAADAVoBWgADAVwBXAADAV8BXwATAWkBaQATAWwBbAADAW4BbgADAXABcAADAXIBcgADAYMBgwAOAZMBkwAjAZgBmAAjAZkBmQADAZsBmwADAZ0BnQADAaIBogAjAaUBpQAfAacBpwAf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"

/***/ }),
/* 51 */
/***/ (function(module, exports) {

	module.exports = "data:application/x-font-ttf;base64,AAEAAAAUAQAABABAR1BPU/YRHoAAAPxQAAAJ0kdTVUJttj0SAAEGJAAAAzhMVFNIeXl6gwAABlQAAAEPT1MvMomPbWUAAAHIAAAAYFZETVhtI3SnAAAHZAAABeBjbWFw2W5+4AAAJbwAAAYyY3Z0IAlqAisAAC5UAAAAKGZwZ20GWZw3AAAr8AAAAXNnYXNwABcACQAA/EAAAAAQZ2x5Zv17JjEAAC58AAC4BGhkbXht/cHiAAANRAAAGHhoZWFk+5nu8AAAAUwAAAA2aGhlYQaaA5wAAAGEAAAAJGhtdHgICTK3AAACKAAABCxrZXJud1J3HgAA6JgAAAdEbG9jYRCbQMgAAOaAAAACGG1heHADIgJKAAABqAAAACBuYW1l6e9oKAAA79wAAAkvcG9zdFfmAlsAAPkMAAADM3ByZXBRkCT9AAAtZAAAAPAAAQAAAAEAAFvzvCFfDzz1ABkD6AAAAADMh0fcAAAAAMyHY4z/1/8QA4cDkgAAAAkAAgAAAAAAAAABAAAC7v8GAEsDuf/X/9EDhwABAAAAAAAAAAAAAAAAAAABCwABAAABCwB7AAYAWgAEAAEAAAAAAAoAAAIAAXMAAgABAAMBkQGQAAUAAAK8AooAAACMArwCigAAAd0AMgD6AAACAAYGAwAAAgAEgAAAr1AAAEoAAAAAAAAAAHB5cnMAQAAg+wYC7v8GAEsDkgDwIAAAAQAAAAABwgKoAAAAIAAEAggAKAIIACgBGAAAARgAAAO5ADIDpwAyAbMAPwOBADMBdQA2AaAAMQD/AFACOgBVAjoAdQHgADwBDgBPAXwARgI6ADICOgA9AjoAGgIwACgA5gBGARgARgEYAA8B9AAwAjoAXADrAA4BaABGAOsARgFI//wCOgA8AjoAUAI6ADkCOgBfAjoAKwI6ACUCOgA5AjoANQI6AEQCOgA5AOsADgI6AGgCOgBVAjoAagGQAA8CTgA8AkQACwIcAEYCCAA8AhIARgHvAEYCJgA8AkkARgDrAEYBuAAUAhgARgHtAEYCvABGAl0ARgJOADwCCABGAk4APAIcAEYB6gAzAgMAFAJYAEECRAALA6cAQQJEABYCEgAoAjoAKAEYAEYBSP/8ARgADwI6ADYBDv/sAcwAsQHgADwBjwAyAeAAMgHHADIBVAAUAeAAPADmAEYA5v/nAb4ARgD/AEYB6gA8AiYAKAHgADwB4AAyAScAPAFKABkB5QA8AbYAEQLQADwBogAVAeAAPAGLAB4BNgAPAP8AVAE2AA8COgBIAcIALQFyADIBuABBAjoALwG4AEABaABpAk4AFAISABQCsgA8ArIAPALGABgBzACyAcwAWgNeABQDXgAoAjoAKAI6AFcBkAA1AaQAOgEEAE0COgBVAjoAVwIoADECKP/ZAdYAMwHWADsC3wBLAf4ABQMHAAUBdwAaAXcAEwDXABYA1wAOAjoAVQE4AAECOgAoAQ4ALwEOADcBwgAtAOsARgNIABoA5gBGAcwAcAHMAFoBzAB9AcwAgADmAEYBuACDAaQAkQHMAIgBuADDAWgASAI6ABQDUgAUA2EAFAKjACUC3wAyARgAAAHMADIBzAAyAcwAMgHMADIBlgAyAZAAFwHWADwB1gA8AOsARgIwABQCSQAUAkQARgLQADwB6gA8AeUAPAHlADwB5QA8AeUAPAFoACUBaAAlA2sAIgN5ACkDeQApAkQACwJEAAsCRAALAkQACwJEAAsCRAALAhIAKAISACgCTgA8AiYAKAImACgCJgAoAiYAKAImACgB6gA8AeoAPAHqADwB6gA8AeoAPAHqADwB6gA8AhIARgHqADMBiwAeAjoAKALpADwCJgAoAiYAKAJE/+wB5QA8Al0ARgIIADwCWABBAlgAQQJYAEECWABBAhIARgISAEYCEgBGAOsARgDrAAIA6//tAOsAFAJOADwCTgA8Ak4APAJOADwDOQAoA0EAEAMbADwCOgBcAXcAEwDXAA4CTgAIAiYAKAHt/+YA///mAkQACwImADwCTgA8AigAMQIo/9cB4AAyAOYACgDmAEYA5v/rAOYAAAIIAEYBuwAeAkQACwJEAAsCRAALAkQACwJEAAsCRAALAu8AEAGkACMBpAAjAaQAIwGkACMBpAAjAaQAIwGkACMCowAjAAABCwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE3AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBATc3AQEBAQEBAQEBAQEBAQEBAQEBAQEBNwAAAAABAAEBAQEBAAwA+Aj/AAgACP/+AAkACf/9AAoACv/9AAsAC//9AAwAC//9AA0ADP/8AA4ADf/8AA8ADv/8ABAAD//8ABEAEP/7ABIAEf/7ABMAEv/7ABQAE//7ABUAFP/6ABYAFf/6ABcAFv/6ABgAFv/6ABkAF//6ABoAGP/5ABsAGf/5ABwAGv/5AB0AG//5AB4AHP/4AB8AHf/4ACAAHv/4ACEAH//4ACIAIP/3ACMAIP/3ACQAIf/3ACUAIv/3ACYAI//2ACcAJP/2ACgAJf/2ACkAJv/2ACoAJ//1ACsAKP/1ACwAKf/1AC0AKv/1AC4AK//0AC8AK//0ADAALP/0ADEALf/0ADIALv/0ADMAL//zADQAMP/zADUAMf/zADYAMv/zADcAM//yADgANP/yADkANf/yADoANv/yADsANv/xADwAN//xAD0AOP/xAD4AOf/xAD8AOv/wAEAAO//wAEEAPP/wAEIAPf/wAEMAPv/vAEQAP//vAEUAQP/vAEYAQP/vAEcAQf/uAEgAQv/uAEkAQ//uAEoARP/uAEsARf/uAEwARv/tAE0AR//tAE4ASP/tAE8ASf/tAFAASv/sAFEAS//sAFIAS//sAFMATP/sAFQATf/rAFUATv/rAFYAT//rAFcAUP/rAFgAUf/qAFkAUv/qAFoAU//qAFsAVP/qAFwAVf/pAF0AVv/pAF4AVv/pAF8AV//pAGAAWP/oAGEAWf/oAGIAWv/oAGMAW//oAGQAXP/oAGUAXf/nAGYAXv/nAGcAX//nAGgAYP/nAGkAYP/mAGoAYf/mAGsAYv/mAGwAY//mAG0AZP/lAG4AZf/lAG8AZv/lAHAAZ//lAHEAaP/kAHIAaf/kAHMAav/kAHQAa//kAHUAa//jAHYAbP/jAHcAbf/jAHgAbv/jAHkAb//iAHoAcP/iAHsAcf/iAHwAcv/iAH0Ac//iAH4AdP/hAH8Adf/hAIAAdf/hAIEAdv/hAIIAd//gAIMAeP/gAIQAef/gAIUAev/gAIYAe//fAIcAfP/fAIgAff/fAIkAfv/fAIoAf//eAIsAgP/eAIwAgP/eAI0Agf/eAI4Agv/dAI8Ag//dAJAAhP/dAJEAhf/dAJIAhv/cAJMAh//cAJQAiP/cAJUAif/cAJYAiv/cAJcAi//bAJgAi//bAJkAjP/bAJoAjf/bAJsAjv/aAJwAj//aAJ0AkP/aAJ4Akf/aAJ8Akv/ZAKAAk//ZAKEAlP/ZAKIAlf/ZAKMAlf/YAKQAlv/YAKUAl//YAKYAmP/YAKcAmf/XAKgAmv/XAKkAm//XAKoAnP/XAKsAnf/WAKwAnv/WAK0An//WAK4AoP/WAK8AoP/WALAAof/VALEAov/VALIAo//VALMApP/VALQApf/UALUApv/UALYAp//UALcAqP/UALgAqf/TALkAqv/TALoAq//TALsAq//TALwArP/SAL0Arf/SAL4Arv/SAL8Ar//SAMAAsP/RAMEAsf/RAMIAsv/RAMMAs//RAMQAtP/QAMUAtf/QAMYAtf/QAMcAtv/QAMgAt//QAMkAuP/PAMoAuf/PAMsAuv/PAMwAu//PAM0AvP/OAM4Avf/OAM8Avv/OANAAv//OANEAwP/NANIAwP/NANMAwf/NANQAwv/NANUAw//MANYAxP/MANcAxf/MANgAxv/MANkAx//LANoAyP/LANsAyf/LANwAyv/LAN0Ayv/KAN4Ay//KAN8AzP/KAOAAzf/KAOEAzv/KAOIAz//JAOMA0P/JAOQA0f/JAOUA0v/JAOYA0//IAOcA1P/IAOgA1f/IAOkA1f/IAOoA1v/HAOsA1//HAOwA2P/HAO0A2f/HAO4A2v/GAO8A2//GAPAA3P/GAPEA3f/GAPIA3v/FAPMA3//FAPQA4P/FAPUA4P/FAPYA4f/EAPcA4v/EAPgA4//EAPkA5P/EAPoA5f/EAPsA5v/DAPwA5//DAP0A6P/DAP4A6f/DAP8A6v/CAAAAFwAAARAJCQUFAwMJCAQIAwQCBQUEAgMFBQUFAgMDBQUCAwIDBQUFBQUFBQUFBQIFBQUEBQUFBQUEBQUCBAUEBgUFBQUGBAUFBQgFBQUDAwMFAgQEBAQEAwQCAgQCBAUEBAMDBAQGBAQEAwIDBQQDBAUEAwUFBgYGBAQICAUFBAQCBQUFBQQEBwUHAwMCAgUDBQICBAIIAgQEBAQCBAQEBAMFCAgGBwMEBAQEBAQEBAIFBQUGBAQEBAQDAwgICAUFBQUFBQUFBQUFBQUFBAQEBAQEBAUEBAUHBQUFBAUFBQUFBQUFBQICAgIFBQUFBwgHBQMCBQUEAgUFBQQGBAICAgIFBAUFBQUFBQcEBAQEBAQEBwAAAAoKBQUDAwoJBAkEBAMGBgUDBAYGBgYCAwMFBgIEAgMGBgYGBgYGBgYGAgYGBgQGBgUFBQUGBgIEBQUHBgYFBgYFBQYGCQYFBgMDAwYDBQUEBQUDBQICBAMFBgUFAwMFBAcEBQQDAwMGBQQEBgQEBgUHBwcFBQkJBgYEBAMGBgYGBQUHBQgEBAICBgMGAwMFAggCBQUFBQIEBAUEBAYJCQcHAwUFBQUEBAUFAgYGBgcFBQUFBQQECQkJBgYGBgYGBQUGBgYGBgYFBQUFBQUFBQUEBgcGBgYFBgUGBgYGBQUFAgICAgYGBgYICAgGBAIGBgUDBgYGBQYFAgICAgUEBgYGBgYGCAQEBAQEBAQHAAAACwoGBgMDCgoFCgQFAwYGBQMEBgYGBgMDAwYGAwQDBAYGBgYGBgYGBgYDBgYGBAYGBgYGBQYGAwUGBQgHBgYGBgUGBwYKBgYGAwQDBgMFBQQFBQQFAwMFAwUGBQUDBAUFCAUFBAMDAwYFBAUGBQQGBggICAUFCQkGBgQFAwYGBgYFBQgGCQQEAgIGAwYDAwUDCQMFBQUFAwUFBQUEBgkKBwgDBQUFBQQEBQUDBgYGCAUFBQUFBAQKCgoGBgYGBgYGBgYGBgYGBgUFBQUFBQUGBQQGCAYGBgUHBgcHBwcGBgYDAwMDBgYGBgkJCQYEAgYGBQMGBgYGBwUDAwMDBgUGBgYGBgYIBQUFBQUFBQgAAAAMCwYGAwMLCwULBAUDBwcGAwUHBwcHAwMDBgcDBAMEBwcHBwcHBwcHBwMHBwcFBwcGBgYGBwcDBQYGCAcHBgcHBgYHBwsHBgcDBAMHAwYGBQYFBAYDAwUDBgcGBgQEBgUJBQYFBAMEBwUEBQcFBAcGCAgJBgYKCgcHBQUDBwcHBwYGCQYJBQUDAwcEBwMDBQMKAwYGBgYDBQUGBQQHCgoICQMGBgYGBQUGBgMHBwcJBgYGBgYEBAsLCwcHBwcHBwYGBwcHBwcHBgYGBgYGBgYGBQcJBwcHBgcGBwcHBwYGBgMDAwMHBwcHCgoKBwUDBwcGAwcHBwYHBgMDAwMGBQcHBwcHBwkFBQUFBQUFCAAAAA0MBwcEBAwMBgwFBQMHBwYEBQcHBwcDBAQHBwMFAwQHBwcHBwcHBwcHAwcHBwUICAcHBwYHCAMGBwYJCAgHCAcGBwgIDAgHBwQEBAcEBgYFBgYEBgMDBgMGBwYGBAQGBgkFBgUEAwQHBgUGBwYFCAcJCQkGBgsLBwcFBQMHBwcHBgYKBwoFBQMDBwQHBAQGAwsDBgYGBgMGBQYGBQcLCwkKBAYGBgYFBQYGAwcICAkGBgYGBgUFCwwMCAgICAgIBwcIBwcHBwcGBgYGBgYGBwYFBwoHBwgGCAcICAgIBwcHAwMDAwgICAgLCwoHBQMIBwYDCAcIBwgGAwMDAwcGCAgICAgICgUFBQUFBQUJAAAADw4ICAQEDg4HDQYGBAkJBwQGCQkJCAMEBAgJBAUEBQkJCQkJCQkJCQkECQkJBgkJCAgIBwgJBAcIBwsJCQgJCAcICQkOCQgJBAUECQQHBwYHBwUHAwMHBAcIBwcEBQcHCwYHBgUEBQkHBgcJBwUJCAoKCwcHDQ0JCQYGBAkJCAgHBwsIDAYGAwMJBQkEBAcEDQMHBwcHAwcGBwcFCQ0NCgsEBwcHBwYGBwcECAkJCwcHBwcHBQUNDQ0JCQkJCQkICAkICAgICAcHBwcHBwcIBwYJCwgICQcJCAkJCQkICAgEBAQECQkJCQwNDAkGAwkIBwQJCAkICQcDAwMDCAcJCQkJCQkLBgYGBgYGBgoAAAAQDwgIBAQPDwcOBgcECQkIBAYJCQkJBAQECAkEBgQFCQkJCQkJCQkJCQQJCQkGCQkJCAgICQkEBwkICwoJCAkJCAgKCQ8JCAkEBQQJBAcIBggHBQgEBAcECAkICAUFCAcMBwgGBQQFCQcGBwkHBgkICwsLBwcODgkJBgcECQkJCQgIDAgMBgYDAwkFCQQEBwQNBAcHBwcEBwcHBwYJDg4LDAQHBwcHBwYICAQJCQkMCAgICAgGBg4ODgkJCQkJCQgICQkJCQkJCAgICAgICAgIBgkMCQkJCAoICgoKCggICAQEBAQJCQkJDQ0NCQYDCQkIBAkJCQgJCAQEBAQIBwkJCQkJCQwHBwcHBwcHCwAAABEQCQkFBRAQBw8GBwQKCggFBgoKCgoEBQUJCgQGBAYKCgoKCgoKCgoKBAoKCgcKCgkJCQgJCgQHCQgMCgoJCgoICQoKEAoJCgUGBQoFCAgHCAgGCAQECAQICQgIBQYIBwwHCAcFBAUKCAYHCgcGCgkMDAwICA8PCgoHBwQKCgkJCAgNCQ0GBgQECgUKBQUIBA4ECAgICAQHBwgHBgoODwsNBQgICAgHBwgIBAoKCgwICAgICAYGDw8PCgoKCgoKCQkKCQkJCQkICAgICAgICQgHCg0JCQoICgkKCgoKCQkJBAQEBAoKCgoODg4KBgQKCQgECgkKCQoIBAQEBAkICgoKCgoKDQcHBwcHBwcMAAAAExIKCgUFEhIIEQcIBQsLCQUHCwsLCwQFBQoLBAcEBgsLCwsLCwsLCwsECwsLCAsLCgoKCQoLBAgKCQ0MCwoLCgkKCwsSCwoLBQYFCwUJCQgJCQYJBAQIBQkKCQkGBgkIDggJCAYFBgsJBwgLCAcLCg0NDQkJEBALCwgIBQsLCgoJCQ4KDwcHBAQLBgsFBQkEEAQJCQkJBAgICQgHCxAQDQ4FCQkJCQgICQkECwsLDgkJCQkJBwcRERELCwsLCwsKCgsKCgoKCgkJCQkJCQkKCQgLDgoKCwkMCgsLCwsKCgoEBAQECwsLCxAQDwsHBAsKCQULCgsKCwkEBAQECggLCwsLCwsOCAgICAgICA0AAAAVFAsLBgYUFAkTCAkFDAwKBggMDAwMBQYGCwwFCAUHDAwMDAwMDAwMDAUMDAwIDAwLCwsKDAwFCQsKDw0MCwwLCgsNDBQMCwwGBwYMBgoKCAoKBwoFBQkFCgwKCgYHCgkPCQoIBwUHDAkICQwJCAwLDg4PCgoSEgwMCAkFDAwMDAoKDwsQCAgFBQwHDAYGCQUSBQoKCgoFCQkKCQgMEhIODwYKCgoKCQgKCgUMDAwPCgoKCgoICBITEwwMDAwMDAsLDAwMDAwMCgoKCgoKCgsKCAwQDAwMCg0LDQ0NDQsLCwUFBQUMDAwMERIRDAgFDAwKBQwMDAwMCgUFBQULCQwMDAwMDBAJCQkJCQkJDgAAABgXDAwHBxcWChYJCgYODgwGCQ4ODg0GBwcMDgYJBggODg4ODg4ODg4OBg4ODgoODg0MDQwNDgYLDQwRDw4MDg0MDA4OFg4NDgcIBw4GCwwKDAsIDAYGCwYMDQwMBwgMCxEKDAkHBgcOCwkLDgsJDg0RERELCxUVDg4KCgYODg0NCwsSDBMJCQUFDgcOBgYLBhQGCwsLCwYLCgsLCQ4UFRASBwsLCwsKCgsLBg0ODhEM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DQ8NGgwVFhIWFRAWCwsVDBcZFhYODxYUIRMWEg4MDhoVERQaFBEbGCAgIRUVKCgaGhITDBoaGRkWFiIXJBERCgoaDhoMDBULJwsVFRUVCxQTFRQRGicoHyINFRUVFRMSFhYLGhsbIRcWFhYWEREoKSkbGxsbGxsYGBsZGRkZGRcXFxcXFxcYFxIaIhkZGxYcGBwcHBwYGBgLCwsLGxsbGyYmJRoRChsZFwwbGRsZGRYLCwsLGBQbGxsbGxsjExMTExMTEx8AAAAyMBoaDg4wLxYtExUNHR0YDhMdHR0cDA4OGR0MEgwQHR0dHR0dHR0dHQwdHR0UHh0bGhsZHB0MFhsZIx4eGh4bGRoeHS8dGx0OEA4dDhcYFBgXERgMDBYNGRwYGA8RGBYkFRgUEA0QHRcTFh0WEh4bIyMkFxcrKx0dFBUNHR0cHBgYJRonExMLCx0QHQ4OFwwqDBcXFxcMFhUXFhIdKysiJQ4XFxcXFBQYGAwcHR0kGRgYGBgSEiwsLB0dHR0dHRsbHhwcHBwcGRkZGRkZGRsZFB0lHBwdGB4aHh4eHhsbGwwMDAweHh4eKSooHRMLHhwZDR0cHhwbGAwMDAwaFh0dHR0dHSYVFRUVFRUVIwAAADYzHBwPDzMyFzAUFg4fHxoPFR8fHx4MDw8bHw0TDRIfHx8fHx8fHx8fDR8fHxYgHx0cHRseIA0YHRsmISAcIB4aHCAfMh8dHw8SDx8PGRoWGhkSGgwMGA4aHhoaEBIaGCcXGhURDhEfGBQYHxgTIB0lJSYZGS8vHx8WFw4fHx4eGRkoHCoUFAwMHxEfDw8YDS0MGRkZGQwYFxkYEx8uLyQoDxkZGRkWFhkZDR4gHycaGhoaGhMTLzAwHx8fHx8fHR0gHh4eHh4aGhoaGhoaHRoVHygeHh8aIRwgICAgHR0dDQ0NDSAgICAtLSsfFAwgHhsOHx4gHR0aDAwMDBwYHx8fHx8fKRcXFxcXFxclAAAAOjceHhAQNzYZNBYYDyEhHBAWISEhIA0QEB0hDhUOEyEhISEhISEhISEOISEhFyIiHx4fHSAiDhofHSkjIh4iHxweIyI2Ih8hEBMQIRAbHBccGhQcDQ0aDxwgHBwRExwZKhgcFxIPEiEaFRohGhUiHygoKRsbMjIhIRcYDyEhICAbGyseLRYWDAwhEiEQEBoOMQ0bGxsbDRoYGxoV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AEEAu//EAEEAvP/EAEEAwP/iAEEAwf/iAEEAwv/iAEEAw//iAEEAxP/iAEEAxf/iAEEAxv/iAEEAx//iAEEAyP/iAEEAyf/iAEEAyv/iAEEAy//iAEEA0P/iAEEA1P/iAEEA5v/iAEEA5/+wAEEA7f/iAEIALf/YAEIANf+wAEIAt//YAEIAuP/YAEIAuf/YAEIAuv/YAEIAu//YAEIAvP/YAEIA5/+6AEQALf/EAEQANf+cAEQATf+mAEQATv+wAEQAT/+mAEQAUP/YAEQAUv/sAEQAU//iAEQAVv+mAEQAV/+mAEQAWP+cAEQAWf+cAEQAWv+cAEQAW//EAEQAXP+mAEQAXf/EAEQAXv+mAEQAX/+wAEQAYP+6AEQAYf/EAEQAj//sAEQAoP+wAEQAof+mAEQAov+wAEQAo/+mAEQApP+mAEQAp//OAEQAqf/iAEQAqv/YAEQArP+mAEQArf+mAEQArv+mAEQAr/+wAEQAsP+mAEQAsf/EAEQAsv+cAEQAt/+wAEQAuP+wAEQAuf+wAEQAuv+wAEQAu/+wAEQAvP+wAEQAwP+mAEQAwf+mAEQAwv+mAEQAw/+wAEQAxP+6AEQAxf+wAEQAxv+wAEQAx/+6AEQAyP+6AEQAyf+wAEQAyv+wAEQAy/+wAEQA0P+mAEQA1P+mAEQA5v+mAEQA5/+cAEQA7f+mAEQA9v/sAEQA9//sAEQA+AAUAEQA+f/sALcAP/+6ALcAQf/EALcAQv/YALcARP+wALcAvv+wALgAP/+6ALgAQf/EALgAQv/YALgARP+wALgAvv+wALkAP/+6ALkAQf/EALkAQv/YALkARP+wALkAvv+wALoAP/+6ALoAQf/EALoAQv/YALoARP+wALoAvv+wALsAP/+6ALsAQf/EALsAQv/YALsARP+wALsAvv+wALwAP/+6ALwAQf/EALwAQv/YALwARP+wALwAvv+wAL4ALf/EAL4ANf+IAL4ATf+mAL4ATv+wAL4AT/+mAL4AUP/YAL4AUv/sAL4AU//iAL4AVv+mAL4AV/+mAL4AWP+cAL4AWf+cAL4AWv+cAL4AW//EAL4AXP+mAL4AXf/EAL4AXv+mAL4AX/+wAL4AYP+6AL4AYf/EAL4Aj//sAL4AoP+wAL4Aof+mAL4Aov+wAL4Ao/+mAL4ApP+mAL4Ap//OAL4Aqf/iAL4Aqv/YAL4ArP+mAL4Arf+mAL4Arv+mAL4Ar/+wAL4AsP+mAL4Asf/EAL4Asv+cAL4At/+wAL4AuP+wAL4Auf+wAL4Auv+wAL4Au/+wAL4AvP+wAL4AwP+mAL4Awf+mAL4Awv+mAL4Aw/+wAL4AxP+6AL4Axf+wAL4Axv+wAL4Ax/+6AL4AyP+6AL4Ayf+wAL4Ayv+wAL4Ay/+wAL4A0P+mAL4A1P+mAL4A5v+mAL4A5/+cAL4A7f+mAL4A9v/sAL4A9//sAL4A+AAUAL4A+f/sAAAAIwGqAAEAAAAAAAAAgwAAAAEAAAAAAAEABgCDAAEAAAAAAAIABACJAAEAAAAAAAMAMACNAAEAAAAAAAQACwC9AAEAAAAAAAUABwDIAAEAAAAAAAYACwDPAAEAAAAAAAcAMQDaAAEAAAAAAAgAIQELAAEAAAAAAAkADwEsAAEAAAAAAAoAfgE7AAEAAAAAAAsAEgG5AAEAAAAAAAwAEgHLAAEAAAAAAA0AgwHdAAEAAAAAAA4AEgJgAAEAAAAAABAABgJyAAEAAAAAABEABAJ4AAEAAAAAABIACwJ8AAMAAQQJAAABBgKHAAMAAQQJAAEADAONAAMAAQQJAAIADgOZAAMAAQQJAAMAYAOnAAMAAQQJAAQAFgQHAAMAAQQJAAUADgQdAAMAAQQJAAYAFgQrAAMAAQQJAAcAYgRBAAMAAQQJAAgAQgSjAAMAAQQJAAkAHgTlAAMAAQQJAAoA/AUDAAMAAQQJAAsAJAX/AAMAAQQJAAwAJAYjAAMAAQQJAA0BBgZHAAMAAQQJAA4AJAdNAAMAAQQJABAADAdxAAMAAQQJABEACAd9Q29weXJpZ2h0IChjKSAyMDEyIGJ5IEVwaXBoYW55IFNvbHV0aW9ucy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTWFkZSBleGNsdXNpdmVseSBmb3IgRXBpcGhhbnkgU29sdXRpb25zIEx0ZC4sIHRvIHVzZSBhcyB0aGV5IHBsZWFzZS5TY2lGbHlTYW5zU3VvbWlUeXBlRm91bmRyeSxTdW9taUZpbmxhbmQ6IFNjaUZseS1TYW5zOiAyMDEyU2NpRmx5LVNhbnMwMDEuMDAwU2NpRmx5LVNhbnNTY2lGbHktU2FucyBpcyBhIHRyYWRlbWFyayBvZiBFcGlwaGFueSBTb2x1dGlvbnMuU3VvbWkgVHlwZSBGb3VuZHJ5LCBTdW9taSBGaW5sYW5kVG9taSBIYWFwYXJhbnRhQ29weXJpZ2h0IChjKSAyMDEyIGJ5IEVwaXBoYW55IFNvbHV0aW9ucy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTWFkZSBleGNsdXNpdmVseSBmb3IgRXBpcGhhbnkgU29sdXRpb25zLCB0byB1c2UgYXMgdGhleSBwbGVhc2UuaHR0cDovL3d3dy50eXBlLmZpaHR0cDovL3d3dy50eXBlLmZpQ29weXJpZ2h0IChjKSAyMDEyIGJ5IEVwaXBoYW55IFNvbHV0aW9ucy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTWFkZSBleGNsdXNpdmVseSBmb3IgRXBpcGhhbnkgU29sdXRpb25zIEx0ZC4sIHRvIHVzZSBhcyB0aGV5IHBsZWFzZS5odHRwOi8vd3d3LnR5cGUuZmlTY2lGbHlTYW5zU2NpRmx5LVNhbnMAQwBvAHAAeQByAGkAZwBoAHQAIAAoAGMAKQAgADIAMAAxADIAIABiAHkAIABFAHAAaQBwAGgAYQBuAHkAIABTAG8AbAB1AHQAaQBvAG4AcwAuACAAQQBsAGwAIAByAGkAZwBoAHQAcwAgAHIAZQBzAGUAcgB2AGUAZAAuACAATQBhAGQAZQAgAGUAeABjAGwAdQBzAGkAdgBlAGwAeQAgAGYAbwByACAARQBwAGkAcABoAGEAbgB5ACAAUwBvAGwAdQB0AGkAbwBuAHMAIABMAHQAZAAuACwAIAB0AG8AIAB1AHMAZQAgAGEAcwAgAHQAaABlAHkAIABwAGwAZQBhAHMAZQAuAFMAYwBpAEYAbAB5AFIAZQBnAHUAbABhAHIAUwB1AG8AbQBpAFQAeQBwAGUARgBvAHUAbgBkAHIAeQAsAFMAdQBvAG0AaQBGAGkAbgBsAGEAbgBkADoAIABTAGMAaQBGAGwAeQAtAFMAYQBuAHMAOgAgADIAMAAxADIAUwBjAGkARgBsAHkALQBTAGEAbgBzADAAMAAxAC4AMAAwADAAUwBjAGkARgBsAHkALQBTAGEAbgBzAFMAYwBpAEYAbAB5AC0AUwBhAG4AcwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEUAcABpAHAAaABhAG4AeQAgAFMAbwBsAHUAdABpAG8AbgBzAC4AUwB1AG8AbQBpACAAVAB5AHAAZQAgAEYAbwB1AG4AZAByAHkALAAgAFMAdQBvAG0AaQAgAEYAaQBuAGwAYQBuAGQAVABvAG0AaQAgAEgAYQBhAHAAYQByAGEAbgB0AGEAQwBvAHAAeQByAGkAZwBoAHQAIAAoAGMAKQAgADIAMAAxADIAIABiAHkAIABFAHAAaQBwAGgAYQBuAHkAIABTAG8AbAB1AHQAaQBvAG4AcwAuACAAQQBsAGwAIAByAGkAZwBoAHQAcwAgAHIAZQBzAGUAcgB2AGUAZAAuACAATQBhAGQAZQAgAGUAeABjAGwAdQBzAGkAdgBlAGwAeQAgAGYAbwByACAARQBwAGkAcABoAGEAbgB5ACAAUwBvAGwAdQB0AGkAbwBuAHMALAAgAHQAbwAgAHUAcwBlACAAYQBzACAAdABoAGUAeQAgAHAAbABlAGEAcwBlAC4AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAHQAeQBwAGUALgBmAGkAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAHQAeQBwAGUALgBmAGkAQwBvAHAAeQByAGkAZwBoAHQAIAAoAGMAKQAgADIAMAAxADIAIABiAHkAIABFAHAAaQBwAGgAYQBuAHkAIABTAG8AbAB1AHQAaQBvAG4AcwAuACAAQQBsAGwAIAByAGkAZwBoAHQAcwAgAHIAZQBzAGUAcgB2AGUAZAAuACAATQBhAGQAZQAgAGUAeABjAGwAdQBzAGkAdgBlAGwAeQAgAGYAbwByACAARQBwAGkAcABoAGEAbgB5ACAAUwBvAGwAdQB0AGkAbwBuAHMAIABMAHQAZAAuACwAIAB0AG8AIAB1AHMAZQAgAGEAcwAgAHQAaABlAHkAIABwAGwAZQBhAHMAZQAuAGgAdAB0AHAAOgAvAC8AdwB3AHcALgB0AHkAcABlAC4AZgBpAFMAYwBpAEYAbAB5AFMAYQBuAHMAAAIAAAAAAAD/fgAUAAAAAAAAAAAAAAAAAAAAAAAAAAABCwAAAQIAAgADAPQA9QDxAPYA8wDyAOgA7wDwAO4ABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAeAB8AIAAhACIAIwAkACUAJgAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEUARgBHAEgASQBLAEwATQBOAE8AUQBSAFMAVABVAFcAWABZAFoAWwBcAF0AXgBfAGAAYQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAJQAlQCWAJwAnQCeAKMApACmAKcBAwCpAKoAqwCyALMAtAC1ALYAtwC4ALwAvQC+AL8AwgEEAMYA1wDYANkBBQDbANwA3QDeAN8A4ADhAQYBBwEIAQkBCgELAHMAcgBxAHAAbwCiAOwAugAdAMAAwQAnAFAAeAB+AH8AgACBAFYA5QCSAJsAmgBjAGIArQCuAMcAyQDrALsAZwB5AHoAewB8AH0ARABuAG0AbABrAGoAaQBlAOQA5wDmAKAAmADqAOkAlwBmAGQAaADWANUA1ADIAMoAywDMAM0AzgDPANAA0QDTAK8AsQCQALAAkwDFAMQAkQChAOIA4wEMAQ0BDgDSAJ8BDwB1AHQAdwB2AO0ASgEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgNOVUwFRGVsdGEOcGVyaW9kY2VudGVyZWQGbWFjcm9uBEV1cm8DZmZpA2ZmbANzX3QDY190B3VuaTAwQTAFYWx0X0EFYWx0X0cFYWx0X1EFYWx0X2cKYWx0X0FhY3V0ZQphbHRfQWdyYXZlD2FsdF9BY2lyY3VtZmxleA1hbHRfQWRpZXJlc2lzCmFsdF9BdGlsZGUJYWx0X0FyaW5nBmFsdF9BRQVhbHRfYQphbHRfYWFjdXRlCmFsdF9hZ3JhdmUPYWx0X2FjaXJjdW1mbGV4DWFsdF9hZGllcmVzaXMKYWx0X2F0aWxkZQlhbHRfYXJpbmcGYWx0X2FlAAAAAAMACAACABAAAf//AAMAAQAAAAoAIAA6AAFsYXRuAAgABAAAAAD//wACAAAAAQACY3BzcAAOa2VybgAUAAAAAQAAAAAAAQABAAIABgAOAAEAAAABABQAAgAAAAMAFgXIB9IAAQgGAAUABwAOAAEIQgAEAAAAFwA4AEoAeACSAJgBbgIkAkYDHAMuA0ADUgNkA3YDiAReBTQFRgVYBWoFfAWOBaAABAA//7oAQf/EAEL/2AC+/8QACwA8/+IAP/9+AEH/nABC/6YAvv9+AL//4gDi/+IA4//iAOT/4gDl/+IA7P/iAAYAt//OALj/zgC5/84Auv/OALv/zgC8/84AAQA//+wANQA1/4gAPP/iAE7/sABW/5wAWP+cAFn/kgBa/5IAW/+6AF7/fgBf/4gAYP9+AGH/iACg/7oAof+mAKL/ugCj/6YApP+mAKf/zgCp/8QAqv/EAKz/nACu/6YAr/+mALD/pgCx/7AAt/+6ALj/ugC5/7oAuv+6ALv/ugC8/7oAv//iAMD/pgDB/6YAwv+mAMP/ugDE/7AAxv+mAMf/xADI/8QAyf+wAMr/sADL/6YA0P+mANT/kgDi/+IA4//iAOT/4gDl/+IA5v+mAOf/kgDs/+IA7f+mAC0ANf+wAE7/4gBW/+IAWP/iAFn/4gBa/9gAW//sAF7/2ABf/9gAYP/sAGH/4gCg/+IAof/iAKL/4gCj/+IApP/iAKf/7ACs/+IArf/iAK7/4gCv/+IAsP/iALH/4gC3/8QAuP/EALn/xAC6/8QAu//EALz/xADA/+IAwf/iAML/4gDD/+IAxP/iAMb/4gDH/+IAyP/iAMn/4gDK/+IAy//iAND/4gDU/+IA5v/iAOf/sADt/+IACAA1/7AAt//YALj/2AC5/9gAuv/YALv/2AC8/9gA5/+6ADUANf+cAE7/sABT/+IAVv+mAFj/nABZ/5wAWv+cAFv/xABe/6YAX/+wAGD/ugBh/8QAj//sAKD/sACh/6YAov+wAKP/pgCk/6YAp//OAKn/4gCq/9gArP+mAK3/pgCu/6YAr/+wALD/pgCx/8QAt/+wALj/sAC5/7AAuv+wALv/sAC8/7AAwP+mAMH/pgDC/6YAw/+wAMT/ugDG/7AAx/+6AMj/ugDJ/7AAyv+wAMv/sADQ/6YA1P+mAOb/pgDn/5wA7f+mAPb/7AD3/+wA+AAUAPn/7AAEAD//ugBB/8QAQv/YAL7/sAAEAD//ugBB/8QAQv/YAL7/sAAEAD//ugBB/8QAQv/YAL7/sAAEAD//ugBB/8QAQv/YAL7/sAAEAD//ugBB/8QAQv/YAL7/sAAEAD//ugBB/8QAQv/YAL7/sAA1ADX/nABO/7AAU//iAFb/pgBY/5wAWf+cAFr/nABb/8QAXv+mAF//sABg/7oAYf/EAI//7ACg/7AAof+mAKL/sACj/6YApP+mAKf/zgCp/+IAqv/YAKz/pgCt/6YArv+mAK//sACw/6YAsf/EALf/sAC4/7AAuf+wALr/sAC7/7AAvP+wAMD/pgDB/6YAwv+mAMP/sADE/7oAxv+wAMf/ugDI/7oAyf+wAMr/sADL/7AA0P+mANT/pgDm/6YA5/+cAO3/pgD2/+wA9//sAPgAFAD5/+wANQA1/4gATv+wAFP/4gBW/6YAWP+cAFn/nABa/5wAW//EAF7/pgBf/7AAYP+6AGH/xACP/+wAoP+wAKH/pgCi/7AAo/+mAKT/pgCn/84Aqf/iAKr/2ACs/6YArf+mAK7/pgCv/7AAsP+mALH/xAC3/7AAuP+wALn/sAC6/7AAu/+wALz/sADA/6YAwf+mAML/pgDD/7AAxP+6AMb/sADH/7oAyP+6AMn/sADK/7AAy/+wAND/pgDU/6YA5v+mAOf/nADt/6YA9v/sAPf/7AD4ABQA+f/sAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAQAP/+6AEH/xABC/9gAvv/EAAECwgAEAAAADAAiADQAVgDQATYBWAFiAWwBdgGAAYoBlAAEADr/4gBE/34Avf9+APL/4gAIAC3/zgDw/84A/P/OAP3/zgD+/84A///OAQD/zgEB/84AHgAt/7oAOv/iAE3/pgBP/5IAUP/EAFf/kgBc/5IAXf+SAJv/xACc/8QApv+SALL/iACz/4gAxf+SAPD/ugDy/+IA/P+6AP3/ugD+/7oA//+6AQD/ugEB/7oBA/+SAQT/kgEF/5IBBv+SAQf/kgEI/5IBCf+SAQr/kgAZAC3/xABN/+IAT//iAFf/4gBc/+IAXf/iAKb/4gCy/+IAs//iAMX/4gDw/8QA/P/EAP3/xAD+/8QA///EAQD/xAEB/8QBA//iAQT/4gEF/+IBBv/iAQf/4gEI/+IBCf/iAQr/4gAIAC3/2ADw/9gA/P/YAP3/2AD+/9gA///YAQD/2AEB/9gAAgBE/7AAvf+wAAIARP+wAL3/sAACAET/sAC9/7AAAgBE/7AAvf+wAAIARP+wAL3/sAACAET/sAC9/7AAHQAt/8QATf+mAE//pgBQ/9gAUv/sAFf/pgBc/6YAXf/EAJv/2ACc/9gApv/EALL/nACz/5wAxf+wAPD/xAD8/8QA/f/EAP7/xAD//8QBAP/EAQH/xAED/6YBBP+mAQX/pgEG/6YBB/+mAQj/pgEJ/6YBCv+mAAIA1AAEAAAA9gEGAAIADAAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xP+m/6b/2P/s/6b/pv/E/5z/sAACAAsALQBFAAAAqwCrABkAtwC/ABoAzADNACMAzwDPACUA0wDTACYA1QDlACcA5wDoADgA7ADsADoA7gDuADsA+gD6ADwAAQAXAC0ANwA7AD0APwBBAEIARAC3ALgAuQC6ALsAvAC9AL4A8AD8AP0A/gD/AQABAQABAAwANwA7AD8AQQBCALcAuAC5ALoAuwC8AL4AAgAFAC0ALQAAAEQARAABALcAvgACAPAA8AAKAPwBAQALAAIAAgBEAEQAAQC9AL4AAQACAB0ALQAtAAIARABEAAEATQBNAAMATwBPAAQAUABQAAUAUgBSAAYAVwBXAAcAXABcAAgAXQBdAAkAYABgAAkAjwCPAAYAmwCcAAUAoACjAAQApACkAAMApgCnAAkAqQCqAAUArgCxAAgAsgCzAAoAtwC8AAIAvQC+AAEAwADEAAcAxQDLAAsA1ADUAAgA5gDmAAcA7QDtAAcA8ADwAAIA9gD5AAYA/AEBAAIBAwEKAAQAAAABAAAACgA0AIAAAWxhdG4ACAAKAAFUUksgABoAAP//AAUAAAABAAIABAAFAAD//wABAAMABmRsaWcAJmZyYWMALGxpZ2EAMmxpZ2EAOm9yZG4AQHNzMDEARgAAAAEAAwAAAAEAAAAAAAIAAQACAAAAAQACAAAAAQAEAAAAAQAFAAkAFAAkACwANAA8AEoAUgBaAGIABgAAAAUAVgBsAIAAlACoAAQAAAABAKwABAAAAAEAygAEAAAAAQDUAAYAAAAEAOoA/AEOASIAAQAAAAEBKAAEAAAAAQFMAAQAAAABAaoAAQAAAAEBwAADAAAABAHCAcgBwgHCAAAAAQAAAAYAAwAAAAMBrAGyAawAAAABAAAABwADAAAAAwGmAZ4BrAAAAAEAAAAGAAMAAAADAZIBigGeAAAAAQAAAAYAAwAAAAMBkAF2AYQAAAABAAAABgABAYIAAQAIAAMACAAQABgAmwADAFAAUgCcAAMAUABVAKkAAgBSAAEBXAABAAgAAQAEAKoAAgBVAAEBUAACAAoAFAABAAQAngACAFsAAQAEAJ0AAgBbAAMAAQE6AAEBRAAAAAEAAAAIAAMAAQEoAAEBOAAAAAEAAAAIAAMAAgEsARYAAQEgAAAAAQAAAAgAAwACARgBAgABARIAAAABAAAACAACAQoAEwDwAPEA8gEBAP8A/QEAAP4A/AEDAQkBCAEHAQYBBQEEAQoBAgD1AAEBCAADAAwAJgBQAAIABgAQAI4ABAAcAB0AHQCOAAQAiAAdAB0ABAAKABIAGgAiAAQAAwAcAB8ABQADABwAIQAEAAMAiAAfAAUAAwCIACEAAgAGAA4ABwADABwAIQAHAAMAiAAhAAEAKAABAAgAAgAGAA4AEgADABwAHQASAAMAiAAdAAIAjgACAHgAdwABAAEAHQABAAIAHACIAAEAAQAeAAEAAQAhAAEAAQAfAAEAAQAgAAEAAQBQAAEAAgBNALIAAgABAB0AJgAAAAEAAQDFAAEAAQBXAAEAAQAbAAEAEwAtADIAPAC3ALgAuQC6ALsAvADFAMYAxwDIAMkAygDLANAA5wD7AAEAAwAdAB4AIAABAAIAVwDF"

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAABI0lEQVQokZXSsUtbURQH4C+BLm0sLjZzeqcrYq5DQUGoW10c7OLQsZt7F/8MBwdL1yI4S8FCJ7EdBF9BfKI+OlcRQaFO5XVIrC9Bk/aMB757Duf+amVZgiLPxvAKExjFLxzjc4ip0Fe1siwVeTaJt9jFN5xjBAnz2A4xfeqBp4f7TazgfYjpoP/lIs+aeIeNENPebb+OBezchyDE9BMfsVjt1zGOr/ehSn1Ho8izZ1X4BJeDVIjpN67xtAqvMDYIFnn2SOfSfwfUu2u8HLLqNM5CTBdVuIV2kWezD0x7jtfYrPZv/7GFZfzQOdQ5GpjCDEqsVoNQqyTnMebcJecGJ/iCFt5gLcR01AOHVZFnL7p4PcR0+M+wi9s60fzwX7CLJ7D0B9WlZsEGf5rzAAAAAElFTkSuQmCC"

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ })
/******/ ])
});
;